            selectedTiposVenda = [];
            mainRedeGroupFilter = '';
            selectedMainRedes = [];
            mainTableState.currentPage = 1;

            mainRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            mainRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);

            document.querySelectorAll('#fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));
            selectedMainSupervisors = updateSupervisorFilter(document.getElementById('supervisor-filter-dropdown'), document.getElementById('supervisor-filter-text'), selectedMainSupervisors, allSalesData);
            selectedMainSuppliers = updateSupplierFilter(document.getElementById('fornecedor-filter-dropdown'), document.getElementById('fornecedor-filter-text'), selectedMainSuppliers, [...allSalesData, ...allHistoryData], 'main');
            selectedSellers = updateSellerFilter(selectedMainSupervisors, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData);
            selectedTiposVenda = updateTipoVendaFilter(tipoVendaFilterDropdown, tipoVendaFilterText, selectedTiposVenda, allSalesData);
            updateAllVisuals();
        }

        function resetCityFilters() {
            selectedCitySupervisors = [];
            cityNameFilter.value = '';
            cityCodCliFilter.value = '';
            selectedCitySellers = [];
            selectedCityRedes = [];
            cityRedeGroupFilter = '';
            selectedCityTiposVenda = [];

            selectedCitySupervisors = updateSupervisorFilter(document.getElementById('city-supervisor-filter-dropdown'), document.getElementById('city-supervisor-filter-text'), selectedCitySupervisors, allSalesData);
            selectedCitySellers = updateSellerFilter(selectedCitySupervisors, cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, allSalesData);
            selectedCityTiposVenda = updateTipoVendaFilter(cityTipoVendaFilterDropdown, cityTipoVendaFilterText, selectedCityTiposVenda, allSalesData);

            cityRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            cityRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, allClientsData);

            updateCityView();
        }

        function resetWeeklyFilters() {
            weeklySupervisorFilter.querySelectorAll('input:checked').forEach(cb => cb.checked = false);
            currentWeeklyFornecedor = '';
            document.querySelectorAll('#weekly-fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));
            updateWeeklyView();
        }

        function resetComparisonFilters() {
            selectedComparisonSupervisors = [];
            comparisonFilialFilter.value = 'ambas';
            currentComparisonFornecedor = '';
            comparisonCityFilter.value = '';
            selectedComparisonSellers = [];
            selectedComparisonSuppliers = [];
            selectedComparisonProducts = [];
            selectedComparisonTiposVenda = [];
            comparisonRedeGroupFilter = '';
            selectedComparisonRedes = [];

            comparisonRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            comparisonRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);

            document.querySelectorAll('#comparison-fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));

            updateAllComparisonFilters();
            updateComparisonView();
        }

        function resetStockFilters() {
            stockFilialFilter.value = 'ambas';
            currentStockFornecedor = '';
            selectedStockSupervisors = [];
            stockCityFilter.value = '';
            selectedStockSellers = [];
            selectedStockSuppliers = [];
            selectedStockProducts = [];
            selectedStockTiposVenda = [];
            stockRedeGroupFilter = '';
            selectedStockRedes = [];
            stockTrendFilter = 'all';

            document.querySelectorAll('.stock-trend-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.stock-trend-btn[data-trend="all"]').classList.add('active');

            stockRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            stockRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(stockRedeFilterDropdown, stockComRedeBtnText, selectedStockRedes, allClientsData, 'Com Rede');

            document.querySelectorAll('#stock-fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));

            customWorkingDaysStock = maxWorkingDaysStock;
            const daysInput = document.getElementById('stock-working-days-input');
            if(daysInput) daysInput.value = customWorkingDaysStock;

            handleStockFilterChange();
        }


        function getCityFilteredData(options = {}) {
            const { excludeFilter = null } = options;

            const sellersSet = new Set(selectedCitySellers);
            const cityInput = cityNameFilter.value.trim().toLowerCase();
            const codCli = cityCodCliFilter.value.trim();
            const tiposVendaSet = new Set(selectedCityTiposVenda);

            let clients = allClientsData;

            if (excludeFilter !== 'rede') {
                 if (cityRedeGroupFilter === 'com_rede') {
                    clients = clients.filter(c => c.ramo && c.ramo !== 'N/A');
                    if (selectedCityRedes.length > 0) {
                        const redeSet = new Set(selectedCityRedes);
                        clients = clients.filter(c => redeSet.has(c.ramo));
                    }
                } else if (cityRedeGroupFilter === 'sem_rede') {
                    clients = clients.filter(c => !c.ramo || c.ramo === 'N/A');
                }
            }

            if (excludeFilter !== 'supervisor' && selectedCitySupervisors.length > 0) {
                const rcasSet = new Set();
                selectedCitySupervisors.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                clients = clients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            if (excludeFilter !== 'seller' && sellersSet.size > 0) {
                const rcasSet = new Set();
                sellersSet.forEach(name => {
                    const code = optimizedData.rcaCodeByName.get(name);
                    if(code) rcasSet.add(code);
                });
                clients = clients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            if (excludeFilter !== 'city' && cityInput) {
                clients = clients.filter(c => (c.cidade || c.CIDADE) && (c.cidade || c.CIDADE).toLowerCase() === cityInput);
            }

            if (excludeFilter !== 'codcli' && codCli) {
                 clients = clients.filter(c => String(c['Código']) === codCli);
            }

            const clientCodes = new Set(clients.map(c => c['Código']));

            const supervisorSet = new Set(selectedCitySupervisors);

            const filters = {
                supervisor: supervisorSet,
                seller: sellersSet,
                city: cityInput,
                tipoVenda: tiposVendaSet,
                clientCodes: clientCodes
            };

            const sales = getFilteredDataFromIndices(optimizedData.indices.current, optimizedData.salesById, filters, excludeFilter);

            return { clients, sales };
        }

        function updateAllCityFilters(options = {}) {
            const { skipFilter = null } = options;

            if (skipFilter !== 'supervisor') {
                const { sales } = getCityFilteredData({ excludeFilter: 'supervisor' });
                selectedCitySupervisors = updateSupervisorFilter(document.getElementById('city-supervisor-filter-dropdown'), document.getElementById('city-supervisor-filter-text'), selectedCitySupervisors, sales);
            }

            const { sales: salesSeller } = getCityFilteredData({ excludeFilter: 'seller' });
            selectedCitySellers = updateSellerFilter(selectedCitySupervisors, cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, salesSeller, skipFilter === 'seller');

            const { sales: salesTV } = getCityFilteredData({ excludeFilter: 'tipoVenda' });
            selectedCityTiposVenda = updateTipoVendaFilter(cityTipoVendaFilterDropdown, cityTipoVendaFilterText, selectedCityTiposVenda, salesTV, skipFilter === 'tipoVenda');

            if (skipFilter !== 'rede') {
                 const { clients: clientsRede } = getCityFilteredData({ excludeFilter: 'rede' });
                 if (cityRedeGroupFilter === 'com_rede') {
                     selectedCityRedes = updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, clientsRede);
                 }
            }
        }

        function handleCityFilterChange(options = {}) {
            if (window.cityUpdateTimeout) clearTimeout(window.cityUpdateTimeout);
            window.cityUpdateTimeout = setTimeout(() => {
                updateAllCityFilters(options);
                updateCityView();
            }, 10);
        }

        function updateCitySuggestions(filterInput, suggestionsContainer, dataSource) {
            const forbidden = ['CIDADE', 'MUNICIPIO', 'CIDADE_CLIENTE', 'NOME DA CIDADE', 'CITY'];
            const inputValue = filterInput.value.toLowerCase();
            // Optimized: Handle datasource which might be Sales (no CIDADE) or Clients (has cidade)
            const allAvailableCities = [...new Set(dataSource.map(item => {
                if (item.CIDADE) return item.CIDADE; // Legacy / Aggregated
                if (item.cidade || item.CIDADE) return item.cidade || item.CIDADE; // Client Object with fallback
                // Lookup if sales object
                if (item.CODCLI) {
                    const c = clientMapForKPIs.get(String(item.CODCLI));
                    if (c) return c.cidade || c.CIDADE || c['Nome da Cidade'];
                }
                return 'N/A';
            }).filter(c => c && c !== 'N/A' && !forbidden.includes(c.toUpperCase())))].sort();
            const filteredCities = inputValue ? allAvailableCities.filter(c => c.toLowerCase().includes(inputValue)) : allAvailableCities;

            if (filteredCities.length > 0 && (document.activeElement === filterInput || !suggestionsContainer.classList.contains('manual-hide'))) {
                suggestionsContainer.innerHTML = filteredCities.map(c => `<div class="p-2 hover:bg-slate-600 cursor-pointer">${c}</div>`).join('');
                suggestionsContainer.classList.remove('hidden');
            } else {
                suggestionsContainer.classList.add('hidden');
            }
        }

        function validateCityFilter() {
            const selectedCity = cityNameFilter.value;
            if (!selectedCity) return;
            const { clients } = getCityFilteredData({ excludeFilter: 'city' });
            const availableCities = [...new Set(clients.map(c => c.cidade).filter(Boolean))];
            if (!availableCities.includes(selectedCity)) cityNameFilter.value = '';
        }

        function updateCityView() {
            cityRenderId++;
            const currentRenderId = cityRenderId;

            let { clients: clientsForAnalysis, sales: salesForAnalysis } = getCityFilteredData();
            const cidadeFiltro = cityNameFilter.value.trim();

            const referenceDate = lastSaleDate;
            const currentMonth = referenceDate.getUTCMonth();
            const currentYear = referenceDate.getUTCFullYear();

            const selectedTiposVendaSet = new Set(selectedCityTiposVenda);

            // Pre-aggregate "Sales This Month" for Status Classification
            const clientTotalsThisMonth = new Map();
            // Sync Pre-aggregation (O(N) is fast)
            for(let i=0; i<allSalesData.length; i++) {
                const s = (allSalesData instanceof ColumnarDataset) ? allSalesData.get(i) : allSalesData[i];
                if (selectedTiposVendaSet.size > 0 && !selectedTiposVendaSet.has(s.TIPOVENDA)) continue;

                const d = parseDate(s.DTPED);
                if (d && d.getUTCFullYear() === currentYear && d.getUTCMonth() === currentMonth) {
                    clientTotalsThisMonth.set(s.CODCLI, (clientTotalsThisMonth.get(s.CODCLI) || 0) + s.VLVENDA);
                }
            }

            const detailedDataByClient = new Map(); // Map<CODCLI, { total, pepsico, multimarcas }>

            // Pre-aggregate Sales Data for Analysis (Sync)
            salesForAnalysis.forEach(s => {
                const d = parseDate(s.DTPED);
                if (d && d.getUTCFullYear() === currentYear && d.getUTCMonth() === currentMonth) {
                    if (!detailedDataByClient.has(s.CODCLI)) {
                        detailedDataByClient.set(s.CODCLI, { total: 0, pepsico: 0, multimarcas: 0 });
                    }
                    const entry = detailedDataByClient.get(s.CODCLI);
                    entry.total += s.VLVENDA;
                    if (s.OBSERVACAOFOR === 'PEPSICO') entry.pepsico += s.VLVENDA;
                    else if (s.OBSERVACAOFOR === 'MULTIMARCAS') entry.multimarcas += s.VLVENDA;
                }
            });

            // Filter clients universe
            clientsForAnalysis = clientsForAnalysis.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                return (isAmericanas || rca1 !== '53' || clientsWithSalesThisMonth.has(c['Código']));
            });

            // Show Loading
            cityActiveDetailTableBody.innerHTML = '<tr><td colspan="6" class="text-center p-8"><svg class="animate-spin h-8 w-8 text-teal-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></td></tr>';
            cityInactiveDetailTableBody.innerHTML = '<tr><td colspan="6" class="text-center p-8"><svg class="animate-spin h-8 w-8 text-teal-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></td></tr>';

            const activeClientsList = [];
            const inactiveClientsList = [];
            const salesByActiveClient = {}; // Map for export/rendering

            // ASYNC CHUNKED PROCESSING
            runAsyncChunked(clientsForAnalysis, (client) => {
                const codcli = String(client['Código']);

                const registrationDate = parseDate(client.dataCadastro);
                client.isNew = registrationDate && registrationDate.getUTCMonth() === currentMonth && registrationDate.getUTCFullYear() === currentYear;

                const totalFaturamentoMes = clientTotalsThisMonth.get(codcli) || 0;

                if (totalFaturamentoMes > 0) {
                    activeClientsList.push(client);

                    // Detailed Data check
                    const details = detailedDataByClient.get(codcli);
                    if (details && details.total > 0) {
                        const outrosTotal = details.total - details.pepsico - details.multimarcas;
                        salesByActiveClient[codcli] = {
                            // Explicit copy to avoid Spread issues with Proxy
                            'Código': client['Código'],
                            fantasia: client.fantasia || client.FANTASIA || client['Nome Fantasia'],
                            razaoSocial: client.razaoSocial || client.RAZAOSOCIAL || client.Cliente,
                            cidade: client.cidade || client.CIDADE || client['Nome da Cidade'],
                            bairro: client.bairro || client.BAIRRO || client['Bairro'],
                            rcas: client.rcas,
                            isNew: client.isNew,
                            // Metrics
                            total: details.total,
                            pepsico: details.pepsico,
                            multimarcas: details.multimarcas,
                            outros: outrosTotal
                        };
                    }
                } else {
                    if (totalFaturamentoMes < 0) {
                        client.isReturn = true;
                    }
                    client.isNewForInactiveLabel = client.isNew && !parseDate(client.ultimaCompra);
                    inactiveClientsList.push(client);
                }
            }, () => {
                // --- ON COMPLETE (Render) ---
                if (currentRenderId !== cityRenderId) return;

                inactiveClientsForExport = inactiveClientsList;

                if (clientsForAnalysis.length > 0) {
                     const statusChartOptions = { animation: { duration: 800, easing: 'easeOutQuart' }, plugins: { legend: { position: 'bottom', labels: { color: '#cbd5e1' } }, tooltip: { callbacks: { label: function(context) { return context.label; } } }, datalabels: { formatter: (value, ctx) => { const total = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0); if (total === 0 || value === 0) return ''; const percentage = (value * 100 / total).toFixed(1) + "%"; return `${value}\n(${percentage})`; }, color: '#fff', backgroundColor: 'rgba(0, 0, 0, 0.6)', borderRadius: 4, padding: 4, font: { weight: 'bold', size: 12 }, textAlign: 'center' } } };
                    createChart('customerStatusChart', 'doughnut', ['Ativos no Mês', 'S/ Vendas no Mês'], [activeClientsList.length, inactiveClientsList.length], statusChartOptions);
                } else showNoDataMessage('customerStatusChart', 'Sem clientes no filtro para exibir o status.');

                const sortedActiveClients = Object.values(salesByActiveClient).sort((a, b) => b.total - a.total);
                activeClientsForExport = sortedActiveClients;

                cityActiveDetailTableBody.innerHTML = sortedActiveClients.slice(0, 500).map(data => {
                    const novoLabel = data.isNew ? `<span class="ml-2 text-xs font-semibold text-purple-400 bg-purple-900/50 px-2 py-0.5 rounded-full">NOVO</span>` : '';
                    let tooltipParts = [];
                    if (data.pepsico > 0) tooltipParts.push(`PEPSICO: ${data.pepsico.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
                    if (data.multimarcas > 0) tooltipParts.push(`MULTIMARCAS: ${data.multimarcas.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
                    if (data.outros > 0.001) tooltipParts.push(`OUTROS: ${data.outros.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
                    const tooltipText = tooltipParts.length > 0 ? tooltipParts.join('<br>') : 'Sem detalhamento de categoria';
                    const rcaVal = (data.rcas && data.rcas.length > 0) ? data.rcas[0] : '-';

                    const fantasia = data.fantasia || data.FANTASIA || data.Fantasia || '';
                    const razao = data.razaoSocial || data.Cliente || data.RAZAOSOCIAL || '';
                    const nome = fantasia || razao || 'N/A';
                    const cidade = data.cidade || data.CIDADE || data['Nome da Cidade'] || 'N/A';
                    const bairro = data.bairro || data.BAIRRO || 'N/A';

                    return `<tr class="hover:bg-slate-700"><td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-codcli="${data['Código']}">${data['Código']}</a></td><td class="px-4 py-2 flex items-center">${nome}${novoLabel}</td><td class="px-4 py-2 text-right"><div class="tooltip">${data.total.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}<span class="tooltip-text" style="width: max-content; transform: translateX(-50%); margin-left: 0;">${tooltipText}</span></div></td><td class="px-4 py-2">${cidade}</td><td class="px-4 py-2">${bairro}</td><td class="px-4 py-2">${rcaVal}</td></tr>`
                }).join('');

                inactiveClientsList.sort((a, b) => {
                    if (a.isReturn && !b.isReturn) return -1;
                    if (!a.isReturn && b.isReturn) return 1;
                    if (a.isNewForInactiveLabel && !b.isNewForInactiveLabel) return -1;
                    if (!a.isNewForInactiveLabel && b.isNewForInactiveLabel) return 1;
                    return (parseDate(b.ultimaCompra) || 0) - (parseDate(a.ultimaCompra) || 0);
                });

                cityInactiveDetailTableBody.innerHTML = inactiveClientsList.slice(0, 500).map(client => {
                    const novoLabel = client.isNewForInactiveLabel ? `<span class="ml-2 text-xs font-semibold text-purple-400 bg-purple-900/50 px-2 py-0.5 rounded-full">NOVO</span>` : '';
                    const devolucaoLabel = client.isReturn ? `<span class="ml-2 text-xs font-semibold text-red-400 bg-red-900/50 px-2 py-0.5 rounded-full">DEVOLUÇÃO</span>` : '';
                    const rcaVal = (client.rcas && client.rcas.length > 0) ? client.rcas[0] : '-';

                    const fantasia = client.fantasia || client.FANTASIA || client.Fantasia || '';
                    const razao = client.razaoSocial || client.Cliente || client.RAZAOSOCIAL || '';
                    const nome = fantasia || razao || 'N/A';
                    const cidade = client.cidade || client.CIDADE || client['Nome da Cidade'] || 'N/A';
                    const bairro = client.bairro || client.BAIRRO || 'N/A';
                    const ultCompra = client.ultimaCompra || client['Data da Última Compra'] || client.ULTIMACOMPRA;

                    return `<tr class="hover:bg-slate-700"><td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-codcli="${client['Código']}">${client['Código']}</a></td><td class="px-4 py-2 flex items-center">${nome}${novoLabel}${devolucaoLabel}</td><td class="px-4 py-2">${cidade}</td><td class="px-4 py-2">${bairro}</td><td class="px-4 py-2 text-center">${formatDate(ultCompra)}</td><td class="px-4 py-2">${rcaVal}</td></tr>`
                }).join('');

                const cityChartTitleEl = document.getElementById('city-chart-title');
                const cityChartOptions = { indexAxis: 'y', scales: { x: { grace: '15%' } }, plugins: { datalabels: { align: 'end', anchor: 'end', color: '#cbd5e1', font: { size: 14, weight: 'bold' }, formatter: (value) => (value / 1000).toFixed(1) + 'k', offset: 8 } } };
                const totalFaturamentoCidade = salesForAnalysis.reduce((sum, item) => sum + item.VLVENDA, 0);
                totalFaturamentoCidadeEl.textContent = totalFaturamentoCidade.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });

                if (totalClientesCidadeEl) {
                    totalClientesCidadeEl.textContent = clientsForAnalysis.length.toLocaleString('pt-BR');
                }

                if (cidadeFiltro) {
                    cityChartTitleEl.textContent = 'Top 10 Bairros';
                    const salesByBairro = {};
                    salesForAnalysis.forEach(sale => {
                        let bairro = sale.BAIRRO;
                        if (!bairro && sale.CODCLI) {
                            const c = clientMapForKPIs.get(String(sale.CODCLI));
                            if (c) bairro = c.bairro || c.BAIRRO || c['Bairro'];
                        }
                        bairro = bairro || 'N/A';
                        salesByBairro[bairro] = (salesByBairro[bairro] || 0) + sale.VLVENDA;
                    });
                    const sortedBairros = Object.entries(salesByBairro).sort(([, a], [, b]) => b - a).slice(0, 10);
                    createChart('salesByClientInCityChart', 'bar', sortedBairros.map(([name]) => name), sortedBairros.map(([, total]) => total), cityChartOptions);
                } else {
                    cityChartTitleEl.textContent = 'Top 10 Cidades';
                    const salesByCity = {};
                    salesForAnalysis.forEach(sale => {
                        let cidade = sale.CIDADE;
                        if (!cidade && sale.CODCLI) {
                            const c = clientMapForKPIs.get(String(sale.CODCLI));
                            if (c) cidade = c.cidade || c.CIDADE || c['Nome da Cidade'];
                        }
                        cidade = cidade || 'N/A';
                        salesByCity[cidade] = (salesByCity[cidade] || 0) + sale.VLVENDA;
                    });
                    const sortedCidades = Object.entries(salesByCity).sort(([, a], [, b]) => b - a).slice(0, 10);
                    createChart('salesByClientInCityChart', 'bar', sortedCidades.map(([name]) => name), sortedCidades.map(([, total]) => total), cityChartOptions);
                }
            }, () => currentRenderId !== cityRenderId);
        }

        function getWeekOfMonth(date) {
            const d = new Date(date);
            const day = d.getUTCDate();
            return Math.ceil(day / 7);
        }

        function calculateHistoricalBests() {
            const salesBySupervisorByDay = {};
            const mostRecentSaleDate = allSalesData.map(s => parseDate(s.DTPED)).filter(Boolean).reduce((a, b) => a > b ? a : b, new Date(0));
            const previousMonthDate = new Date(Date.UTC(mostRecentSaleDate.getUTCFullYear(), mostRecentSaleDate.getUTCMonth() - 1, 1));
            const previousMonth = previousMonthDate.getUTCMonth();
            const previousMonthYear = previousMonthDate.getUTCFullYear();
            const historyLastMonthData = allHistoryData.filter(sale => { const saleDate = parseDate(sale.DTPED); return saleDate && saleDate.getUTCMonth() === previousMonth && saleDate.getUTCFullYear() === previousMonthYear; });
            historyLastMonthData.forEach(sale => {
                if (!sale.SUPERV || sale.SUPERV === 'BALCAO' || !sale.DTPED) return;
                const saleDate = parseDate(sale.DTPED); if (!saleDate) return;
                const supervisor = sale.SUPERV.toUpperCase(); const dateString = saleDate.toISOString().split('T')[0];
                if (!salesBySupervisorByDay[supervisor]) salesBySupervisorByDay[supervisor] = {};
                if (!salesBySupervisorByDay[supervisor][dateString]) salesBySupervisorByDay[supervisor][dateString] = 0;
                salesBySupervisorByDay[supervisor][dateString] += sale.VLVENDA;
            });
            const bestDayByWeekdayBySupervisor = {};
            for (const supervisor in salesBySupervisorByDay) {
                const salesByDay = salesBySupervisorByDay[supervisor];
                const bests = {};
                for (const dateString in salesByDay) {
                    const date = new Date(dateString + 'T00:00:00Z');
                    const dayOfWeek = date.getUTCDay();
                    const total = salesByDay[dateString];
                    if (dayOfWeek >= 1 && dayOfWeek <= 5) { if (!bests[dayOfWeek] || total > bests[dayOfWeek]) bests[dayOfWeek] = total; }
                }
                bestDayByWeekdayBySupervisor[supervisor] = bests;
            }
            historicalBests = bestDayByWeekdayBySupervisor;
        }

        function populateWeeklyFilters() {
            const forbidden = ['SUPERV', 'CODUSUR', 'CODSUPERVISOR', 'NOME', 'CODCLI', 'SUPERVISOR'];
            const supervisors = [...new Set(allSalesData.map(item => item.SUPERV).filter(Boolean).filter(sup => sup !== 'BALCAO' && !forbidden.includes(sup.toUpperCase())))].sort();
            weeklySupervisorFilter.innerHTML = '';
            supervisors.forEach(sup => { weeklySupervisorFilter.innerHTML += `<div class="flex items-center"><input id="sup-check-${sup.replace(/\s+/g, '-')}" type="checkbox" value="${sup}" class="w-4 h-4 text-teal-600 bg-slate-700 border-slate-600 rounded focus:ring-teal-600 ring-offset-slate-800 focus:ring-2"><label for="sup-check-${sup.replace(/\s+/g, '-')}" class="ml-2 text-sm font-medium text-slate-300">${sup}</label></div>`; });
        }

        function updateWeeklyView() {
            const selectedSupervisors = Array.from(weeklySupervisorFilter.querySelectorAll('input:checked')).map(cb => cb.value);

            // Optimize using indices
            const filters = {};
            if (selectedSupervisors.length > 0) {
                 // getFilteredDataFromIndices expects 'supervisor' as string, but we have multiple.
                 // Indices for 'bySupervisor' is a Map<Name, Set<Id>>.
                 // We can manually intersect or just pass null if complex multiselect logic isn't supported by that helper yet.
                 // But getFilteredDataFromIndices doesn't support multiple supervisors array directly in 'filters.supervisor'.
                 // However, we can filter after or adapt.
                 // Let's manually use the indices here for maximum speed if we want to replace O(N).
            }

            // Actually, getFilteredDataFromIndices doesn't support multi-supervisor array yet, only single.
            // Let's stick to a simpler optimization: Use the pasta filter index if available.

            let dataForGeneralCharts;

            if (currentWeeklyFornecedor) {
                 // Use index
                 if (optimizedData.indices.current.byPasta.has(currentWeeklyFornecedor)) {
                     const ids = optimizedData.indices.current.byPasta.get(currentWeeklyFornecedor);
                     dataForGeneralCharts = [];
                     ids.forEach(id => dataForGeneralCharts.push(optimizedData.salesById.get(id)));
                 } else {
                     dataForGeneralCharts = [];
                 }
            } else {
                dataForGeneralCharts = allSalesData;
            }

            if (selectedSupervisors.length > 0) {
                const supSet = new Set(selectedSupervisors);
                dataForGeneralCharts = dataForGeneralCharts.filter(d => supSet.has(d.SUPERV));
            }

            const currentMonth = lastSaleDate.getUTCMonth(); const currentYear = lastSaleDate.getUTCFullYear();
            const monthSales = dataForGeneralCharts.filter(d => { if (!d.DTPED) return false; const saleDate = parseDate(d.DTPED); return saleDate && saleDate.getUTCMonth() === currentMonth && saleDate.getUTCFullYear() === currentYear; });
            const totalMes = monthSales.reduce((sum, item) => sum + item.VLVENDA, 0);
            totalMesSemanalEl.textContent = totalMes.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            const salesByWeekAndDay = {}; const dayNames = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            monthSales.forEach(sale => { const saleDate = parseDate(sale.DTPED); if (!saleDate) return; const weekNum = getWeekOfMonth(saleDate); const dayName = dayNames[saleDate.getUTCDay()]; if (!salesByWeekAndDay[weekNum]) salesByWeekAndDay[weekNum] = {}; if (!salesByWeekAndDay[weekNum][dayName]) salesByWeekAndDay[weekNum][dayName] = 0; salesByWeekAndDay[weekNum][dayName] += sale.VLVENDA; });
            const weekLabels = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta'];
            const weekNumbers = Object.keys(salesByWeekAndDay).sort((a,b) => a - b);
            const professionalPalette = ['#14b8a6', '#6366f1', '#ec4899', '#f97316', '#8b5cf6'];
            const currentMonthDatasets = weekNumbers.map((weekNum, index) => ({ label: `Semana ${weekNum}`, data: weekLabels.map(day => salesByWeekAndDay[weekNum][day] || 0), backgroundColor: professionalPalette[index % professionalPalette.length] }));
            const supervisorsForHistory = selectedSupervisors.length > 0 ? selectedSupervisors : Object.keys(historicalBests).map(s => s.toLowerCase().replace(/(?:^|\s)\S/g, a => a.toUpperCase()));
            const historicalDataForChart = [0, 0, 0, 0, 0];
            supervisorsForHistory.forEach(sup => { const bests = historicalBests[sup.toUpperCase()]; if(bests) { historicalDataForChart[0] += bests[1] || 0; historicalDataForChart[1] += bests[2] || 0; historicalDataForChart[2] += bests[3] || 0; historicalDataForChart[3] += bests[4] || 0; historicalDataForChart[4] += bests[5] || 0; } });
            const historicalDataset = { type: 'line', label: 'Melhor Dia Mês Anterior', data: historicalDataForChart, borderColor: '#f59e0b', backgroundColor: 'transparent', pointBackgroundColor: '#f59e0b', pointRadius: 4, tension: 0.1, borderWidth: 2, yAxisID: 'y', datalabels: { display: false } };
            const finalDatasets = [...currentMonthDatasets, historicalDataset];
            const weeklyChartOptions = { plugins: { legend: { display: true, onClick: (e, legendItem, legend) => { const index = legendItem.datasetIndex; const ci = legend.chart; if (ci.isDatasetVisible(index)) { ci.hide(index); legendItem.hidden = true; } else { ci.show(index); legendItem.hidden = false; } let newTotal = 0; ci.data.datasets.forEach((dataset, i) => { if (ci.isDatasetVisible(i) && dataset.type !== 'line') newTotal += dataset.data.reduce((acc, val) => acc + val, 0); }); totalMesSemanalEl.textContent = newTotal.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }); } } } };
            createChart('weeklySalesChart', 'bar', weekLabels, finalDatasets, weeklyChartOptions);
            const weeklySummaryTableBody = document.getElementById('weekly-summary-table-body');
            if (weeklySummaryTableBody) {
                weeklySummaryTableBody.innerHTML = ''; let grandTotal = 0;
                Object.keys(salesByWeekAndDay).sort((a,b) => parseInt(a) - parseInt(b)).forEach(weekNum => { const weekTotal = Object.values(salesByWeekAndDay[weekNum]).reduce((a, b) => a + b, 0); grandTotal += weekTotal; weeklySummaryTableBody.innerHTML += `<tr class="hover:bg-slate-700"><td class="px-4 py-2">Semana ${weekNum}</td><td class="px-4 py-2 text-right">${weekTotal.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td></tr>`; });
                weeklySummaryTableBody.innerHTML += `<tr class="font-bold bg-slate-700/50"><td class="px-4 py-2">Total do Mês</td><td class="px-4 py-2 text-right">${grandTotal.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td></tr>`;
            }
            const dataForRankings = dataForGeneralCharts.filter(d => d.SUPERV !== 'BALCAO');
            const positivacao = {}; dataForRankings.forEach(d => { if (!d.NOME || !d.CODCLI) return; if (!positivacao[d.NOME]) positivacao[d.NOME] = new Set(); positivacao[d.NOME].add(d.CODCLI); });
            const positivacaoRank = Object.entries(positivacao).map(([v, c]) => ({ vendedor: v, total: c.size })).sort((a, b) => b.total - a.total).slice(0, 10);
            if (positivacaoRank.length > 0) createChart('positivacaoChart', 'bar', positivacaoRank.map(r => getFirstName(r.vendedor)), positivacaoRank.map(r => r.total));
            else showNoDataMessage('positivacaoChart', 'Sem dados para o ranking.');
            const salesBySeller = {}; dataForRankings.forEach(d => { if (!d.NOME) return; salesBySeller[d.NOME] = (salesBySeller[d.NOME] || 0) + d.VLVENDA; });
            const topSellersRank = Object.entries(salesBySeller).sort(([, a], [, b]) => b - a).slice(0, 10);
            if (topSellersRank.length > 0) createChart('topSellersChart', 'bar', topSellersRank.map(r => getFirstName(r[0])), topSellersRank.map(r => r[1]));
            else showNoDataMessage('topSellersChart', 'Sem dados para o ranking.');
            // --- OPTIMIZATION: Mix Rank Calculation ---
            // Calculate mix map in a single pass: Map<Seller, Map<Client, Set<Description>>>
            const sellerClientMixMap = new Map();
            const targetSuppliers = new Set(['707', '708']);

            dataForRankings.forEach(d => {
                const vendedor = d.NOME;
                if (!vendedor || vendedor === 'VD HIAGO') return;

                // Rule: If Supervisor is OSVALDO NUNES O, count all products.
                // Otherwise, only count products from target suppliers (707, 708).
                const supervisor = d.SUPERV;
                if (supervisor !== 'OSVALDO NUNES O' && !targetSuppliers.has(String(d.CODFOR))) {
                    return;
                }

                if (!d.CODCLI || !d.DESCRICAO) return;

                if (!sellerClientMixMap.has(vendedor)) sellerClientMixMap.set(vendedor, new Map());
                const clientMap = sellerClientMixMap.get(vendedor);

                if (!clientMap.has(d.CODCLI)) clientMap.set(d.CODCLI, new Set());
                clientMap.get(d.CODCLI).add(d.DESCRICAO);
            });

            const mixRank = [];
            for (const [vendedor, clientMap] of sellerClientMixMap.entries()) {
                const mixValues = [];
                for (const productSet of clientMap.values()) {
                    mixValues.push(productSet.size);
                }

                if (mixValues.length > 0) {
                    const avgMix = mixValues.reduce((a, b) => a + b, 0) / mixValues.length;
                    mixRank.push({ vendedor, avgMix });
                } else {
                     mixRank.push({ vendedor, avgMix: 0 });
                }
            }

            mixRank.sort((a, b) => b.avgMix - a.avgMix);
            const top10Mix = mixRank.slice(0, 10);

            if(top10Mix.length > 0 && top10Mix.some(r => r.avgMix > 0)) createChart('mixChart', 'bar', top10Mix.map(r => getFirstName(r.vendedor)), top10Mix.map(r => r.avgMix));
            else showNoDataMessage('mixChart', 'Sem dados para o ranking.');
        }

        function updateSupplierFilter(dropdown, filterText, selectedArray, dataSource, filterType = 'comparison', skipRender = false) {
            const forbidden = ['CODFOR', 'FORNECEDOR', 'COD FOR', 'NOME DO FORNECEDOR', 'FORNECEDOR_NOME'];
            const suppliers = new Map();
            dataSource.forEach(s => {
                if(s.CODFOR && s.FORNECEDOR && !forbidden.includes(s.CODFOR.toUpperCase()) && !forbidden.includes(s.FORNECEDOR.toUpperCase())) {
                    suppliers.set(s.CODFOR, s.FORNECEDOR);
                }
            });
            const sortedSuppliers = [...suppliers.entries()].sort((a, b) => a[1].localeCompare(b[1]));

            selectedArray = selectedArray.filter(cod => suppliers.has(cod));

            if (!skipRender) {
                const htmlParts = [];
                for (let i = 0; i < sortedSuppliers.length; i++) {
                    const [cod, name] = sortedSuppliers[i];
                    const isChecked = selectedArray.includes(cod);
                    htmlParts.push(`<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" data-filter-type="${filterType}" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${cod}" ${isChecked ? 'checked' : ''}><span class="ml-2 text-xs">${cod} - ${name}</span></label>`);
                }
                dropdown.innerHTML = htmlParts.join('');
            }

            if (selectedArray.length === 0 || selectedArray.length === sortedSuppliers.length) {
                filterText.textContent = 'Todos Fornecedores';
            } else if (selectedArray.length === 1) {
                filterText.textContent = suppliers.get(selectedArray[0]) || '1 selecionado';
            } else {
                filterText.textContent = `${selectedArray.length} fornecedores selecionados`;
            }
            return selectedArray;
        }

        function updateComparisonCitySuggestions(dataSource) {
            const forbidden = ['CIDADE', 'MUNICIPIO', 'CIDADE_CLIENTE', 'NOME DA CIDADE', 'CITY'];
            const inputValue = comparisonCityFilter.value.toLowerCase();
            // Optimized Lookup
            const allAvailableCities = [...new Set(dataSource.map(item => {
                if (item.CIDADE) return item.CIDADE;
                if (item.CODCLI) {
                    const c = clientMapForKPIs.get(String(item.CODCLI));
                    if (c) return c.cidade || c['Nome da Cidade'];
                }
                return 'N/A';
            }).filter(c => c && c !== 'N/A' && !forbidden.includes(c.toUpperCase())))].sort();
            const filteredCities = inputValue ? allAvailableCities.filter(c => c.toLowerCase().includes(inputValue)) : allAvailableCities;
            if (filteredCities.length > 0 && document.activeElement === comparisonCityFilter) {
                comparisonCitySuggestions.innerHTML = filteredCities.map(c => `<div class="p-2 hover:bg-slate-600 cursor-pointer">${c}</div>`).join('');
                comparisonCitySuggestions.classList.remove('hidden');
            } else {
                comparisonCitySuggestions.classList.add('hidden');
            }
        }

        function getMonthWeeks(year, month) {
            const weeks = [];
            // Find the first day of the month
            const firstOfMonth = new Date(Date.UTC(year, month, 1));

            // Find the Sunday on or before the 1st
            const dayOfWeek = firstOfMonth.getUTCDay(); // 0 (Sun) to 6 (Sat)
            let currentStart = new Date(firstOfMonth);
            currentStart.setUTCDate(firstOfMonth.getUTCDate() - dayOfWeek);

            // Find the last day of the month
            const lastOfMonth = new Date(Date.UTC(year, month + 1, 0));

            // Iterate weeks until we cover the last day of the month
            while (currentStart <= lastOfMonth) {
                const currentEnd = new Date(currentStart);
                currentEnd.setUTCDate(currentStart.getUTCDate() + 6);
                currentEnd.setUTCHours(23, 59, 59, 999);

                weeks.push({ start: new Date(currentStart), end: currentEnd });

                // Move to next Sunday
                currentStart.setUTCDate(currentStart.getUTCDate() + 7);
            }
            return weeks;
        }

        function normalize(str) {
            return str
                ? str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g, ' ').trim().toUpperCase()
                : '';
        }

        function getPositiveClientsWithNewLogic(salesData) {
            const salesByClient = new Map();
            salesData.forEach(sale => {
                if (!sale.CODCLI) return;
                const clientTotal = salesByClient.get(sale.CODCLI) || 0;
                salesByClient.set(sale.CODCLI, clientTotal + sale.VLVENDA);
            });

            let positiveClients = 0;
            const threshold = 1;

            for (const total of salesByClient.values()) {
                if (total > threshold) {
                    positiveClients++;
                }
            }
            return positiveClients;
        }

        const formatValue = (val, format) => {
            if (format === 'currency') return val.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            if (format === 'decimal') return val.toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });
            if (format === 'mix') return val.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return val.toLocaleString('pt-BR', { maximumFractionDigits: 0 });
        };

        const formatAbbreviated = (val, format) => {
            let prefix = format === 'currency' ? 'R$ ' : '';
            if (val >= 1000000) {
                return prefix + (val / 1000000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' Mi';
            } else if (val >= 1000) {
                 return prefix + (val / 1000).toLocaleString('pt-BR', { maximumFractionDigits: 0 }) + ' K';
            }
            return null;
        };

        function renderKpiCards(kpis) {
            const container = document.getElementById('comparison-kpi-container');

            container.innerHTML = kpis.map(kpi => {
                const variation = kpi.history > 0 ? ((kpi.current - kpi.history) / kpi.history) * 100 : (kpi.current > 0 ? 100 : 0);
                const colorClass = variation > 0 ? 'text-green-400' : variation < 0 ? 'text-red-400' : 'text-slate-400';

                let displayValue;
                if (kpi.title === 'Faturamento Total') {
                    displayValue = formatAbbreviated(kpi.current, kpi.format) || formatValue(kpi.current, kpi.format);
                } else {
                    displayValue = formatValue(kpi.current, kpi.format);
                }

                let glowClass = 'kpi-glow-blue';
                if (kpi.title.includes('Faturamento')) glowClass = 'kpi-glow-green';
                else if (kpi.title.includes('Volume')) glowClass = 'kpi-glow-blue';
                else if (kpi.title.includes('Positivação') || kpi.title.includes('Cobertura')) glowClass = 'kpi-glow-purple';
                else if (kpi.title.includes('SKU') || kpi.title.includes('Mix')) glowClass = 'kpi-glow-yellow';

                return `<div class="kpi-card p-4 rounded-lg text-center kpi-glow-base ${glowClass} transition transform hover:-translate-y-1 duration-200">
                            <p class="text-slate-400 text-sm">${kpi.title}</p>
                            <p class="text-2xl font-bold text-white my-2">${displayValue}</p>
                            <p class="text-sm ${colorClass}">${variation.toFixed(2)}% vs Média do Trimestre</p>
                            <p class="text-xs text-slate-500">Média Trim.: ${formatValue(kpi.history, kpi.format)}</p>
                        </div>`;
            }).join('');
        }

        function calculateAverageMixComDevolucao(salesData, targetCodfors) {
             if (!salesData || salesData.length === 0 || !targetCodfors || targetCodfors.length === 0) return 0;

            const clientProductNetValue = new Map();

            for (const sale of salesData) {
                if (!targetCodfors.includes(String(sale.CODFOR))) continue;
                if (!sale.CODCLI || !sale.PRODUTO) continue;

                if (!clientProductNetValue.has(sale.CODCLI)) {
                    clientProductNetValue.set(sale.CODCLI, new Map());
                }
                const clientProducts = clientProductNetValue.get(sale.CODCLI);

                const currentValue = clientProducts.get(sale.PRODUTO) || 0;
                clientProducts.set(sale.PRODUTO, currentValue + (Number(sale.VLVENDA) || 0));
            }

            const mixValues = [];
            for (const products of clientProductNetValue.values()) {
                let positiveProductCount = 0;
                for (const netValue of products.values()) {
                    if (netValue > 1) {
                        positiveProductCount++;
                    }
                }
                if (positiveProductCount > 0) {
                    mixValues.push(positiveProductCount);
                }
            }

            if (mixValues.length === 0) return 0;

            return mixValues.reduce((a, b) => a + b, 0) / mixValues.length;
        }

        function calculatePositivacaoPorCestaComDevolucao(salesData, requiredCategories) {
            if (!salesData || salesData.length === 0 || !requiredCategories || requiredCategories.length === 0) return 0;

            const normalizedCategories = requiredCategories.map(normalize);
            const clientProductNetSales = new Map();

            for (const sale of salesData) {
                if (!sale.CODCLI || !sale.PRODUTO) continue;

                if (!clientProductNetSales.has(sale.CODCLI)) {
                    clientProductNetSales.set(sale.CODCLI, new Map());
                }
                const clientProducts = clientProductNetSales.get(sale.CODCLI);

                if (!clientProducts.has(sale.PRODUTO)) {
                    clientProducts.set(sale.PRODUTO, { netValue: 0, description: sale.DESCRICAO });
                }
                const productData = clientProducts.get(sale.PRODUTO);
                productData.netValue += (Number(sale.VLVENDA) || 0);
            }

            const clientPurchasedCategories = new Map();

            for (const [codcli, products] of clientProductNetSales.entries()) {
                for (const data of products.values()) {
                    if (data.netValue > 1) {
                        const normalizedDescription = normalize(data.description);
                        for (const category of normalizedCategories) {
                            if (normalizedDescription.includes(category)) {
                                if (!clientPurchasedCategories.has(codcli)) {
                                    clientPurchasedCategories.set(codcli, new Set());
                                }
                                clientPurchasedCategories.get(codcli).add(category);
                                break;
                            }
                        }
                    }
                }
            }

            let positivadosCount = 0;
            const requiredCategoryCount = normalizedCategories.length;
            for (const categoriesPurchased of clientPurchasedCategories.values()) {
                if (categoriesPurchased.size >= requiredCategoryCount) {
                    positivadosCount++;
                }
            }

            return positivadosCount;
        }


        function groupSalesByMonth(salesData) {
            const salesByMonth = {};
            salesData.forEach(sale => {
                const date = parseDate(sale.DTPED);
                if (!date || isNaN(date.getTime())) return;
                const monthKey = date.getUTCFullYear() + '-' + String(date.getUTCMonth() + 1).padStart(2, '0');
                if (!salesByMonth[monthKey]) salesByMonth[monthKey] = [];
                salesByMonth[monthKey].push(sale);
            });
            return salesByMonth;
        }

                        function calculateUnifiedMetrics(currentSales, historySales) {
            // 1. Setup Data Structures
            const currentYear = lastSaleDate.getUTCFullYear();
            const currentMonth = lastSaleDate.getUTCMonth();
            const currentMonthWeeks = getMonthWeeks(currentYear, currentMonth);

            const metrics = {
                current: {
                    fat: 0, peso: 0, clients: 0,
                    mixPepsico: 0, positivacaoSalty: 0, positivacaoFoods: 0
                },
                history: {
                    fat: 0, peso: 0,
                    avgFat: 0, avgPeso: 0, avgClients: 0,
                    avgMixPepsico: 0, avgPositivacaoSalty: 0, avgPositivacaoFoods: 0
                },
                charts: {
                    weeklyCurrent: new Array(currentMonthWeeks.length).fill(0),
                    weeklyHistory: new Array(currentMonthWeeks.length).fill(0),
                    monthlyData: [], // { label, value (fat/clients) }
                    supervisorData: {} // { sup: { current, history } }
                },
                overlapSales: []
            };

            const firstWeekStart = currentMonthWeeks[0].start;
            const firstOfMonth = new Date(Date.UTC(currentYear, currentMonth, 1));
            const hasOverlap = firstWeekStart < firstOfMonth;

            const pepsicoCodfors = new Set(['707', '708']);
            const saltyCategories = ['CHEETOS', 'DORITOS', 'FANDANGOS', 'RUFFLES', 'TORCIDA'];
            const foodsCategories = ['TODDYNHO', 'TODDY ', 'QUAKER', 'KEROCOCO'];

            // Helper to normalize strings
            const norm = (s) => s ? s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase() : '';

            // --- FILTER: Foods Description Logic (Same as Metas) ---
            const isValidFoodsProduct = (codFor, desc) => {
                // Apply strict description check ONLY for Supplier 1119 (Foods)
                if (codFor !== '1119') return true;

                const d = norm(desc || '');
                // Check if it matches ANY of the Foods sub-brands (Toddynho, Toddy, Quaker/Kerococo)
                // Note: Metas logic separates them. Here we just want to know if it belongs to "Foods Group".
                // If it contains NONE of the keywords, it is excluded from "Foods" metrics.
                if (d.includes('TODDYNHO')) return true;
                if (d.includes('TODDY ')) return true; // Note the space
                if (d.includes('QUAKER')) return true;
                if (d.includes('KEROCOCO')) return true;

                return false;
            };

            // --- 2. Process Current Sales (Single Pass) ---
            const currentClientProductMap = new Map(); // Client -> Product -> { val, desc, codfor }
            const currentClientsSet = new Map(); // Client -> Total Value (for Positive check)

            currentSales.forEach(s => {
                // Filter: Only Type 1 and 9 count for Metrics (Fat/Peso/Charts)
                const isValidType = (s.TIPOVENDA === '1' || s.TIPOVENDA === '9');

                // Filter: Strict Foods Definition
                if (!isValidFoodsProduct(String(s.CODFOR), s.DESCRICAO)) return;

                if (isValidType) {
                    metrics.current.fat += s.VLVENDA;
                    metrics.current.peso += s.TOTPESOLIQ;
                }

                if (s.CODCLI) {
                    // Accumulate for Positive Check (using VLVENDA which is 0 for non-1/9 anyway, but keeping consistent)
                    currentClientsSet.set(s.CODCLI, (currentClientsSet.get(s.CODCLI) || 0) + s.VLVENDA);

                    if (!currentClientProductMap.has(s.CODCLI)) currentClientProductMap.set(s.CODCLI, new Map());
                    const cMap = currentClientProductMap.get(s.CODCLI);
                    if (!cMap.has(s.PRODUTO)) cMap.set(s.PRODUTO, { val: 0, desc: s.DESCRICAO, codfor: String(s.CODFOR) });
                    cMap.get(s.PRODUTO).val += s.VLVENDA;
                }

                // Supervisor Data
                if (s.SUPERV && isValidType) {
                    if (!metrics.charts.supervisorData[s.SUPERV]) metrics.charts.supervisorData[s.SUPERV] = { current: 0, history: 0 };
                    metrics.charts.supervisorData[s.SUPERV].current += s.VLVENDA;
                }

                // Weekly Chart (Current)
                const d = parseDate(s.DTPED);
                if (d && isValidType) {
                    const wIdx = currentMonthWeeks.findIndex(w => d >= w.start && d <= w.end);
                    if (wIdx !== -1) metrics.charts.weeklyCurrent[wIdx] += s.VLVENDA;
                }
            });

            // Calculate Current KPIs from Maps
            let currentPositiveClients = 0;
            currentClientsSet.forEach(val => { if (val > 1) currentPositiveClients++; });
            metrics.current.clients = currentPositiveClients;

            // Mix/Positivacao Current
            let sumMix = 0;
            let countMixClients = 0;
            let countSalty = 0;
            let countFoods = 0;

            currentClientProductMap.forEach((prods, codcli) => {
                // Mix Pepsico
                let pepsicoCount = 0;
                const boughtCatsSalty = new Set();
                const boughtCatsFoods = new Set();

                prods.forEach(pData => {
                    if (pData.val > 1) {
                        if (pepsicoCodfors.has(pData.codfor)) pepsicoCount++;

                        const desc = norm(pData.desc);
                        saltyCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsSalty.add(cat); });
                        foodsCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsFoods.add(cat); });
                    }
                });

                if (pepsicoCount > 0) {
                    sumMix += pepsicoCount;
                    countMixClients++;
                }
                if (boughtCatsSalty.size >= saltyCategories.length) countSalty++;
                if (boughtCatsFoods.size >= foodsCategories.length) countFoods++;
            });

            metrics.current.mixPepsico = countMixClients > 0 ? sumMix / countMixClients : 0;
            metrics.current.positivacaoSalty = countSalty;
            metrics.current.positivacaoFoods = countFoods;


            // --- 3. Process History Sales (Single Pass) ---
            const historyMonths = new Map(); // MonthKey -> { fat, clientMap, weekSales: [] }

            // Cache week ranges for history months to avoid recalculating
            const monthWeeksCache = new Map();

            historySales.forEach(s => {
                const d = parseDate(s.DTPED);
                if (!d) return;

                const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;

                // Filter: Strict Foods Definition (Apply here too)
                if (!isValidFoodsProduct(String(s.CODFOR), s.DESCRICAO)) return;

                // Filter: Only Type 1 and 9 count for Metrics (Fat/Peso/Charts)
                const isValidType = (s.TIPOVENDA === '1' || s.TIPOVENDA === '9');

                if (isValidType) {
                    metrics.history.fat += s.VLVENDA;
                    metrics.history.peso += s.TOTPESOLIQ;
                }

                if (!historyMonths.has(monthKey)) {
                    historyMonths.set(monthKey, {
                        fat: 0,
                        clients: new Map(), // Client -> Total
                        productMap: new Map() // Client -> Product -> Data
                    });
                }
                const mData = historyMonths.get(monthKey);

                if (isValidType) {
                    mData.fat += s.VLVENDA;
                }

                if (s.CODCLI) {
                    mData.clients.set(s.CODCLI, (mData.clients.get(s.CODCLI) || 0) + s.VLVENDA);

                    if (!mData.productMap.has(s.CODCLI)) mData.productMap.set(s.CODCLI, new Map());
                    const cMap = mData.productMap.get(s.CODCLI);
                    if (!cMap.has(s.PRODUTO)) cMap.set(s.PRODUTO, { val: 0, desc: s.DESCRICAO, codfor: String(s.CODFOR) });
                    cMap.get(s.PRODUTO).val += s.VLVENDA;
                }

                // Supervisor History
                if (s.SUPERV && isValidType) {
                    if (!metrics.charts.supervisorData[s.SUPERV]) metrics.charts.supervisorData[s.SUPERV] = { current: 0, history: 0 };
                    metrics.charts.supervisorData[s.SUPERV].history += s.VLVENDA;
                }

                // Weekly History (Average logic)
                if (!monthWeeksCache.has(monthKey)) {
                    monthWeeksCache.set(monthKey, getMonthWeeks(d.getUTCFullYear(), d.getUTCMonth()));
                }
                const weeks = monthWeeksCache.get(monthKey);
                const wIdx = weeks.findIndex(w => d >= w.start && d <= w.end);

                // Map to Current Month's structure (0..4)
                if (wIdx !== -1 && wIdx < metrics.charts.weeklyHistory.length && isValidType) {
                    metrics.charts.weeklyHistory[wIdx] += s.VLVENDA;
                }

                // Handle Overlap for Current Chart (Single Pass)
                if (hasOverlap && d >= firstWeekStart && d < firstOfMonth && isValidType) {
                    metrics.charts.weeklyCurrent[0] += s.VLVENDA;
                    metrics.overlapSales.push(s);
                }
            });

            // Calculate History Averages
            metrics.history.avgFat = metrics.history.fat / QUARTERLY_DIVISOR;
            metrics.history.avgPeso = metrics.history.peso / QUARTERLY_DIVISOR;
            metrics.charts.weeklyHistory = metrics.charts.weeklyHistory.map(v => v / QUARTERLY_DIVISOR);

            // Normalize Supervisor History
            Object.values(metrics.charts.supervisorData).forEach(d => d.history /= QUARTERLY_DIVISOR);

            // Process Monthly KPIs (Clients, Mix)
            // Sort months to ensure we take the last 3 if there are more
            const sortedMonths = Array.from(historyMonths.keys()).sort();

            // Take last 3 months
            const monthsToProcess = sortedMonths.slice(-3);

            let sumClients = 0;
            let sumMixPep = 0;
            let sumPosSalty = 0;
            let sumPosFoods = 0;

            monthsToProcess.forEach(mKey => {
                const mData = historyMonths.get(mKey);

                // Clients
                let posClients = 0;
                mData.clients.forEach(v => { if(v > 1) posClients++; });
                sumClients += posClients;

                // Mix
                let mSumMix = 0;
                let mCountMixClients = 0;
                let mCountSalty = 0;
                let mCountFoods = 0;

                mData.productMap.forEach((prods, codcli) => {
                    let pepsicoCount = 0;
                    const boughtCatsSalty = new Set();
                    const boughtCatsFoods = new Set();

                    prods.forEach(pData => {
                        if (pData.val > 1) {
                            if (pepsicoCodfors.has(pData.codfor)) pepsicoCount++;
                            const desc = norm(pData.desc);
                            saltyCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsSalty.add(cat); });
                            foodsCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsFoods.add(cat); });
                        }
                    });

                    if (pepsicoCount > 0) {
                        mSumMix += pepsicoCount;
                        mCountMixClients++;
                    }
                    if (boughtCatsSalty.size >= saltyCategories.length) mCountSalty++;
                    if (boughtCatsFoods.size >= foodsCategories.length) mCountFoods++;
                });

                sumMixPep += (mCountMixClients > 0 ? mSumMix / mCountMixClients : 0);
                sumPosSalty += mCountSalty;
                sumPosFoods += mCountFoods;

                // For Monthly Chart (Labels and Values)
                const [y, m] = mKey.split('-');
                const monthName = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"][parseInt(m)];

                metrics.charts.monthlyData.push({
                    label: monthName,
                    fat: mData.fat,
                    clients: posClients,
                    key: mKey
                });
            });

            // Finish History Averages
            metrics.history.avgClients = sumClients / QUARTERLY_DIVISOR;
            metrics.history.avgMixPepsico = sumMixPep / QUARTERLY_DIVISOR;
            metrics.history.avgPositivacaoSalty = sumPosSalty / QUARTERLY_DIVISOR;
            metrics.history.avgPositivacaoFoods = sumPosFoods / QUARTERLY_DIVISOR;

            return metrics;
        }


        function monthlyKpiAverage(dataInput, kpiFn, isGrouped = false, ...kpiArgs) {
            let salesByMonth;
            if (isGrouped) {
                salesByMonth = dataInput;
            } else {
                salesByMonth = groupSalesByMonth(dataInput);
            }

            let sortedMonths = Object.keys(salesByMonth).sort();

            if (sortedMonths.length > 0) {
                const firstMonthKey = sortedMonths[0];
                const firstSaleInFirstMonth = salesByMonth[firstMonthKey].reduce((earliest, sale) => {
                    const saleDate = parseDate(sale.DTPED);
                    return (!earliest || (saleDate && saleDate < earliest)) ? saleDate : earliest;
                }, null);

                if (firstSaleInFirstMonth && firstSaleInFirstMonth.getUTCDate() > 20) {
                    sortedMonths.shift();
                }
            }

            const monthsToAverage = sortedMonths.slice(-3);

            const kpiValues = monthsToAverage.map(monthKey => {
                const salesForMonth = salesByMonth[monthKey];
                return kpiFn(salesForMonth, ...kpiArgs);
            });

            if (kpiValues.length === 0) return 0;
            return kpiValues.reduce((a, b) => a + b, 0) / QUARTERLY_DIVISOR;
        }

        function calculateStockMonthlyAverage(historySales) {
            // Function groupSalesByMonth is defined above in the scope
            const salesByMonth = groupSalesByMonth(historySales);
            let sortedMonths = Object.keys(salesByMonth).sort();

            if (sortedMonths.length > 0) {
                const firstMonthKey = sortedMonths[0];
                const firstSaleInFirstMonth = salesByMonth[firstMonthKey].reduce((earliest, sale) => {
                    const saleDate = parseDate(sale.DTPED);
                    return (!earliest || (saleDate && saleDate < earliest)) ? saleDate : earliest;
                }, null);

                if (firstSaleInFirstMonth && firstSaleInFirstMonth.getUTCDate() > 20) {
                    sortedMonths.shift();
                }
            }

            const monthsToAverage = sortedMonths.slice(-3);

            const kpiValues = monthsToAverage.map(monthKey => {
                const salesForMonth = salesByMonth[monthKey];
                return salesForMonth.reduce((sum, s) => sum + (s.QTVENDA_EMBALAGEM_MASTER || 0), 0);
            });

            if (kpiValues.length === 0) return 0;
            return kpiValues.reduce((a, b) => a + b, 0) / kpiValues.length;
        }

        const getFilteredDataFromIndices = (indices, dataMap, filters, excludeFilter = null) => {
            const isExcluded = (f) => excludeFilter === f || (Array.isArray(excludeFilter) && excludeFilter.includes(f));
            const setsToIntersect = [];
            let hasFilter = false;

            if (filters.filial && filters.filial !== 'ambas') {
                hasFilter = true;
                if (indices.byFilial && indices.byFilial.has(filters.filial)) {
                    setsToIntersect.push(indices.byFilial.get(filters.filial));
                } else {
                    return [];
                }
            }

            if (!isExcluded('supervisor') && filters.supervisor) {
                if (typeof filters.supervisor === 'string') {
                    hasFilter = true;
                    if (indices.bySupervisor && indices.bySupervisor.has(filters.supervisor)) {
                        setsToIntersect.push(indices.bySupervisor.get(filters.supervisor));
                    } else {
                        return [];
                    }
                } else if (filters.supervisor.size > 0) {
                    hasFilter = true;
                    const unionIds = new Set();
                    let foundAny = false;
                    filters.supervisor.forEach(sup => {
                        if (indices.bySupervisor && indices.bySupervisor.has(sup)) {
                            indices.bySupervisor.get(sup).forEach(id => unionIds.add(id));
                            foundAny = true;
                        }
                    });
                    if (foundAny) setsToIntersect.push(unionIds);
                    else return [];
                }
            }

            if (!isExcluded('pasta') && filters.pasta) {
                hasFilter = true;
                if (indices.byPasta && indices.byPasta.has(filters.pasta)) {
                    setsToIntersect.push(indices.byPasta.get(filters.pasta));
                } else {
                    return [];
                }
            }

            if (!isExcluded('tipoVenda') && filters.tipoVenda && filters.tipoVenda.size > 0) {
                hasFilter = true;
                const ids = new Set();
                let foundAny = false;
                filters.tipoVenda.forEach(t => {
                    if (indices.byTipoVenda && indices.byTipoVenda.has(t)) {
                        indices.byTipoVenda.get(t).forEach(id => ids.add(id));
                        foundAny = true;
                    }
                });
                if (foundAny) setsToIntersect.push(ids);
                else return [];
            }

            if (!isExcluded('seller') && filters.seller && filters.seller.size > 0) {
                hasFilter = true;
                const ids = new Set();
                let foundAny = false;
                filters.seller.forEach(s => {
                    if (indices.byRca && indices.byRca.has(s)) {
                        indices.byRca.get(s).forEach(id => ids.add(id));
                        foundAny = true;
                    }
                });
                if (foundAny) setsToIntersect.push(ids);
                else return [];
            }

            if (!isExcluded('supplier') && filters.supplier && filters.supplier.size > 0) {
                hasFilter = true;
                const ids = new Set();
                let foundAny = false;
                filters.supplier.forEach(s => {
                    if (indices.bySupplier && indices.bySupplier.has(s)) {
                        indices.bySupplier.get(s).forEach(id => ids.add(id));
                        foundAny = true;
                    }
                });
                if (foundAny) setsToIntersect.push(ids);
                else return [];
            }

            if (!isExcluded('product') && filters.product && filters.product.size > 0) {
                hasFilter = true;
                const ids = new Set();
                let foundAny = false;
                filters.product.forEach(p => {
                    if (indices.byProduct && indices.byProduct.has(p)) {
                        indices.byProduct.get(p).forEach(id => ids.add(id));
                        foundAny = true;
                    }
                });
                if (foundAny) setsToIntersect.push(ids);
                else return [];
            }

            if (!isExcluded('city') && filters.city) {
                hasFilter = true;
                if (indices.byCity && indices.byCity.has(filters.city)) {
                    setsToIntersect.push(indices.byCity.get(filters.city));
                } else {
                    return [];
                }
            }

            if (setsToIntersect.length === 0 && !hasFilter && !filters.clientCodes) {
                if (dataMap instanceof IndexMap) return dataMap._source;
                return Array.from(dataMap.values());
            }

            let resultIds;
            if (setsToIntersect.length > 0) {
                // --- OPTIMIZATION START ---
                // Sort sets by size to intersect the smallest sets first.
                setsToIntersect.sort((a, b) => a.size - b.size);

                // Start with the smallest set.
                resultIds = new Set(setsToIntersect[0]);

                // Intersect with the rest of the sets.
                for (let i = 1; i < setsToIntersect.length; i++) {
                    // Stop early if the result is already empty.
                    if (resultIds.size === 0) break;

                    const currentSet = setsToIntersect[i];
                    for (const id of resultIds) {
                        if (!currentSet.has(id)) {
                            resultIds.delete(id);
                        }
                    }
                }
                // --- OPTIMIZATION END ---
            } else if (filters.clientCodes) {
                 const allData = Array.from(dataMap.values());
                 return allData.filter(s => filters.clientCodes.has(s.CODCLI));
            } else {
                return Array.from(dataMap.values());
            }

            const result = [];
            for (const id of resultIds) {
                const item = dataMap.get(id);
                if (!filters.clientCodes || filters.clientCodes.has(item.CODCLI)) {
                    result.push(item);
                }
            }
            return result;
        };

        function getComparisonFilteredData(options = {}) {
            const { excludeFilter = null } = options;

            const sellersSet = new Set(selectedComparisonSellers);
            const suppliersSet = new Set(selectedComparisonSuppliers);
            const productsSet = new Set(selectedComparisonProducts);
            const tiposVendaSet = new Set(selectedComparisonTiposVenda);
            const redeSet = new Set(selectedComparisonRedes);
            const supervisorSet = new Set(selectedComparisonSupervisors);

            const pasta = currentComparisonFornecedor;
            const city = comparisonCityFilter.value.trim().toLowerCase();
            const filial = comparisonFilialFilter.value;

            let clientCodes = null;
            if (comparisonRedeGroupFilter) {
                let clients = allClientsData;
                if (comparisonRedeGroupFilter === 'com_rede') {
                    clients = clients.filter(c => c.ramo && c.ramo !== 'N/A');
                     if (redeSet.size > 0) {
                        clients = clients.filter(c => redeSet.has(c.ramo));
                    }
                } else if (comparisonRedeGroupFilter === 'sem_rede') {
                    clients = clients.filter(c => !c.ramo || c.ramo === 'N/A');
                }
                clientCodes = new Set(clients.map(c => c['Código']));
            }

            const filters = {
                filial,
                supervisor: supervisorSet,
                pasta,
                tipoVenda: tiposVendaSet,
                seller: sellersSet,
                supplier: suppliersSet,
                product: productsSet,
                city,
                clientCodes
            };

            return {
                currentSales: getFilteredDataFromIndices(optimizedData.indices.current, optimizedData.salesById, filters, excludeFilter),
                historySales: getFilteredDataFromIndices(optimizedData.indices.history, optimizedData.historyById, filters, excludeFilter)
            };
        }


        function updateAllComparisonFilters() {
            const { currentSales: supervisorCurrent, historySales: supervisorHistory } = getComparisonFilteredData({ excludeFilter: 'supervisor' });
            const supervisorOptionsData = [...supervisorCurrent, ...supervisorHistory];
            selectedComparisonSupervisors = updateSupervisorFilter(document.getElementById('comparison-supervisor-filter-dropdown'), document.getElementById('comparison-supervisor-filter-text'), selectedComparisonSupervisors, supervisorOptionsData);

            const { currentSales: sellerCurrent, historySales: sellerHistory } = getComparisonFilteredData({ excludeFilter: 'seller' });
            const sellerOptionsData = [...sellerCurrent, ...sellerHistory];
            selectedComparisonSellers = updateSellerFilter(selectedComparisonSupervisors, comparisonVendedorFilterDropdown, comparisonVendedorFilterText, selectedComparisonSellers, sellerOptionsData);

            const { currentSales: supplierCurrent, historySales: supplierHistory } = getComparisonFilteredData({ excludeFilter: 'supplier' });
            const supplierOptionsData = [...supplierCurrent, ...supplierHistory];
            selectedComparisonSuppliers = updateSupplierFilter(comparisonSupplierFilterDropdown, comparisonSupplierFilterText, selectedComparisonSuppliers, supplierOptionsData, 'comparison');

            const { currentSales: tvCurrent, historySales: tvHistory } = getComparisonFilteredData({ excludeFilter: 'tipoVenda' });
            selectedComparisonTiposVenda = updateTipoVendaFilter(comparisonTipoVendaFilterDropdown, comparisonTipoVendaFilterText, selectedComparisonTiposVenda, [...tvCurrent, ...tvHistory]);

            updateComparisonProductFilter();

            const { currentSales: cityCurrent, historySales: cityHistory } = getComparisonFilteredData({ excludeFilter: 'city' });
            const cityOptionsData = [...cityCurrent, ...cityHistory];
            updateComparisonCitySuggestions(cityOptionsData);

            const { currentSales: pastaCurrent, historySales: pastaHistory } = getComparisonFilteredData({ excludeFilter: 'pasta' });
            const pastaOptionsData = [...pastaCurrent, ...pastaHistory];
            const pepsicoBtn = document.querySelector('#comparison-fornecedor-toggle-container button[data-fornecedor="PEPSICO"]');
            const multimarcasBtn = document.querySelector('#comparison-fornecedor-toggle-container button[data-fornecedor="MULTIMARCAS"]');
            const hasPepsico = pastaOptionsData.some(s => s.OBSERVACAOFOR === 'PEPSICO');
            const hasMultimarcas = pastaOptionsData.some(s => s.OBSERVACAOFOR === 'MULTIMARCAS');
            pepsicoBtn.disabled = !hasPepsico;
            multimarcasBtn.disabled = !hasMultimarcas;
            pepsicoBtn.classList.toggle('opacity-50', !hasPepsico);
            multimarcasBtn.classList.toggle('opacity-50', !hasMultimarcas);
        }

        function updateProductFilter(dropdown, filterText, selectedArray, dataSource, filterType = 'comparison', skipRender = false) {
            const forbidden = ['PRODUTO', 'DESCRICAO', 'CODIGO', 'CÓDIGO', 'DESCRIÇÃO'];
            const searchInput = dropdown.querySelector('input[type="text"]');
            const listContainer = dropdown.querySelector('div[id$="-list"]');
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

            const products = [...new Map(dataSource.map(s => [s.PRODUTO, s.DESCRICAO]))
                .entries()]
                .filter(([code, desc]) => code && desc && !forbidden.includes(code.toUpperCase()) && !forbidden.includes(desc.toUpperCase()))
                .sort((a,b) => a[1].localeCompare(b[1]));

            // Filter selectedArray to keep only items present in the current dataSource
            const availableProductCodes = new Set(products.map(p => p[0]));
            selectedArray = selectedArray.filter(code => availableProductCodes.has(code));

            const filteredProducts = searchTerm.length > 0
                ? products.filter(([code, name]) =>
                    name.toLowerCase().includes(searchTerm) || code.toLowerCase().includes(searchTerm)
                  )
                : products;

            if (!skipRender) {
                const htmlParts = [];
                for (let i = 0; i < filteredProducts.length; i++) {
                    const [code, name] = filteredProducts[i];
                    const isChecked = selectedArray.includes(code);
                    htmlParts.push(`
                        <label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" data-filter-type="${filterType}" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${code}" ${isChecked ? 'checked' : ''}>
                            <span class="ml-2 text-xs">(${code}) ${name}</span>
                        </label>`);
                }
                listContainer.innerHTML = htmlParts.join('');
            }

            if (selectedArray.length === 0) {
                filterText.textContent = 'Todos os Produtos';
            } else if (selectedArray.length === 1) {
                const productsInfo = new Map(products);
                filterText.textContent = productsInfo.get(selectedArray[0]) || '1 selecionado';
            } else {
                filterText.textContent = `${selectedArray.length} produtos selecionados`;
            }
            return selectedArray;
        }

        function updateComparisonProductFilter() {
            const { currentSales, historySales } = getComparisonFilteredData({ excludeFilter: 'product' });
            selectedComparisonProducts = updateProductFilter(comparisonProductFilterDropdown, comparisonProductFilterText, selectedComparisonProducts, [...currentSales, ...historySales], 'comparison');
        }

        function updateStockProductFilter(skipRender = false) {
            const data = getStockFilteredData({excludeFilter: 'product'});
            selectedStockProducts = updateProductFilter(stockProductFilterDropdown, stockProductFilterText, selectedStockProducts, [...data.sales, ...data.history], 'stock', skipRender);
        }

        function updateStockSupplierFilter(skipRender = false) {
            const data = getStockFilteredData({excludeFilter: 'supplier'});
            selectedStockSuppliers = updateSupplierFilter(stockSupplierFilterDropdown, stockSupplierFilterText, selectedStockSuppliers, [...data.sales, ...data.history], 'stock', skipRender);
        }

        function updateStockSellerFilter(skipRender = false) {
            const data = getStockFilteredData({excludeFilter: 'seller'});
            selectedStockSellers = updateSellerFilter(selectedStockSupervisors, stockVendedorFilterDropdown, stockVendedorFilterText, selectedStockSellers, [...data.sales, ...data.history], skipRender);
        }

        function updateStockCitySuggestions(dataSource) {
            const forbidden = ['CIDADE', 'MUNICIPIO', 'CIDADE_CLIENTE', 'NOME DA CIDADE', 'CITY'];
            const inputValue = stockCityFilter.value.toLowerCase();
            // Optimized Lookup
            const allAvailableCities = [...new Set(dataSource.map(item => {
                if (item.CIDADE) return item.CIDADE;
                if (item.CODCLI) {
                    const c = clientMapForKPIs.get(String(item.CODCLI));
                    if (c) return c.cidade || c['Nome da Cidade'];
                }
                return 'N/A';
            }).filter(c => c && c !== 'N/A' && !forbidden.includes(c.toUpperCase())))].sort();
            const filteredCities = inputValue ? allAvailableCities.filter(c => c.toLowerCase().includes(inputValue)) : allAvailableCities;
            if (filteredCities.length > 0 && document.activeElement === stockCityFilter) {
                stockCitySuggestions.innerHTML = filteredCities.map(c => `<div class="p-2 hover:bg-slate-600 cursor-pointer">${c}</div>`).join('');
                stockCitySuggestions.classList.remove('hidden');
            } else {
                stockCitySuggestions.classList.add('hidden');
            }
        }

        function getActiveStockMap(filial) {
            const filterValue = filial || stockFilialFilter.value;
            if (filterValue === '05') {
                return stockData05;
            }
            if (filterValue === '08') {
                return stockData08;
            }
            const combinedStock = new Map(stockData05);
            stockData08.forEach((qty, code) => {
                combinedStock.set(code, (combinedStock.get(code) || 0) + qty);
            });
            return combinedStock;
        }

        function getStockFilteredData(options = {}) {
            const { excludeFilter = null } = options;

            const sellersSet = new Set(selectedStockSellers);
            const suppliersSet = new Set(selectedStockSuppliers);
            const productsSet = new Set(selectedStockProducts);
            const tiposVendaSet = new Set(selectedStockTiposVenda);
            const redeSet = new Set(selectedStockRedes);
            const supervisorSet = new Set(selectedStockSupervisors);

            const pasta = currentStockFornecedor;
            const city = stockCityFilter.value.trim().toLowerCase();
            const filial = stockFilialFilter.value;

            let clientCodes = null;
            if (excludeFilter !== 'rede') {
                if (stockRedeGroupFilter === 'com_rede' || stockRedeGroupFilter === 'sem_rede') {
                    let clients = allClientsData;
                    if (stockRedeGroupFilter === 'com_rede') {
                        clients = clients.filter(c => c.ramo && c.ramo !== 'N/A');
                        if (redeSet.size > 0) {
                            clients = clients.filter(c => redeSet.has(c.ramo));
                        }
                    } else if (stockRedeGroupFilter === 'sem_rede') {
                        clients = clients.filter(c => !c.ramo || c.ramo === 'N/A');
                    }
                    clientCodes = new Set(clients.map(c => c['Código']));
                }
            }

            const filters = {
                filial,
                supervisor: supervisorSet,
                pasta,
                tipoVenda: tiposVendaSet,
                seller: sellersSet,
                supplier: suppliersSet,
                product: productsSet,
                city,
                clientCodes
            };

            return {
                sales: getFilteredDataFromIndices(optimizedData.indices.current, optimizedData.salesById, filters, excludeFilter),
                history: getFilteredDataFromIndices(optimizedData.indices.history, optimizedData.historyById, filters, excludeFilter)
            };
        }

        function handleStockFilterChange(options = {}) {
            const { skipFilter = null } = options;

            // Debounce stock view update
            if (window.stockUpdateTimeout) clearTimeout(window.stockUpdateTimeout);
            window.stockUpdateTimeout = setTimeout(() => {
                if (skipFilter !== 'supervisor') {
                    const supervisorData = getStockFilteredData({ excludeFilter: 'supervisor' });
                    const supervisorOptionsData = [...supervisorData.sales, ...supervisorData.history];
                    selectedStockSupervisors = updateSupervisorFilter(document.getElementById('stock-supervisor-filter-dropdown'), document.getElementById('stock-supervisor-filter-text'), selectedStockSupervisors, supervisorOptionsData);
                }

                updateStockSellerFilter(skipFilter === 'seller');
                updateStockSupplierFilter(skipFilter === 'supplier');
                updateStockProductFilter(skipFilter === 'product');

                const tvData = getStockFilteredData({ excludeFilter: 'tipoVenda' });
                selectedStockTiposVenda = updateTipoVendaFilter(stockTipoVendaFilterDropdown, stockTipoVendaFilterText, selectedStockTiposVenda, [...tvData.sales, ...tvData.history], skipFilter === 'tipoVenda');

                if (skipFilter !== 'city') {
                    const cityData = getStockFilteredData({ excludeFilter: 'city' });
                    updateStockCitySuggestions([...cityData.sales, ...cityData.history]);
                }

                if (skipFilter !== 'pasta') {
                    const pastaData = getStockFilteredData({ excludeFilter: 'pasta' });
                    const pastaOptionsData = [...pastaData.sales, ...pastaData.history];
                    const pepsicoBtn = document.querySelector('#stock-fornecedor-toggle-container button[data-fornecedor="PEPSICO"]');
                    const multimarcasBtn = document.querySelector('#stock-fornecedor-toggle-container button[data-fornecedor="MULTIMARCAS"]');
                    const hasPepsico = pastaOptionsData.some(s => s.OBSERVACAOFOR === 'PEPSICO');
                    const hasMultimarcas = pastaOptionsData.some(s => s.OBSERVACAOFOR === 'MULTIMARCAS');
                    pepsicoBtn.disabled = !hasPepsico;
                    multimarcasBtn.disabled = !hasMultimarcas;
                    pepsicoBtn.classList.toggle('opacity-50', !hasPepsico);
                    multimarcasBtn.classList.toggle('opacity-50', !hasMultimarcas);
                }

                updateStockView();
            }, 10);
        }

        function updateComparisonView() {
            comparisonRenderId++;
            const currentRenderId = comparisonRenderId;
            const { currentSales, historySales } = getComparisonFilteredData();

            // Show Loading State on Charts
            const chartContainers = ['weeklyComparisonChart', 'monthlyComparisonChart', 'dailyWeeklyComparisonChart'];
            chartContainers.forEach(id => {
                if (charts[id]) {
                    charts[id].destroy();
                    delete charts[id];
                }
                const el = document.getElementById(id + 'Container');
                if(el) el.innerHTML = '<div class="flex h-full items-center justify-center"><svg class="animate-spin h-8 w-8 text-teal-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>';
            });

            const currentYear = lastSaleDate.getUTCFullYear();
            const currentMonth = lastSaleDate.getUTCMonth();
            const currentMonthWeeks = getMonthWeeks(currentYear, currentMonth);

            const metrics = {
                current: { fat: 0, peso: 0, clients: 0, mixPepsico: 0, positivacaoSalty: 0, positivacaoFoods: 0 },
                history: { fat: 0, peso: 0, avgFat: 0, avgPeso: 0, avgClients: 0, avgMixPepsico: 0, avgPositivacaoSalty: 0, avgPositivacaoFoods: 0 },
                charts: {
                    weeklyCurrent: new Array(currentMonthWeeks.length).fill(0),
                    weeklyHistory: new Array(currentMonthWeeks.length).fill(0),
                    monthlyData: [],
                    supervisorData: {}
                },
                historicalDayTotals: new Array(7).fill(0), // 0=Sun, 6=Sat
                overlapSales: []
            };

            const firstWeekStart = currentMonthWeeks[0].start;
            const firstOfMonth = new Date(Date.UTC(currentYear, currentMonth, 1));
            const hasOverlap = firstWeekStart < firstOfMonth;
            const pepsicoCodfors = new Set(['707', '708']);
            const saltyCategories = ['CHEETOS', 'DORITOS', 'FANDANGOS', 'RUFFLES', 'TORCIDA'];
            const foodsCategories = ['TODDYNHO', 'TODDY ', 'QUAKER', 'KEROCOCO'];
            const norm = (s) => s ? s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase() : '';

            // Temp structures for Current processing
            const currentClientProductMap = new Map();
            const currentClientsSet = new Map();

            // Temp structures for History processing
            const historyMonths = new Map();
            const monthWeeksCache = new Map();

            // --- Async Pipeline ---

            // 1. Process Current Sales
            runAsyncChunked(currentSales, (s) => {
                const isValidType = (s.TIPOVENDA === '1' || s.TIPOVENDA === '9');
                if (isValidType) {
                    metrics.current.fat += s.VLVENDA;
                    metrics.current.peso += s.TOTPESOLIQ;
                }
                if (s.CODCLI) {
                    currentClientsSet.set(s.CODCLI, (currentClientsSet.get(s.CODCLI) || 0) + s.VLVENDA);
                    if (!currentClientProductMap.has(s.CODCLI)) currentClientProductMap.set(s.CODCLI, new Map());
                    const cMap = currentClientProductMap.get(s.CODCLI);
                    if (!cMap.has(s.PRODUTO)) cMap.set(s.PRODUTO, { val: 0, desc: s.DESCRICAO, codfor: String(s.CODFOR) });
                    cMap.get(s.PRODUTO).val += s.VLVENDA;
                }
                if (s.SUPERV && isValidType) {
                    if (!metrics.charts.supervisorData[s.SUPERV]) metrics.charts.supervisorData[s.SUPERV] = { current: 0, history: 0 };
                    metrics.charts.supervisorData[s.SUPERV].current += s.VLVENDA;
                }
                const d = parseDate(s.DTPED);
                if (d && isValidType) {
                    const wIdx = currentMonthWeeks.findIndex(w => d >= w.start && d <= w.end);
                    if (wIdx !== -1) metrics.charts.weeklyCurrent[wIdx] += s.VLVENDA;
                }
            }, () => {
                // 1.1 Finalize Current KPIs
                let currentPositiveClients = 0;
                currentClientsSet.forEach(val => { if (val > 1) currentPositiveClients++; });
                metrics.current.clients = currentPositiveClients;

                let sumMix = 0; let countMixClients = 0; let countSalty = 0; let countFoods = 0;
                currentClientProductMap.forEach((prods) => {
                    let pepsicoCount = 0;
                    const boughtCatsSalty = new Set();
                    const boughtCatsFoods = new Set();
                    prods.forEach(pData => {
                        if (pData.val > 1) {
                            if (pepsicoCodfors.has(pData.codfor)) pepsicoCount++;
                            const desc = norm(pData.desc);
                            saltyCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsSalty.add(cat); });
                            foodsCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsFoods.add(cat); });
                        }
                    });
                    if (pepsicoCount > 0) { sumMix += pepsicoCount; countMixClients++; }
                    if (boughtCatsSalty.size >= saltyCategories.length) countSalty++;
                    if (boughtCatsFoods.size >= foodsCategories.length) countFoods++;
                });
                metrics.current.mixPepsico = countMixClients > 0 ? sumMix / countMixClients : 0;
                metrics.current.positivacaoSalty = countSalty;
                metrics.current.positivacaoFoods = countFoods;

                if (currentRenderId !== comparisonRenderId) return;

                // 2. Process History Sales
                runAsyncChunked(historySales, (s) => {
                    const isValidType = (s.TIPOVENDA === '1' || s.TIPOVENDA === '9');
                    if (isValidType) {
                        metrics.history.fat += s.VLVENDA;
                        metrics.history.peso += s.TOTPESOLIQ;
                    }
                    const d = parseDate(s.DTPED);
                    if (!d) return;

                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                    if (!historyMonths.has(monthKey)) historyMonths.set(monthKey, { fat: 0, clients: new Map(), productMap: new Map() });
                    const mData = historyMonths.get(monthKey);

                    if (isValidType) mData.fat += s.VLVENDA;

                    if (s.CODCLI) {
                        mData.clients.set(s.CODCLI, (mData.clients.get(s.CODCLI) || 0) + s.VLVENDA);
                        if (!mData.productMap.has(s.CODCLI)) mData.productMap.set(s.CODCLI, new Map());
                        const cMap = mData.productMap.get(s.CODCLI);
                        if (!cMap.has(s.PRODUTO)) cMap.set(s.PRODUTO, { val: 0, desc: s.DESCRICAO, codfor: String(s.CODFOR) });
                        cMap.get(s.PRODUTO).val += s.VLVENDA;
                    }

                    if (s.SUPERV && isValidType) {
                        if (!metrics.charts.supervisorData[s.SUPERV]) metrics.charts.supervisorData[s.SUPERV] = { current: 0, history: 0 };
                        metrics.charts.supervisorData[s.SUPERV].history += s.VLVENDA;
                    }

                    // Accumulate Day Totals for Day Weight Calculation
                    if (isValidType) {
                        metrics.historicalDayTotals[d.getUTCDay()] += s.VLVENDA;
                    }

                    if (!monthWeeksCache.has(monthKey)) monthWeeksCache.set(monthKey, getMonthWeeks(d.getUTCFullYear(), d.getUTCMonth()));
                    const weeks = monthWeeksCache.get(monthKey);
                    const wIdx = weeks.findIndex(w => d >= w.start && d <= w.end);
                    if (wIdx !== -1 && wIdx < metrics.charts.weeklyHistory.length && isValidType) {
                        metrics.charts.weeklyHistory[wIdx] += s.VLVENDA;
                    }
                    if (hasOverlap && d >= firstWeekStart && d < firstOfMonth && isValidType) {
                        metrics.charts.weeklyCurrent[0] += s.VLVENDA;
                        metrics.overlapSales.push(s);
                    }
                }, () => {
                    if (currentRenderId !== comparisonRenderId) return;

                    // 2.1 Finalize History Metrics
                    metrics.history.avgFat = metrics.history.fat / QUARTERLY_DIVISOR;
                    metrics.history.avgPeso = metrics.history.peso / QUARTERLY_DIVISOR;
                    metrics.charts.weeklyHistory = metrics.charts.weeklyHistory.map(v => v / QUARTERLY_DIVISOR);
                    Object.values(metrics.charts.supervisorData).forEach(d => d.history /= QUARTERLY_DIVISOR);

                    // Calculate Day Weights
                    const totalHistoryDays = metrics.historicalDayTotals.reduce((a, b) => a + b, 0);
                    metrics.dayWeights = metrics.historicalDayTotals.map(v => totalHistoryDays > 0 ? v / totalHistoryDays : 0);

                    const sortedMonths = Array.from(historyMonths.keys()).sort((a, b) => {
                        const [y1, m1] = a.split('-').map(Number);
                        const [y2, m2] = b.split('-').map(Number);
                        return (y1 * 12 + m1) - (y2 * 12 + m2);
                    }).slice(-3);
                    let sumClients = 0; let sumMixPep = 0; let sumPosSalty = 0; let sumPosFoods = 0;

                    sortedMonths.forEach(mKey => {
                        const mData = historyMonths.get(mKey);
                        let posClients = 0;
                        mData.clients.forEach(v => { if(v > 1) posClients++; });
                        sumClients += posClients;

                        let mSumMix = 0; let mCountMixClients = 0; let mCountSalty = 0; let mCountFoods = 0;
                        mData.productMap.forEach((prods) => {
                            let pepsicoCount = 0;
                            const boughtCatsSalty = new Set();
                            const boughtCatsFoods = new Set();
                            prods.forEach(pData => {
                                if (pData.val > 1) {
                                    if (pepsicoCodfors.has(pData.codfor)) pepsicoCount++;
                                    const desc = norm(pData.desc);
                                    saltyCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsSalty.add(cat); });
                                    foodsCategories.forEach(cat => { if (desc.includes(cat)) boughtCatsFoods.add(cat); });
                                }
                            });
                            if (pepsicoCount > 0) { mSumMix += pepsicoCount; mCountMixClients++; }
                            if (boughtCatsSalty.size >= saltyCategories.length) mCountSalty++;
                            if (boughtCatsFoods.size >= foodsCategories.length) mCountFoods++;
                        });
                        sumMixPep += (mCountMixClients > 0 ? mSumMix / mCountMixClients : 0);
                        sumPosSalty += mCountSalty;
                        sumPosFoods += mCountFoods;

                        const [y, m] = mKey.split('-');
                        const label = new Date(Date.UTC(parseInt(y), parseInt(m), 1)).toLocaleDateString('pt-BR', { month: 'short', year: '2-digit', timeZone: 'UTC' });
                        metrics.charts.monthlyData.push({ label, fat: mData.fat, clients: posClients });
                    });

                    metrics.history.avgClients = sumClients / QUARTERLY_DIVISOR;
                    metrics.history.avgMixPepsico = sumMixPep / QUARTERLY_DIVISOR;
                    metrics.history.avgPositivacaoSalty = sumPosSalty / QUARTERLY_DIVISOR;
                    metrics.history.avgPositivacaoFoods = sumPosFoods / QUARTERLY_DIVISOR;

                    // 3. Render Views
                    const m = metrics;
                    renderKpiCards([
                        { title: 'Faturamento Total', current: m.current.fat, history: m.history.avgFat, format: 'currency' },
                        { title: 'Peso Total (Ton)', current: m.current.peso / 1000, history: m.history.avgPeso / 1000, format: 'decimal' },
                        { title: 'Clientes Atendidos', current: m.current.clients, history: m.history.avgClients, format: 'integer' },
                        { title: 'Ticket Médio', current: m.current.clients > 0 ? m.current.fat / m.current.clients : 0, history: m.history.avgClients > 0 ? m.history.avgFat / m.history.avgClients : 0, format: 'currency' },
                        { title: 'Mix por PDV (Pepsico)', current: m.current.mixPepsico, history: m.history.avgMixPepsico, format: 'mix' },
                        { title: 'Mix Salty', current: m.current.positivacaoSalty, history: m.history.avgPositivacaoSalty, format: 'integer' },
                        { title: 'Mix Foods', current: m.current.positivacaoFoods, history: m.history.avgPositivacaoFoods, format: 'integer' }
                    ]);

                    // Weekly Chart Logic with Tendency
                    let weeklyCurrentData = [...m.charts.weeklyCurrent];
                    if (useTendencyComparison) {
                        const today = lastSaleDate;
                        const currentWeekIndex = currentMonthWeeks.findIndex(w => today >= w.start && today <= w.end);
                        const totalWeeks = currentMonthWeeks.length;
                        for (let i = 0; i < totalWeeks; i++) {
                            if (i === currentWeekIndex) {
                                const currentWeek = currentMonthWeeks[i];
                                let workingDaysPassed = 0; let totalWorkingDays = 0;
                                for (let d = new Date(currentWeek.start); d <= currentWeek.end; d.setUTCDate(d.getUTCDate() + 1)) {
                                    const dayOfWeek = d.getUTCDay();
                                    if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(d, selectedHolidays)) {
                                        totalWorkingDays++;
                                        if (d <= today) workingDaysPassed++;
                                    }
                                }
                                const salesSoFar = weeklyCurrentData[i];
                                if (workingDaysPassed > 0 && totalWorkingDays > 0) {
                                    weeklyCurrentData[i] = (salesSoFar / workingDaysPassed) * totalWorkingDays;
                                } else {
                                    weeklyCurrentData[i] = m.charts.weeklyHistory[i] || 0;
                                }
                            } else if (i > currentWeekIndex) {
                                weeklyCurrentData[i] = m.charts.weeklyHistory[i] || 0;
                            }
                        }
                    }

                    // Render Charts logic (Reusing existing drawing code)
                    if (comparisonChartType === 'weekly') {
                        monthlyComparisonChartContainer.classList.add('hidden');
                        weeklyComparisonChartContainer.classList.remove('hidden');
                        comparisonChartTitle.textContent = 'Comparativo de Faturamento Semanal';
                        const weekLabels = currentMonthWeeks.map((w, i) => `Semana ${i + 1}`);
                        createChart('weeklyComparisonChart', 'line', weekLabels, [
                            { label: useTendencyComparison ? 'Tendência Semanal' : 'Mês Atual', data: weeklyCurrentData, borderColor: '#14b8a6', tension: 0.2, pointRadius: 5, pointBackgroundColor: '#14b8a6', borderWidth: 2.5 },
                            { label: 'Média Trimestre', data: m.charts.weeklyHistory, borderColor: '#f97316', tension: 0.2, pointRadius: 5, pointBackgroundColor: '#f97316', borderWidth: 2.5 }
                        ], { plugins: { legend: { display: true, position: 'top', align: 'end' } }, layout: { padding: { bottom: 0 } } });
                    } else if (comparisonChartType === 'monthly') {
                        weeklyComparisonChartContainer.classList.add('hidden');
                        monthlyComparisonChartContainer.classList.remove('hidden');
                        const metricToggle = document.getElementById('comparison-monthly-metric-container');
                        if (metricToggle) metricToggle.classList.remove('hidden');
                        const isFat = comparisonMonthlyMetric === 'faturamento';
                        comparisonChartTitle.textContent = isFat ? 'Comparativo de Faturamento Mensal' : 'Comparativo de Clientes Atendidos Mensal';
                        const monthLabels = m.charts.monthlyData.map(d => d.label);
                        const monthValues = m.charts.monthlyData.map(d => isFat ? d.fat : d.clients);
                        let currentMonthLabel = 'Mês Atual';
                        if (currentSales.length > 0) {
                            const firstSaleDate = parseDate(currentSales[0].DTPED) || new Date();
                            currentMonthLabel = firstSaleDate.toLocaleString('pt-BR', { month: 'short', year: '2-digit' });
                        }
                        let currentVal = isFat ? m.current.fat : m.current.clients;
                        if (isFat && useTendencyComparison) {
                            const totalDays = getWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays);
                            const passedDays = getPassedWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays, lastSaleDate);
                            if (totalDays > 0 && passedDays > 0) { currentVal = (currentVal / passedDays) * totalDays; }
                        }
                        monthLabels.push(currentMonthLabel);
                        monthValues.push(currentVal);
                        createChart('monthlyComparisonChart', 'bar', monthLabels, [{ label: isFat ? 'Faturamento' : 'Clientes Atendidos', data: monthValues, backgroundColor: (context) => { const ctx = context.chart.ctx; const gradient = ctx.createLinearGradient(0, 0, 0, 400); gradient.addColorStop(0, 'rgba(20, 184, 166, 0.8)'); gradient.addColorStop(1, 'rgba(126, 34, 206, 0.8)'); return gradient; }, borderColor: (context) => { const ctx = context.chart.ctx; const gradient = ctx.createLinearGradient(0, 0, 0, 400); gradient.addColorStop(0, '#14b8a6'); gradient.addColorStop(1, '#7e22ce'); return gradient; }, borderWidth: 2 }], { layout: { padding: { top: 20 } }, plugins: { legend: { display: false }, datalabels: { color: '#ffffff', anchor: 'end', align: 'top', offset: 4, font: { weight: 'bold' }, formatter: (value) => { if (isFat) { if (value >= 1000000) return 'R$ ' + (value / 1000000).toFixed(2) + ' M'; return 'R$ ' + (value / 1000).toFixed(0) + 'k'; } else { return value.toLocaleString('pt-BR'); } } }, tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) label += ': '; if (context.parsed.y !== null) { if (isFat) label += new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(context.parsed.y); else label += context.parsed.y.toLocaleString('pt-BR') + ' clientes'; } return label; } } } } });
                    }

                    // Daily Chart (Simplified re-calc for now, or could optimize further)
                    const salesByWeekAndDay = {};
                    currentMonthWeeks.forEach((w, i) => { salesByWeekAndDay[i + 1] = new Array(7).fill(0); });
                    currentSales.forEach(s => { const d = parseDate(s.DTPED); if(d) { const wIdx = currentMonthWeeks.findIndex(w => d >= w.start && d <= w.end); if(wIdx !== -1) salesByWeekAndDay[wIdx+1][d.getUTCDay()] += s.VLVENDA; } });
                    if (m.overlapSales && m.overlapSales.length > 0) { m.overlapSales.forEach(s => { const d = parseDate(s.DTPED); if (d) salesByWeekAndDay[1][d.getUTCDay()] += s.VLVENDA; }); }

                    // --- INICIO DA MODIFICAÇÃO: Tendência no Gráfico Diário ---
                    if (useTendencyComparison) {
                        const today = lastSaleDate;
                        const currentWeekIndex = currentMonthWeeks.findIndex(w => today >= w.start && today <= w.end);

                        // 1. Project Current Week
                        if (currentWeekIndex !== -1) {
                            const currentWeek = currentMonthWeeks[currentWeekIndex];
                            let workingDaysPassed = 0; let totalWorkingDays = 0;
                            const remainingDaysIndices = [];

                            for (let d = new Date(currentWeek.start); d <= currentWeek.end; d.setUTCDate(d.getUTCDate() + 1)) {
                                const dayOfWeek = d.getUTCDay();
                                if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(d, selectedHolidays)) {
                                    totalWorkingDays++;
                                    if (d <= today) workingDaysPassed++;
                                    else remainingDaysIndices.push(dayOfWeek);
                                }
                            }

                            if (workingDaysPassed > 0 && totalWorkingDays > 0) {
                                const weekData = salesByWeekAndDay[currentWeekIndex + 1];
                                const salesSoFar = weekData.reduce((a, b) => a + b, 0);
                                const projectedWeekTotal = (salesSoFar / workingDaysPassed) * totalWorkingDays;
                                const remainder = projectedWeekTotal - salesSoFar;

                                if (remainder > 0 && remainingDaysIndices.length > 0) {
                                    const weightsForRemaining = remainingDaysIndices.map(d => m.dayWeights[d] || 0);
                                    const totalWeightRemaining = weightsForRemaining.reduce((a, b) => a + b, 0);

                                    remainingDaysIndices.forEach(dayIndex => {
                                        const weight = m.dayWeights[dayIndex] || 0;
                                        // If weights are available, use them. Otherwise distribute evenly.
                                        const share = totalWeightRemaining > 0 ? (weight / totalWeightRemaining) : (1 / remainingDaysIndices.length);
                                        weekData[dayIndex] = remainder * share;
                                    });
                                }
                            }
                        }

                        // 2. Fill Future Weeks with Historical Average (Distributed by Day Weights)
                        const weightsMonFri = [1, 2, 3, 4, 5].map(d => m.dayWeights[d] || 0);
                        const totalWeightMonFri = weightsMonFri.reduce((a, b) => a + b, 0);

                        for (let i = currentWeekIndex + 1; i < currentMonthWeeks.length; i++) {
                            const historicalTotal = m.charts.weeklyHistory[i] || 0;
                            if (historicalTotal > 0) {
                                const weekData = salesByWeekAndDay[i + 1];
                                // Fill Mon(1) to Fri(5)
                                for (let d = 1; d <= 5; d++) {
                                    const weight = m.dayWeights[d] || 0;
                                    const share = totalWeightMonFri > 0 ? (weight / totalWeightMonFri) : (1 / 5);
                                    weekData[d] = historicalTotal * share;
                                }
                            }
                        }
                    }
                    // --- FIM DA MODIFICAÇÃO ---

                    const dayNames = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
                    const professionalPalette = ['#a855f7', '#6366f1', '#ec4899', '#f97316', '#8b5cf6', '#06b6d4', '#f59e0b'];
                    const dailyBreakdownDatasets = dayNames.map((dayName, dayIndex) => ({ label: dayName, data: currentMonthWeeks.map((week, weekIndex) => salesByWeekAndDay[weekIndex + 1][dayIndex]), backgroundColor: professionalPalette[dayIndex % professionalPalette.length] }));
                    const weekLabelsForDailyChart = currentMonthWeeks.map((week, index) => { const startDateStr = week.start.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', timeZone: 'UTC' }); const endDateStr = week.end.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', timeZone: 'UTC' }); return `S${index + 1} (${startDateStr} à ${endDateStr})`; });

                    if (dailyBreakdownDatasets.some(ds => ds.data.some(d => d > 0))) {
                        createChart('dailyWeeklyComparisonChart', 'bar', weekLabelsForDailyChart, dailyBreakdownDatasets, {
                            plugins: {
                                legend: { display: true, position: 'top' },
                                tooltip: {
                                    mode: 'point',
                                    intersect: true,
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label) label += ': ';
                                            if (context.parsed.y !== null) {
                                                label += new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(context.parsed.y);
                                            }
                                            return label;
                                        },
                                        afterBody: function(context) {
                                            // Calculate Week Total
                                            const weekIndex = context[0].dataIndex; // All items in tooltip share same index (if grouped) or point
                                            // Ensure we are accessing the modified salesByWeekAndDay
                                            const weekData = salesByWeekAndDay[weekIndex + 1];
                                            const total = weekData.reduce((a, b) => a + b, 0);
                                            return '\nSemana: ' + new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(total);
                                        }
                                    }
                                },
                                datalabels: { display: false }
                            },
                            scales: { x: { stacked: false }, y: { stacked: false, ticks: { callback: (v) => (v / 1000).toFixed(0) + 'k' } } }
                        });
                    } else {
                        showNoDataMessage('dailyWeeklyComparisonChart', 'Sem dados para exibir.');
                    }

                    // Supervisor Table
                    const supervisorTableBody = document.getElementById('supervisorComparisonTableBody');
                    const supRows = Object.entries(m.charts.supervisorData).map(([sup, data]) => { const variation = data.history > 0 ? ((data.current - data.history) / data.history) * 100 : (data.current > 0 ? 100 : 0); const colorClass = variation > 0 ? 'text-green-400' : variation < 0 ? 'text-red-400' : 'text-slate-400'; return `<tr class="hover:bg-slate-700"><td class="px-4 py-2">${sup}</td><td class="px-4 py-2 text-right">${data.history.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td><td class="px-4 py-2 text-right">${data.current.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td><td class="px-4 py-2 text-right ${colorClass}">${variation.toFixed(2)}%</td></tr>`; }).join('');
                    supervisorTableBody.innerHTML = supRows;
                }, () => currentRenderId !== comparisonRenderId); // Cancel check
            }, () => currentRenderId !== comparisonRenderId); // Cancel check
        }

        function updateStockView() {
            stockRenderId++;
            const currentRenderId = stockRenderId;

            const { sales: filteredSales, history: filteredHistory } = getStockFilteredData();

            const filial = stockFilialFilter.value;
            const activeStockMap = getActiveStockMap(filial);

            // Sets for fast lookup
            const selectedSuppliersSet = new Set(selectedStockSuppliers);
            const selectedProductsSet = new Set(selectedStockProducts);
            const currentPasta = currentStockFornecedor;

            const productAnalysis = new Map();
            const productsWithFilteredActivity = new Set(); // Changed from Set to array logic below for chunking, but Set used for uniqueness

            // --- OPTIMIZATION: Pre-aggregate Sales Data by Product ---
            // Map<ProductCode, Array<Sale>>
            const salesByProduct = new Map();
            const historyByProduct = new Map();
            const historySalesListByProduct = new Map();
            const totalQtyByProduct = new Map();
            const currentMonthQtyByProduct = new Map();
            const uniqueMonthsByProduct = new Map();

            // Sync Pre-aggregation (O(N) is fast)
            const processSaleForAggregation = (s, isHistory) => {
                const p = s.PRODUTO;
                // Don't add to productsWithFilteredActivity yet, do it in the filtering loop below to respect stock filters

                if (!salesByProduct.has(p)) salesByProduct.set(p, []);
                salesByProduct.get(p).push(s);

                if (!uniqueMonthsByProduct.has(p)) uniqueMonthsByProduct.set(p, new Set());
                const d = parseDate(s.DTPED);
                if (d) uniqueMonthsByProduct.get(p).add(`${d.getUTCFullYear()}-${d.getUTCMonth()}`);

                const qty = s.QTVENDA_EMBALAGEM_MASTER;
                totalQtyByProduct.set(p, (totalQtyByProduct.get(p) || 0) + qty);

                if (isHistory) {
                    if (!historySalesListByProduct.has(p)) historySalesListByProduct.set(p, []);
                    historySalesListByProduct.get(p).push(s);

                    if (!historyByProduct.has(p)) historyByProduct.set(p, 0);
                    historyByProduct.set(p, historyByProduct.get(p) + 1);
                } else {
                    currentMonthQtyByProduct.set(p, (currentMonthQtyByProduct.get(p) || 0) + qty);
                }
            };

            filteredSales.forEach(s => processSaleForAggregation(s, false));
            filteredHistory.forEach(s => processSaleForAggregation(s, true));

            // Build the list of products to analyze based on STOCK or SALES activity + Filters
            activeStockMap.forEach((qty, productCode) => {
                if (qty > 0) {
                    const details = productDetailsMap.get(productCode);
                    if (!details) return;

                    if (selectedSuppliersSet.size > 0 && !selectedSuppliersSet.has(String(details.codfor))) return;
                    if (selectedProductsSet.size > 0 && !selectedProductsSet.has(String(productCode))) return;

                    if (currentPasta) {
                        const pastaDoProduto = optimizedData.productPastaMap.get(productCode) || '';
                        if (pastaDoProduto !== currentPasta) return;
                    }

                    productsWithFilteredActivity.add(productCode);
                }
            });

            // Also include products with sales even if 0 stock (logic from original)
            // Iterate salesByProduct keys (which implies sales existed)
            for (const productCode of totalQtyByProduct.keys()) {
                 if (productsWithFilteredActivity.has(productCode)) continue; // Already added

                 const details = productDetailsMap.get(productCode);
                 if (!details) continue; // Should be in details map if processed correctly

                 if (selectedSuppliersSet.size > 0 && !selectedSuppliersSet.has(String(details.codfor))) continue;
                 if (selectedProductsSet.size > 0 && !selectedProductsSet.has(String(productCode))) continue;
                 if (currentPasta) {
                    const pastaDoProduto = optimizedData.productPastaMap.get(productCode) || '';
                    if (pastaDoProduto !== currentPasta) continue;
                 }
                 productsWithFilteredActivity.add(productCode);
            }

            // Show Loading
            stockAnalysisTableBody.innerHTML = '<tr><td colspan="6" class="text-center p-8"><div class="flex justify-center items-center"><svg class="animate-spin h-8 w-8 text-teal-500 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="text-slate-400">Calculando estoque e tendências...</span></div></td></tr>';

            // Convert to array for chunking
            const productsArray = Array.from(productsWithFilteredActivity);

            // Pre-calculate global dates for trend
            const endDate = parseDate(sortedWorkingDays[sortedWorkingDays.length - 1]);

            // ASYNC PROCESS
            runAsyncChunked(productsArray, (productCode) => {
                if (!activeProductCodesFromCadastro.has(productCode)) return;

                const details = productDetailsMap.get(productCode) || {
                    descricao: `Produto ${productCode}`,
                    fornecedor: 'N/A',
                    codfor: 'N/A'
                };

                const stock = activeStockMap.get(productCode) || 0;
                const totalQtySold = totalQtyByProduct.get(productCode) || 0;

                if (stock <= 0 && totalQtySold <= 0) return;

                const hasHistory = historyByProduct.has(productCode);
                const currentMonthSalesQty = currentMonthQtyByProduct.get(productCode) || 0;
                const soldThisMonth = currentMonthSalesQty > 0;

                const productAllSales = salesByProduct.get(productCode) || [];

                const productCadastroDate = parseDate(details.dtCadastro);
                let productFirstWorkingDayIndex = 0;

                if (productCadastroDate) {
                    const cadastroDateString = productCadastroDate.toISOString().split('T')[0];
                    productFirstWorkingDayIndex = sortedWorkingDays.findIndex(d => d >= cadastroDateString);
                    if (productFirstWorkingDayIndex === -1) {
                        productFirstWorkingDayIndex = sortedWorkingDays.length;
                    }
                }

                const productMaxLifeInWorkingDays = sortedWorkingDays.length - productFirstWorkingDayIndex;
                const daysFromBox = customWorkingDaysStock;
                let effectiveDaysToCalculate;

                const isFactuallyNewOrReactivated = (!hasHistory && soldThisMonth);

                if (isFactuallyNewOrReactivated) {
                    const daysToConsider = (daysFromBox > 0) ? daysFromBox : passedWorkingDaysCurrentMonth;
                    effectiveDaysToCalculate = Math.min(passedWorkingDaysCurrentMonth, daysToConsider);
                } else {
                    if (daysFromBox > 0) {
                        effectiveDaysToCalculate = Math.min(daysFromBox, productMaxLifeInWorkingDays);
                    } else {
                        effectiveDaysToCalculate = productMaxLifeInWorkingDays;
                    }
                }

                const daysDivisor = effectiveDaysToCalculate > 0 ? effectiveDaysToCalculate : 1;
                const targetIndex = Math.max(0, sortedWorkingDays.length - daysDivisor);
                const startDate = parseDate(sortedWorkingDays[targetIndex]);

                let totalQtySoldInRange = 0;
                // Optimized loop
                productAllSales.forEach(sale => {
                    const saleDate = parseDate(sale.DTPED);
                    if (saleDate && saleDate >= startDate && saleDate <= endDate) {
                        totalQtySoldInRange += sale.QTVENDA_EMBALAGEM_MASTER;
                    }
                });

                let dailyAvgSale = totalQtySoldInRange / daysDivisor;
                const isNew = productMaxLifeInWorkingDays <= passedWorkingDaysCurrentMonth;
                const trendDays = dailyAvgSale > 0 ? (stock / dailyAvgSale) : (stock > 0 ? Infinity : 0);

                const productHistorySales = historySalesListByProduct.get(productCode) || [];
                const monthlyAvgSale = calculateStockMonthlyAverage(productHistorySales);

                productAnalysis.set(productCode, {
                    code: productCode,
                    ...details,
                    stock,
                    monthlyAvgSale,
                    dailyAvgSale,
                    trendDays,
                    currentMonthSalesQty,
                    isNew,
                    hasHistory,
                    soldThisMonth
                });
            }, () => {
                // --- ON COMPLETE (Render) ---
                if (currentRenderId !== stockRenderId) return;

                let sortedAnalysis = [...productAnalysis.values()].sort((a, b) => {
                     const trendA = isFinite(a.trendDays) ? a.trendDays : -1;
                     const trendB = isFinite(b.trendDays) ? b.trendDays : -1;
                    return trendB - trendA;
                });

                if (stockTrendFilter !== 'all') {
                    sortedAnalysis = sortedAnalysis.filter(item => {
                        const trend = item.trendDays;
                        if (stockTrendFilter === 'low') return isFinite(trend) && trend < 15;
                        if (stockTrendFilter === 'medium') return isFinite(trend) && trend >= 15 && trend < 30;
                        if (stockTrendFilter === 'good') return isFinite(trend) && trend >= 30;
                        return false;
                    });
                }

                stockAnalysisTableBody.innerHTML = sortedAnalysis.slice(0, 500).map(item => {
                    let trendText;
                    let newTag = item.isNew ? ` <span class="inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium bg-blue-500/30 text-blue-300 ml-1">NOVO</span>` : '';

                    if (!isFinite(item.trendDays) && item.stock > 0) {
                        trendText = `<span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-500/30 text-gray-300">S/ VENDA</span>`;
                    } else if (isFinite(item.trendDays)) {
                        const trendDays = Math.floor(item.trendDays);
                        let trendColor = 'text-slate-400';
                        if (trendDays < 15) trendColor = 'text-red-400';
                        else if (trendDays < 30) trendColor = 'text-yellow-400';
                        else trendColor = 'text-green-400';
                        trendText = `<span class="font-bold ${trendColor}">${trendDays} dias</span>`;
                    } else {
                        trendText = '-';
                    }

                    return `
                        <tr class="hover:bg-slate-700/50">
                            <td class="px-4 py-2 text-xs">(${item.code}) ${item.descricao}</td>
                            <td class="px-4 py-2 text-xs">(${item.codfor}) ${item.fornecedor.split(' ').slice(0, 4).join(' ')}</td>
                            <td class="px-4 py-2 text-right text-xs">${item.stock.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                            <td class="px-4 py-2 text-right text-xs">${item.monthlyAvgSale.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                            <td class="px-4 py-2 text-right text-xs">${item.dailyAvgSale.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                            <td class="px-4 py-2 text-right text-xs flex items-center justify-end">${trendText}${newTag}</td>
                        </tr>
                    `;
                }).join('');

                const growth = [];
                const decline = [];
                const newProducts = [];
                const lostProducts = [];

                productAnalysis.forEach(p => {
                     if (p.soldThisMonth && p.hasHistory) {
                            const variation = p.monthlyAvgSale > 0 ? ((p.currentMonthSalesQty - p.monthlyAvgSale) / p.monthlyAvgSale) * 100 : (p.currentMonthSalesQty > 0 ? Infinity : 0);
                            const productWithVariation = { ...p, variation };

                        if (p.currentMonthSalesQty >= p.monthlyAvgSale) {
                            growth.push(productWithVariation);
                        } else if (p.currentMonthSalesQty < p.monthlyAvgSale && p.monthlyAvgSale > 0) {
                            decline.push(productWithVariation);
                        }
                     } else if (p.soldThisMonth && !p.hasHistory) {
                        newProducts.push(p);
                     } else if (!p.soldThisMonth && p.stock > 0) {
                        lostProducts.push(p);
                     }
                });

                const renderProductTable = (bodyElement, data, showVariation = true) => {
                    bodyElement.innerHTML = data.map(p => {
                        const variation = p.monthlyAvgSale > 0 ? ((p.currentMonthSalesQty - p.monthlyAvgSale) / p.monthlyAvgSale) * 100 : (p.currentMonthSalesQty > 0 ? Infinity : 0);
                        const colorClass = variation > 0 ? 'text-green-400' : (variation < 0 ? 'text-red-400' : 'text-slate-400');
                        let variationText = '0%';
                        if (isFinite(variation)) {
                            variationText = `${variation.toFixed(0)}%`;
                        } else if (variation === Infinity) {
                             variationText = 'Novo';
                        }

                        return `
                            <tr class="hover:bg-slate-700/50">
                                <td class="px-2 py-1.5 text-xs">(${p.code}) ${p.descricao}</td>
                                <td class="px-2 py-1.5 text-xs text-right">${p.currentMonthSalesQty.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                                <td class="px-2 py-1.5 text-xs text-right">${p.monthlyAvgSale.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                                ${showVariation ? `<td class="px-2 py-1.5 text-xs text-right font-bold ${colorClass}">${variationText}</td>` : ''}
                                <td class="px-2 py-1.5 text-xs text-right">${p.stock.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                            </tr>
                        `;
                    }).join('');
                };

                growth.sort((a, b) => b.variation - a.variation);
                decline.sort((a, b) => a.variation - b.variation);
                newProducts.sort((a,b) => b.currentMonthSalesQty - a.currentMonthSalesQty);
                lostProducts.sort((a,b) => b.monthlyAvgSale - a.monthlyAvgSale);

                renderProductTable(growthTableBody, growth);
                renderProductTable(declineTableBody, decline);
                renderProductTable(newProductsTableBody, newProducts, false);
                renderProductTable(lostProductsTableBody, lostProducts, false);
            }, () => currentRenderId !== stockRenderId);
        }


        function getInnovationsMonthFilteredData(options = {}) {
            const { excludeFilter = null } = options;

            const sellers = selectedInnovationsMonthSellers;
            const city = innovationsMonthCityFilter.value.trim().toLowerCase();
            const filial = innovationsMonthFilialFilter.value;

            let clients = allClientsData;

            if (filial !== 'ambas') {
                clients = clients.filter(c => clientLastBranch.get(c['Código']) === filial);
            }

            if (excludeFilter !== 'supervisor' && selectedInnovationsSupervisors.length > 0) {
                const rcasSet = new Set();
                selectedInnovationsSupervisors.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                clients = clients.filter(c => {
                    const clientRcas = (c.rcas && Array.isArray(c.rcas)) ? c.rcas : [];
                    return clientRcas.some(rca => rcasSet.has(rca));
                });
            }
            if (excludeFilter !== 'seller' && sellers.length > 0) {
                const rcasOfSellers = new Set();
                 sellers.forEach(sellerName => {
                    const rcaCode = optimizedData.rcaCodeByName.get(sellerName);
                    if (rcaCode) rcasOfSellers.add(rcaCode);
                });
                clients = clients.filter(c => {
                    const clientRcas = (c.rcas && Array.isArray(c.rcas)) ? c.rcas : [];
                    return clientRcas.some(rca => rcasOfSellers.has(rca));
                });
            }
            if (excludeFilter !== 'city' && city) {
                clients = clients.filter(c => c.cidade && c.cidade.toLowerCase() === city);
            }

            return { clients };
        }

        function resetInnovationsMonthFilters() {
            selectedInnovationsSupervisors = [];
            innovationsMonthCityFilter.value = '';
            innovationsMonthFilialFilter.value = 'ambas';
            innovationsMonthCategoryFilter.value = '';
            selectedInnovationsMonthSellers = [];
            selectedInnovationsMonthTiposVenda = [];

            selectedInnovationsSupervisors = updateSupervisorFilter(document.getElementById('innovations-month-supervisor-filter-dropdown'), document.getElementById('innovations-month-supervisor-filter-text'), selectedInnovationsSupervisors, allSalesData);
            updateSellerFilter(selectedInnovationsSupervisors, innovationsMonthVendedorFilterDropdown, innovationsMonthVendedorFilterText, [], allSalesData);
            selectedInnovationsMonthTiposVenda = updateTipoVendaFilter(innovationsMonthTipoVendaFilterDropdown, innovationsMonthTipoVendaFilterText, selectedInnovationsMonthTiposVenda, [...allSalesData, ...allHistoryData]);
            updateInnovationsMonthView();
        }

        function updateInnovationsMonthView() {
            const selectedCategory = innovationsMonthCategoryFilter.value;

            // Initialize Global Categories if not already done (Optimization)
            if (!globalInnovationCategories && innovationsMonthData && innovationsMonthData.length > 0) {
                globalInnovationCategories = {};
                globalProductToCategoryMap = new Map();
                innovationsMonthData.forEach(item => {
                    const categoryName = item.Inovacoes || item.inovacoes || item.INOVACOES;
                    if (!categoryName) return;
                    if (!globalInnovationCategories[categoryName]) {
                        globalInnovationCategories[categoryName] = { productCodes: new Set(), products: [] };
                    }
                    const productCode = String(item.Codigo || item.codigo || item.CODIGO).trim();
                    globalInnovationCategories[categoryName].productCodes.add(productCode);
                    globalInnovationCategories[categoryName].products.push({ ...item, Codigo: productCode, Inovacoes: categoryName });
                    globalProductToCategoryMap.set(productCode, categoryName);
                });
            }

            const categories = globalInnovationCategories || {};
            const currentFilterValue = innovationsMonthCategoryFilter.value;
            const allCategories = Object.keys(categories).sort();

            // Only update dropdown if empty or number of items changed significantly (simplistic check)
            if (innovationsMonthCategoryFilter.options.length <= 1 && allCategories.length > 0) {
                innovationsMonthCategoryFilter.innerHTML = '<option value="">Todas as Categorias</option>';
                allCategories.forEach(cat => {
                    innovationsMonthCategoryFilter.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
                if (allCategories.includes(currentFilterValue)) {
                    innovationsMonthCategoryFilter.value = currentFilterValue;
                }
            }

            const { clients: filteredClients } = getInnovationsMonthFilteredData();

            const sellers = selectedInnovationsMonthSellers;
            const sellerRcaCodes = new Set();
            if (sellers.length > 0) {
                sellers.forEach(sellerName => {
                    const rcaCode = optimizedData.rcaCodeByName.get(sellerName);
                    if (rcaCode) sellerRcaCodes.add(rcaCode);
                });
            } else if (selectedInnovationsSupervisors.length > 0) {
                selectedInnovationsSupervisors.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => sellerRcaCodes.add(rca));
                });
            }

            const activeClients = filteredClients.filter(c => {
                const codcli = c['Código'];
                const rca1 = String(c.rca1 || '').trim();
                if (rca1 === '306' || rca1 === '300') return false;
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                return (isAmericanas || rca1 !== '53' || clientsWithSalesThisMonth.has(codcli));
            });
            const activeClientsCount = activeClients.length;
            const activeClientCodes = new Set(activeClients.map(c => c['Código']));

            // --- OPTIMIZED AGGREGATION LOGIC ---

            // Determine types to use
            const availableTypes = new Set([...allSalesData.map(s => s.TIPOVENDA), ...allHistoryData.map(s => s.TIPOVENDA)]);
            let currentSelection = selectedInnovationsMonthTiposVenda.length > 0 ? selectedInnovationsMonthTiposVenda : Array.from(availableTypes);
            const currentSelectionKey = currentSelection.slice().sort().join(',');

            // Caching Strategy: Reuse maps if Tipo Venda selection hasn't changed
            let mapsCurrent, mapsPrevious;
            if (viewState.inovacoes.lastTypesKey === currentSelectionKey && viewState.inovacoes.cache) {
                mapsCurrent = viewState.inovacoes.cache.mapsCurrent;
                mapsPrevious = viewState.inovacoes.cache.mapsPrevious;
            } else {
                const mainTypes = currentSelection.filter(t => t !== '5' && t !== '11');
                const bonusTypes = currentSelection.filter(t => t === '5' || t === '11');

                // Optimized Map Building (2 passes instead of 4)
                mapsCurrent = buildInnovationSalesMaps(allSalesData, mainTypes, bonusTypes);
                mapsPrevious = buildInnovationSalesMaps(allHistoryData, mainTypes, bonusTypes);

                viewState.inovacoes.lastTypesKey = currentSelectionKey;
                viewState.inovacoes.cache = { mapsCurrent, mapsPrevious };
            }

            // Structures to hold results
            // categoryResults[catName] = { current: Set<CodCli>, previous: Set<CodCli>, bonusCurrent: Set<CodCli>, bonusPrevious: Set<CodCli> }
            // productResults[prodCode] = { current: Set<CodCli> } -> For Top Item Logic
            const categoryResults = {};
            const productResults = {};

            for (const cat in categories) {
                categoryResults[cat] = {
                    current: new Set(),
                    previous: new Set(),
                    bonusCurrent: new Set(),
                    bonusPrevious: new Set()
                };
                categories[cat].productCodes.forEach(p => {
                    productResults[p] = { current: new Set(), previous: new Set() };
                });
            }

            // Helper to process maps and populate sets
            const processMap = (salesMap, isCurrent, isBonus) => {
                salesMap.forEach((productsMap, codCli) => {
                    // Only count if client is in the filtered active list
                    if (!activeClientCodes.has(codCli)) return;

                    productsMap.forEach((rcas, prodCode) => {
                        const category = globalProductToCategoryMap ? globalProductToCategoryMap.get(prodCode) : null;
                        if (!category) return; // Should not happen if innovation data is consistent

                        // Check RCA Filter
                        let soldBySelected = false;
                        if (sellerRcaCodes.size === 0) {
                            soldBySelected = true;
                        } else {
                            // Check intersection of rcas and sellerRcaCodes
                            for (const rca of rcas) {
                                if (sellerRcaCodes.has(rca)) {
                                    soldBySelected = true;
                                    break;
                                }
                            }
                        }

                        if (!soldBySelected) return;

                        const targetSetField = isCurrent ? 'current' : 'previous';

                        // Add to Category Set (Normal or Bonus)
                        if (categoryResults[category]) {
                            if (isBonus) {
                                categoryResults[category][isCurrent ? 'bonusCurrent' : 'bonusPrevious'].add(codCli);
                            } else {
                                categoryResults[category][targetSetField].add(codCli);
                            }
                        }

                        // Add to Product Set (For Top Item Logic)
                        if (productResults[prodCode]) {
                            productResults[prodCode][targetSetField].add(codCli);
                        }
                    });
                });
            };

            // Process all 4 maps efficiently (Looping over Sales, not all Clients)
            processMap(mapsCurrent.mainMap, true, false);
            processMap(mapsCurrent.bonusMap, true, true);
            processMap(mapsPrevious.mainMap, false, false);
            processMap(mapsPrevious.bonusMap, false, true);

            // Consolidate Results
            const categoryAnalysis = {};
            let topCoverageItem = { name: '-', coverage: 0, clients: 0 };

            // Consolidate Product Results for Top Item
            // We need to merge Main and Bonus for product coverage if needed,
            // but `processMap` populated `productResults` separately for main/bonus?
            // Wait, `processMap` handles Main and Bonus calls sequentially.
            // `productResults[prodCode].current` is a Set.
            // If we call processMap for Main, it adds clients.
            // If we call processMap for Bonus, it adds clients to SAME Set.
            // So `productResults` automatically handles the UNION of Main and Bonus coverage per product.

            if (selectedCategory && categories[selectedCategory]) {
                categories[selectedCategory].products.forEach(product => {
                    const pCode = String(product.Codigo).trim();
                    if (productResults[pCode]) {
                        const count = productResults[pCode].current.size;
                        const coverage = activeClientsCount > 0 ? (count / activeClientsCount) * 100 : 0;
                        if (coverage > topCoverageItem.coverage) {
                            topCoverageItem = { name: `(${pCode}) ${product.Produto}`, coverage, clients: count };
                        }
                    }
                });
            } else {
                // Top Category Logic
                for (const cat in categoryResults) {
                    const set = categoryResults[cat].current; // Main coverage
                    // Wait, original logic: "gotItCurrent" if sales OR bonus.
                    // My categoryResults structure separates them. I need to union them for the metric?
                    // Original logic:
                    // clientsWhoGotAnyVisibleProductCurrent.add(codcli) if (Sales OR Bonus) of ANY product in category.

                    // Let's create a Union Set for the category coverage metric
                    const unionSet = new Set([...categoryResults[cat].current, ...categoryResults[cat].bonusCurrent]);
                    const count = unionSet.size;
                    const coverage = activeClientsCount > 0 ? (count / activeClientsCount) * 100 : 0;

                    if (coverage > topCoverageItem.coverage) {
                        topCoverageItem = { name: cat, coverage, clients: count };
                    }
                }
            }

            // Calculate Global KPIs (Union of all categories selected)
            const clientsWhoGotAnyVisibleProductCurrent = new Set();
            const clientsWhoGotAnyVisibleProductPrevious = new Set();
            const clientsWhoGotBonusAnyVisibleProductCurrent = new Set();
            const clientsWhoGotBonusAnyVisibleProductPrevious = new Set();

            for (const cat in categoryResults) {
                if (selectedCategory && cat !== selectedCategory) continue;

                // Merge sets into global KPI sets
                categoryResults[cat].current.forEach(c => clientsWhoGotAnyVisibleProductCurrent.add(c));
                categoryResults[cat].previous.forEach(c => clientsWhoGotAnyVisibleProductPrevious.add(c));
                categoryResults[cat].bonusCurrent.forEach(c => clientsWhoGotBonusAnyVisibleProductCurrent.add(c));
                categoryResults[cat].bonusPrevious.forEach(c => clientsWhoGotBonusAnyVisibleProductPrevious.add(c));

                // Prepare Analysis Object for Chart/Table
                const currentUnion = new Set([...categoryResults[cat].current, ...categoryResults[cat].bonusCurrent]);
                const previousUnion = new Set([...categoryResults[cat].previous, ...categoryResults[cat].bonusPrevious]);

                // NOTE: The chart/table in original code used "coverageCurrent" derived from
                // (clientsCurrentCount / activeClientsCount).
                // clientsCurrentCount was incremented if (Sales OR Bonus).

                const countCurr = currentUnion.size;
                const countPrev = previousUnion.size;

                const covCurr = activeClientsCount > 0 ? (countCurr / activeClientsCount) * 100 : 0;
                const covPrev = activeClientsCount > 0 ? (countPrev / activeClientsCount) * 100 : 0;
                const varPct = covPrev > 0 ? ((covCurr - covPrev) / covPrev) * 100 : (covCurr > 0 ? Infinity : 0);

                categoryAnalysis[cat] = {
                    coverageCurrent: covCurr,
                    coveragePrevious: covPrev,
                    variation: varPct,
                    clientsCount: countCurr,
                    clientsPreviousCount: countPrev
                };
            }

            // Total KPI calculations (Union of Sets)
            // Note: Original code did:
            // clientsWhoGotAnyVisibleProductCurrent -> Sales
            // clientsWhoGotBonusAnyVisibleProductCurrent -> Bonus
            // It kept them separate for the KPI cards at the top.
            // "Innovations Month Selection Coverage" -> Sales
            // "Innovations Month Bonus Coverage" -> Bonus

            const selectionCoveredCountCurrent = clientsWhoGotAnyVisibleProductCurrent.size;
            const selectionCoveragePercentCurrent = activeClientsCount > 0 ? (selectionCoveredCountCurrent / activeClientsCount) * 100 : 0;
            const selectionCoveredCountPrevious = clientsWhoGotAnyVisibleProductPrevious.size;
            const selectionCoveragePercentPrevious = activeClientsCount > 0 ? (selectionCoveredCountPrevious / activeClientsCount) * 100 : 0;

            const bonusCoveredCountCurrent = clientsWhoGotBonusAnyVisibleProductCurrent.size;
            const bonusCoveragePercentCurrent = activeClientsCount > 0 ? (bonusCoveredCountCurrent / activeClientsCount) * 100 : 0;
            const bonusCoveredCountPrevious = clientsWhoGotBonusAnyVisibleProductPrevious.size;
            const bonusCoveragePercentPrevious = activeClientsCount > 0 ? (bonusCoveredCountPrevious / activeClientsCount) * 100 : 0;

            // Update DOM
            innovationsMonthActiveClientsKpi.textContent = activeClientsCount.toLocaleString('pt-BR');
            innovationsMonthTopCoverageValueKpi.textContent = `${topCoverageItem.coverage.toFixed(2)}%`;
            innovationsMonthTopCoverageKpi.textContent = topCoverageItem.name;
            innovationsMonthTopCoverageKpi.title = topCoverageItem.name;
            innovationsMonthTopCoverageCountKpi.textContent = `${topCoverageItem.clients.toLocaleString('pt-BR')} PDVs`;
            document.getElementById('innovations-month-top-coverage-title').textContent = selectedCategory ? 'Produto com Maior Cobertura' : 'Categoria com Maior Cobertura';

            innovationsMonthSelectionCoverageValueKpi.textContent = `${selectionCoveragePercentCurrent.toFixed(2)}%`;
            innovationsMonthSelectionCoverageCountKpi.textContent = `${selectionCoveredCountCurrent.toLocaleString('pt-BR')} de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;
            innovationsMonthSelectionCoverageValueKpiPrevious.textContent = `${selectionCoveragePercentPrevious.toFixed(2)}%`;
            innovationsMonthSelectionCoverageCountKpiPrevious.textContent = `${selectionCoveredCountPrevious.toLocaleString('pt-BR')} de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;

            innovationsMonthBonusCoverageValueKpi.textContent = `${bonusCoveragePercentCurrent.toFixed(2)}%`;
            innovationsMonthBonusCoverageCountKpi.textContent = `${bonusCoveredCountCurrent.toLocaleString('pt-BR')} de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;
            innovationsMonthBonusCoverageValueKpiPrevious.textContent = `${bonusCoveragePercentPrevious.toFixed(2)}%`;
            innovationsMonthBonusCoverageCountKpiPrevious.textContent = `${bonusCoveredCountPrevious.toLocaleString('pt-BR')} de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;

            // Chart Update
            chartLabels = Object.keys(categoryAnalysis).sort((a,b) => categoryAnalysis[b].coverageCurrent - categoryAnalysis[a].coverageCurrent);
            const chartDataCurrent = chartLabels.map(cat => categoryAnalysis[cat].coverageCurrent);
            const chartDataPrevious = chartLabels.map(cat => categoryAnalysis[cat].coveragePrevious);

            if (chartLabels.length > 0) {
                createChart('innovations-month-chart', 'bar', chartLabels, [
                    { label: 'Mês Anterior', data: chartDataPrevious, backgroundColor: '#f97316' },
                    { label: 'Mês Atual', data: chartDataCurrent, backgroundColor: '#06b6d4' }
                ], {
                    plugins: {
                        legend: { display: true, position: 'top' },
                        datalabels: {
                            anchor: 'end',
                            align: 'top',
                            offset: 8,
                            formatter: (value) => value > 0 ? value.toFixed(1) + '%' : '',
                            color: '#cbd5e1',
                            font: { size: 10 }
                        },
                         tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += context.parsed.y.toFixed(2) + '%';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: { y: { ticks: { callback: (v) => `${v}%` } } },
                    layout: { padding: { top: 20 } }
                });
            } else {
                showNoDataMessage('innovations-month-chart', 'Sem dados de inovações para exibir com os filtros atuais.');
            }

            // Table Update
            const tableData = [];
            const activeStockMap = getActiveStockMap(innovationsMonthFilialFilter.value);

            chartLabels.forEach(categoryName => {
                const categoryData = categories[categoryName];

                categoryData.products.forEach((product) => {
                    const productCode = product.Codigo;
                    const productName = product.Produto;
                    const stock = activeStockMap.get(productCode) || 0;

                    // Re-calculate per product using the Product Results Sets
                    // Optimization: productResults[productCode] already contains sets of clients who bought
                    const pRes = productResults[productCode];

                    // IMPORTANT: productResults contains ALL clients who bought.
                    // We must filter by 'activeClientCodes' if not already done?
                    // 'processMap' already checked: `if (!activeClientCodes.has(codCli)) return;`
                    // So the sets in productResults are already filtered by active clients.

                    const clientsCurrentCount = pRes ? pRes.current.size : 0;
                    const clientsPreviousCount = pRes ? pRes.previous.size : 0;

                    const coverageCurrent = activeClientsCount > 0 ? (clientsCurrentCount / activeClientsCount) * 100 : 0;
                    const coveragePrevious = activeClientsCount > 0 ? (clientsPreviousCount / activeClientsCount) * 100 : 0;
                    const variation = coveragePrevious > 0 ? ((coverageCurrent - coveragePrevious) / coveragePrevious) * 100 : (coverageCurrent > 0 ? Infinity : 0);

                    tableData.push({
                        categoryName,
                        productCode,
                        productName,
                        stock,
                        coveragePrevious,
                        clientsPreviousCount,
                        coverageCurrent,
                        clientsCurrentCount,
                        variation
                    });
                });
            });

            tableData.sort((a,b) => b.coverageCurrent - a.coverageCurrent);
            innovationsMonthTableDataForExport = tableData;

            innovationsMonthTableBody.innerHTML = tableData.map(item => {
                let variationContent;
                if (isFinite(item.variation)) {
                    const colorClass = item.variation >= 0 ? 'text-green-400' : 'text-red-400';
                    variationContent = `<span class="${colorClass}">${item.variation.toFixed(1)}%</span>`;
                } else if (item.coverageCurrent > 0) {
                    variationContent = `<span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-purple-500/30 text-purple-300">Novo</span>`;
                } else {
                    variationContent = `<span>-</span>`;
                }

                return `
                    <tr class="hover:bg-slate-700/50">
                        <td class="px-2 py-1.5 text-xs">${item.categoryName}</td>
                        <td class="px-2 py-1.5 text-xs">${item.productCode} - ${item.productName}</td>
                        <td class="px-2 py-1.5 text-xs text-right">${item.stock.toLocaleString('pt-BR')}</td>
                        <td class="px-2 py-1.5 text-xs text-right">
                            <div class="tooltip">${item.coveragePrevious.toFixed(2)}%<span class="tooltip-text">${item.clientsPreviousCount} PDVs</span></div>
                        </td>
                        <td class="px-2 py-1.5 text-xs text-right">
                            <div class="tooltip">${item.coverageCurrent.toFixed(2)}%<span class="tooltip-text">${item.clientsCurrentCount} PDVs</span></div>
                        </td>
                        <td class="px-2 py-1.5 text-xs text-right">${variationContent}</td>
                    </tr>
                `;
            }).join('');

            // Innovations by Client Table
            const innovationsByClientTableHead = document.getElementById('innovations-by-client-table-head');
            const innovationsByClientTableBody = document.getElementById('innovations-by-client-table-body');
            const innovationsByClientLegend = document.getElementById('innovations-by-client-legend');

            categoryLegendForExport = chartLabels.map((name, index) => `${index + 1} - ${name}`);
            innovationsByClientLegend.innerHTML = `<strong>Legenda:</strong> ${categoryLegendForExport.join('; ')}`;

            let tableHeadHTML = `
                <tr>
                    <th class="px-2 py-2 text-left">Código</th>
                    <th class="px-2 py-2 text-left">Cliente</th>
                    <th class="px-2 py-2 text-left">Cidade</th>
                    <th class="px-2 py-2 text-left">Bairro</th>
                    <th class="px-2 py-2 text-center">Últ. Compra</th>
            `;
            chartLabels.forEach((name, index) => {
                tableHeadHTML += `<th class="px-2 py-2 text-center">${index + 1}</th>`;
            });
            tableHeadHTML += `</tr>`;
            innovationsByClientTableHead.innerHTML = tableHeadHTML;

            // Build Client Status List
            // Optimized: Iterate Active Clients and check sets in categoryResults
            const clientInnovationStatus = activeClients.map(client => {
                const codcli = client['Código'];
                const status = {};

                chartLabels.forEach(catName => {
                    // Check if client exists in Main OR Bonus sets for this category
                    const inMain = categoryResults[catName].current.has(codcli);
                    const inBonus = categoryResults[catName].bonusCurrent.has(codcli);
                    status[catName] = inMain || inBonus;
                });

                // Explicit copy for robustness against Proxies
                return {
                    'Código': client['Código'],
                    fantasia: client.fantasia,
                    razaoSocial: client.razaoSocial,
                    cidade: client.cidade,
                    bairro: client.bairro,
                    ultimaCompra: client.ultimaCompra,
                    innovationStatus: status
                };
            });

            clientInnovationStatus.sort((a, b) => {
                const cidadeA = a.cidade || '';
                const cidadeB = b.cidade || '';
                const bairroA = a.bairro || '';
                const bairroB = b.bairro || '';
                if (cidadeA.localeCompare(cidadeB) !== 0) return cidadeA.localeCompare(cidadeB);
                return bairroA.localeCompare(bairroB);
            });

            innovationsByClientForExport = clientInnovationStatus;

            // Pagination for Innovations Client Table
            const itemsPerPage = 100;
            const totalPages = Math.ceil(clientInnovationStatus.length / itemsPerPage);
            let currentPage = 1;

            const renderInnovationsPage = (page) => {
                const startIndex = (page - 1) * itemsPerPage;
                const endIndex = startIndex + itemsPerPage;
                const pageData = clientInnovationStatus.slice(startIndex, endIndex);

                const checkIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-400 mx-auto" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
                const xIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-red-400 mx-auto" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`;

                let tableBodyHTML = '';
                pageData.forEach(client => {
                    tableBodyHTML += `
                        <tr class="hover:bg-slate-700/50">
                            <td class="px-2 py-1.5 text-xs">${client['Código']}</td>
                            <td class="px-2 py-1.5 text-xs">${client.fantasia || client.razaoSocial}</td>
                            <td class="px-2 py-1.5 text-xs">${client.cidade}</td>
                            <td class="px-2 py-1.5 text-xs">${client.bairro}</td>
                            <td class="px-2 py-1.5 text-xs text-center">${formatDate(client.ultimaCompra)}</td>
                    `;
                    chartLabels.forEach(catName => {
                        tableBodyHTML += `<td class="px-2 py-1.5 text-center">${client.innovationStatus[catName] ? checkIcon : xIcon}</td>`;
                    });
                    tableBodyHTML += `</tr>`;
                });
                innovationsByClientTableBody.innerHTML = tableBodyHTML;

                // Update Pagination Controls
                const prevBtn = document.getElementById('innovations-prev-page-btn');
                const nextBtn = document.getElementById('innovations-next-page-btn');
                const infoText = document.getElementById('innovations-page-info-text');
                const controls = document.getElementById('innovations-pagination-controls');

                if (controls) {
                    if (totalPages > 1) {
                        controls.classList.remove('hidden');
                        infoText.textContent = `Página ${page} de ${totalPages} (${clientInnovationStatus.length} clientes)`;
                        prevBtn.disabled = page === 1;
                        nextBtn.disabled = page === totalPages;

                        // Clone and replace buttons to remove old event listeners
                        const newPrevBtn = prevBtn.cloneNode(true);
                        const newNextBtn = nextBtn.cloneNode(true);
                        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
                        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);

                        newPrevBtn.addEventListener('click', () => {
                            if (currentPage > 1) {
                                currentPage--;
                                renderInnovationsPage(currentPage);
                            }
                        });
                        newNextBtn.addEventListener('click', () => {
                            if (currentPage < totalPages) {
                                currentPage++;
                                renderInnovationsPage(currentPage);
                            }
                        });

                    } else {
                        controls.classList.add('hidden');
                    }
                }
            };

            renderInnovationsPage(1);
        }

        async function exportInnovationsMonthPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('landscape');

            const supervisor = document.getElementById('innovations-month-supervisor-filter-text').textContent;
            const vendedor = document.getElementById('innovations-month-vendedor-filter-text').textContent;
            const filial = innovationsMonthFilialFilter.options[innovationsMonthFilialFilter.selectedIndex].text;
            const cidade = innovationsMonthCityFilter.value.trim();
            const categoria = innovationsMonthCategoryFilter.value || 'Todas';
            const generationDate = new Date().toLocaleString('pt-BR');

            doc.setFontSize(18);
            doc.text('Relatório de Inovações do Mês', 14, 22);
            doc.setFontSize(10);
            doc.setTextColor(10);
            doc.text(`Data de Emissão: ${generationDate}`, 14, 30);

            let filterText = `Filtros Aplicados: Supervisor: ${supervisor} | Vendedor: ${vendedor} | Filial: ${filial} | Cidade: ${cidade || 'Todas'} | Categoria: ${categoria}`;
            const splitFilters = doc.splitTextToSize(filterText, 270);
            doc.text(splitFilters, 14, 36);

            const chartCanvas = document.getElementById('innovations-month-chart');
            if (chartCanvas && charts['innovations-month-chart'] && chartLabels.length > 0) {
                try {
                    const chartInstance = charts['innovations-month-chart'];
                    const originalDatalabelsColor = chartInstance.options.plugins.datalabels.color;
                    const originalXColor = chartInstance.options.scales.x.ticks.color;
                    const originalYColor = chartInstance.options.scales.y.ticks.color;
                    const originalLegendColor = chartInstance.options.plugins.legend?.labels?.color;

                    chartInstance.options.plugins.datalabels.color = '#000000';
                    chartInstance.options.scales.x.ticks.color = '#000000';
                    chartInstance.options.scales.y.ticks.color = '#000000';
                    if (chartInstance.options.plugins.legend && chartInstance.options.plugins.legend.labels) {
                        chartInstance.options.plugins.legend.labels.color = '#000000';
                    }

                    chartInstance.update('none');

                    const chartImage = chartCanvas.toDataURL('image/png', 1.0);
                    doc.addImage(chartImage, 'PNG', 14, 50, 270, 100);

                    chartInstance.options.plugins.datalabels.color = originalDatalabelsColor;
                    chartInstance.options.scales.x.ticks.color = originalXColor;
                    chartInstance.options.scales.y.ticks.color = originalYColor;
                    if (chartInstance.options.plugins.legend && chartInstance.options.plugins.legend.labels) {
                        chartInstance.options.plugins.legend.labels.color = originalLegendColor;
                    }
                    chartInstance.update('none');
                } catch (e) {
                    console.error("Erro ao converter o gráfico para imagem:", e);
                    doc.text("Erro ao gerar a imagem do gráfico.", 14, 50);
                }
            } else {
                 doc.text("Gráfico não disponível para os filtros selecionados.", 14, 50);
            }

            const head = [['Categoria', 'Produto', 'Estoque', 'Cob. Mês Ant.', 'Cob. Mês Atual', 'Variação']];
            const body = [];

            innovationsMonthTableDataForExport.forEach(item => {
                let variationContent;
                if (isFinite(item.variation)) {
                    variationContent = `${item.variation.toFixed(1)}%`;
                } else if (item.coverageCurrent > 0) {
                    variationContent = 'Novo';
                } else {
                    variationContent = '-';
                }

                const row = [
                    item.categoryName,
                    `${item.productCode} - ${item.productName}`,
                    item.stock.toLocaleString('pt-BR'),
                    `${item.coveragePrevious.toFixed(2)}% (${item.clientsPreviousCount} PDVs)`,
                    `${item.coverageCurrent.toFixed(2)}% (${item.clientsCurrentCount} PDVs)`,
                    variationContent
                ];
                body.push(row);
            });

            doc.autoTable({
                head: head,
                body: body,
                startY: 155,
                theme: 'grid',
                styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
                headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 7, fontStyle: 'bold' },
                alternateRowStyles: { fillColor: [240, 248, 255] },
                didDrawPage: function (data) {
                    doc.setFontSize(12);
                    doc.setTextColor(10);
                    doc.text("Dados do Gráfico", data.settings.margin.left, 152);
                }
            });

            if (innovationsByClientForExport.length > 0) {
                doc.addPage();
                doc.setFontSize(18);
                doc.text('Relatório de Inovações por Cliente', 14, 22);
                doc.setFontSize(10);
                doc.setTextColor(10);
                doc.text(`Data de Emissão: ${generationDate}`, 14, 30);
                doc.text(splitFilters, 14, 36);

                const legendText = `Legenda: ${categoryLegendForExport.join('; ')}`;
                const splitLegend = doc.splitTextToSize(legendText, 270);
                doc.text(splitLegend, 14, 42);

                const clientInnovationsHead = [['Código', 'Cliente', 'Cidade', 'Bairro', 'Últ. Compra', ...categoryLegendForExport.map((_, i) => `${i + 1}`)]];
                const clientInnovationsBody = innovationsByClientForExport.map(client => {
                    const row = [
                        client['Código'],
                        client.fantasia || client.razaoSocial,
                        client.cidade,
                        client.bairro,
                        formatDate(client.ultimaCompra)
                    ];
                    categoryLegendForExport.forEach((cat, index) => {
                        const catName = cat.split(' - ')[1];
                        const status = client.innovationStatus[catName];

                        const cell = {
                            content: status ? 'S' : 'N',
                            styles: {
                                textColor: status ? [34, 139, 34] : [220, 20, 60],
                                fontStyle: 'bold'
                            }
                        };
                        row.push(cell);
                    });
                    return row;
                });

                doc.autoTable({
                    head: clientInnovationsHead,
                    body: clientInnovationsBody,
                    startY: 55,
                    theme: 'grid',
                    styles: { fontSize: 7, cellPadding: 1.5, halign: 'center', textColor: [0, 0, 0] },
                    headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 7, fontStyle: 'bold' },
                    columnStyles: {
                        0: { halign: 'left' },
                        1: { halign: 'left' },
                        2: { halign: 'left' },
                        3: { halign: 'left' },
                        4: { halign: 'center' }
                    },
                    alternateRowStyles: { fillColor: [240, 248, 255] },
                });
            }

            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(9);
                doc.setTextColor(10);
                doc.text(`Página ${i} de ${pageCount}`, doc.internal.pageSize.width / 2, doc.internal.pageSize.height - 10, { align: 'center' });
            }

            let fileNameParam = 'geral';
            if (selectedInnovationsMonthSellers.length === 1) {
                fileNameParam = getFirstName(selectedInnovationsMonthSellers[0]);
            } else if (cidade) {
                fileNameParam = cidade;
            }
            const safeFileNameParam = fileNameParam.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            doc.save(`relatorio_inovacoes_mes_${safeFileNameParam}_${new Date().toISOString().slice(0,10)}.pdf`);
        }


        async function exportCoveragePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('landscape');

            const supervisor = document.getElementById('coverage-supervisor-filter-text').textContent;
            const vendedor = document.getElementById('coverage-vendedor-filter-text').textContent;
            const filial = coverageFilialFilter.options[coverageFilialFilter.selectedIndex].text;
            const cidade = coverageCityFilter.value.trim();
            const supplierText = document.getElementById('coverage-supplier-filter-text').textContent;
            const generationDate = new Date().toLocaleString('pt-BR');

            doc.setFontSize(18);
            doc.text('Relatório de Cobertura (Estoque x PDVs)', 14, 22);
            doc.setFontSize(10);
            doc.setTextColor(10);
            doc.text(`Data de Emissão: ${generationDate}`, 14, 30);

            let filterText = `Filtros Aplicados: Supervisor: ${supervisor} | Vendedor: ${vendedor} | Filial: ${filial} | Cidade: ${cidade || 'Todas'} | Fornecedor: ${supplierText}`;
            const splitFilters = doc.splitTextToSize(filterText, 270);
            doc.text(splitFilters, 14, 36);

            // Add Chart if available
            const chartId = currentCoverageChartMode === 'city' ? 'coverageCityChart' : 'coverageSellerChart';
            const chartCanvas = document.getElementById(chartId);
            if (chartCanvas && charts[chartId]) {
                try {
                    const chartInstance = charts[chartId];
                    const originalDatalabelsColor = chartInstance.options.plugins.datalabels.color;
                    const originalXColor = chartInstance.options.scales.x.ticks.color;
                    const originalYColor = chartInstance.options.scales.y.ticks.color;
                    const originalLegendColor = chartInstance.options.plugins.legend?.labels?.color;

                    chartInstance.options.plugins.datalabels.color = '#000000';
                    chartInstance.options.scales.x.ticks.color = '#000000';
                    chartInstance.options.scales.y.ticks.color = '#000000';
                    if (chartInstance.options.plugins.legend && chartInstance.options.plugins.legend.labels) {
                        chartInstance.options.plugins.legend.labels.color = '#000000';
                    }

                    chartInstance.update('none');

                    const chartImage = chartCanvas.toDataURL('image/png', 1.0);
                    doc.addImage(chartImage, 'PNG', 14, 50, 270, 80);

                    chartInstance.options.plugins.datalabels.color = originalDatalabelsColor;
                    chartInstance.options.scales.x.ticks.color = originalXColor;
                    chartInstance.options.scales.y.ticks.color = originalYColor;
                    if (chartInstance.options.plugins.legend && chartInstance.options.plugins.legend.labels) {
                        chartInstance.options.plugins.legend.labels.color = originalLegendColor;
                    }
                    chartInstance.update('none');
                } catch (e) {
                    console.error("Erro ao converter o gráfico para imagem:", e);
                }
            }

            const head = [['Produto', 'Estoque (Cx)', 'Cx. Mês Ant.', 'Cx. Mês Atual', 'Caixas (%)', 'PDVs Ant.', 'PDVs Atual', 'Cobertura (%)']];
            const body = [];

            coverageTableDataForExport.forEach(item => {
                let boxesVariationContent;
                if (isFinite(item.boxesVariation)) {
                    boxesVariationContent = `${item.boxesVariation.toFixed(1)}%`;
                } else if (item.boxesVariation === Infinity) {
                    boxesVariationContent = 'Novo';
                } else {
                    boxesVariationContent = '-';
                }

                let pdvVariationContent;
                if (isFinite(item.pdvVariation)) {
                    pdvVariationContent = `${item.pdvVariation.toFixed(1)}%`;
                } else if (item.pdvVariation === Infinity) {
                    pdvVariationContent = 'Novo';
                } else {
                    pdvVariationContent = '-';
                }

                const row = [
                    item.descricao,
                    item.stockQty.toLocaleString('pt-BR'),
                    item.boxesSoldPreviousMonth.toLocaleString('pt-BR', {maximumFractionDigits: 2}),
                    item.boxesSoldCurrentMonth.toLocaleString('pt-BR', {maximumFractionDigits: 2}),
                    boxesVariationContent,
                    item.clientsPreviousCount.toLocaleString('pt-BR'),
                    item.clientsCurrentCount.toLocaleString('pt-BR'),
                    pdvVariationContent
                ];
                body.push(row);
            });

            doc.autoTable({
                head: head,
                body: body,
                startY: 140,
                theme: 'grid',
                styles: { fontSize: 8, cellPadding: 1.5, textColor: [0, 0, 0] },
                headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 8, fontStyle: 'bold' },
                alternateRowStyles: { fillColor: [240, 248, 255] },
                 didDrawPage: function (data) {
                    // Footer or Header on new pages
                }
            });

            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(9);
                doc.setTextColor(10);
                doc.text(`Página ${i} de ${pageCount}`, doc.internal.pageSize.width / 2, doc.internal.pageSize.height - 10, { align: 'center' });
            }

            let fileNameParam = 'geral';
            if (selectedCoverageSellers.length === 1) {
                fileNameParam = getFirstName(selectedCoverageSellers[0]);
            } else if (cidade) {
                fileNameParam = cidade;
            }
            const safeFileNameParam = fileNameParam.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            doc.save(`relatorio_cobertura_${safeFileNameParam}_${new Date().toISOString().slice(0,10)}.pdf`);
        }


        function openModal(pedidoId) {
            const orderInfo = aggregatedOrders.find(order => order.PEDIDO == pedidoId);
            const itemsDoPedido = allSalesData.filter(item => item.PEDIDO == pedidoId);
            if (!orderInfo) return;
            modalPedidoId.textContent = pedidoId;
            modalHeaderInfo.innerHTML = `<div><p class="font-bold">Cód. Cliente:</p><p>${orderInfo.CODCLI || 'N/A'}</p></div><div><p class="font-bold">Cliente:</p><p>${orderInfo.CLIENTE_NOME || 'N/A'}</p></div><div><p class="font-bold">Vendedor:</p><p>${orderInfo.NOME || 'N/A'}</p></div><div><p class="font-bold">Data Pedido:</p><p>${formatDate(orderInfo.DTPED)}</p></div><div><p class="font-bold">Data Faturamento:</p><p>${formatDate(orderInfo.DTSAIDA)}</p></div><div><p class="font-bold">Cidade:</p><p>${orderInfo.CIDADE || 'N/A'}</p></div>`;
            modalTableBody.innerHTML = itemsDoPedido.map(item => { const unitPrice = (item.QTVENDA > 0) ? (item.VLVENDA / item.QTVENDA) : 0; return `<tr class="hover:bg-slate-700"><td class="px-4 py-2">(${item.PRODUTO}) ${item.DESCRICAO}</td><td class="px-4 py-2 text-right">${item.QTVENDA}</td><td class="px-4 py-2 text-right">${item.TOTPESOLIQ.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} Kg</td><td class="px-4 py-2 text-right"><div class="tooltip">${unitPrice.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}<span class="tooltip-text" style="width: max-content; transform: translateX(-50%); margin-left: 0;">Subtotal: ${item.VLVENDA.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</span></div></td></tr>`; }).join('');
            modalFooterTotal.innerHTML = `<p class="text-lg font-bold text-teal-400">Mix de Produtos: ${itemsDoPedido.length}</p><p class="text-lg font-bold text-emerald-400">Total do Pedido: ${orderInfo.VLVENDA.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</p>`;
            modal.classList.remove('hidden');
        }

        function openClientModal(codcli) {
            const clientData = allClientsData.find(c => String(c['Código']) === String(codcli));
            if (!clientData) return;

            const getVal = (obj, keys) => {
                for (const k of keys) {
                    if (obj[k] !== undefined && obj[k] !== null && obj[k] !== 'N/A' && obj[k] !== '') return obj[k];
                }
                return undefined;
            };

            const endereco = getVal(clientData, ['Endereço Comercial', 'endereco', 'ENDERECO']) || 'N/A';
            const numero = getVal(clientData, ['NUMERO', 'numero', 'Número']) || 'SN';
            let finalAddress = endereco;
            if (numero !== 'SN' && finalAddress !== 'N/A' && !finalAddress.includes(numero)) finalAddress += `, ${numero}`;

            const cnpj = getVal(clientData, ['CNPJ/CPF', 'cnpj_cpf']) || 'N/A';
            const insc = getVal(clientData, ['Insc. Est. / Produtor', 'inscricaoEstadual', 'INSCRICAOESTADUAL']) || 'N/A';
            const razao = getVal(clientData, ['Cliente', 'razaoSocial', 'nomeCliente', 'RAZAOSOCIAL', 'NOMECLIENTE']) || 'N/A';
            const fantasia = getVal(clientData, ['FANTASIA', 'Fantasia', 'fantasia']) || 'N/A';
            const bairro = getVal(clientData, ['BAIRRO', 'Bairro', 'bairro']) || 'N/A';
            const cidade = getVal(clientData, ['CIDADE', 'Cidade', 'cidade', 'Nome da Cidade']) || 'N/A';
            const cep = getVal(clientData, ['CEP', 'cep']) || 'N/A';
            const telefone = getVal(clientData, ['Telefone Comercial', 'telefone', 'TELEFONE']) || 'N/A';
            const email = getVal(clientData, ['EMAIL', 'email', 'E-mail']) || 'N/A';
            const ramo = getVal(clientData, ['Descricao', 'ramo', 'DESCRICAO', 'Descricao']) || 'N/A';
            const ultimaCompra = getVal(clientData, ['Data da Última Compra', 'ultimaCompra', 'ULTIMACOMPRA']);

            clientModalContent.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4 text-sm"><div><p class="font-bold text-slate-400">Código:</p><p>${clientData['Código'] || 'N/A'}</p></div><div><p class="font-bold text-slate-400">CNPJ/CPF:</p><p>${cnpj}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Insc. Est. / Produtor:</p><p>${insc}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Razão Social:</p><p>${razao}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Nome Fantasia:</p><p>${fantasia}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Endereço:</p><p>${finalAddress}</p></div><div><p class="font-bold text-slate-400">Bairro:</p><p>${bairro}</p></div><div><p class="font-bold text-slate-400">Cidade:</p><p>${cidade}</p></div><div><p class="font-bold text-slate-400">CEP:</p><p>${cep}</p></div><div><p class="font-bold text-slate-400">Telefone:</p><p>${telefone}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">E-mail:</p><p>${email}</p></div><div><p class="font-bold text-slate-400">Ramo de Atividade:</p><p>${ramo}</p></div><div><p class="font-bold text-slate-400">Última Compra:</p><p>${formatDate(ultimaCompra)}</p></div></div>`;
            clientModal.classList.remove('hidden');
        }

        function exportClientsPDF(clientList, title, filename, includeFaturamento) {
             if (clientList.length === 0) return;
            const { jsPDF } = window.jspdf; const doc = new jsPDF();
            const supervisor = document.getElementById('city-supervisor-filter-text').textContent;
            const vendedor = document.getElementById('city-vendedor-filter-text').textContent;
            const city = cityNameFilter.value.trim();
            const generationDate = new Date().toLocaleString('pt-BR'); const today = new Date();
            const firstDay = new Date(today.getFullYear(), today.getMonth(), 1).toLocaleDateString('pt-BR');
            const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0).toLocaleDateString('pt-BR');
            doc.setFontSize(18); doc.text(title, 14, 22); doc.setFontSize(11); doc.setTextColor(10);
            doc.text(`Período de Análise: ${firstDay} a ${lastDay}`, 14, 32);
            doc.text(`Supervisor: ${supervisor}`, 14, 38); doc.text(`Vendedor: ${vendedor}`, 14, 44);
            doc.text(`Cidade: ${city || 'Todas'}`, 14, 50);
            doc.text(`Data de Emissão: ${generationDate}`, 14, 56);
            const tableColumn = ["Código", "Cliente", "Bairro", "Cidade", "Últ. Compra"];
            if (includeFaturamento) tableColumn.splice(2, 0, "Faturamento");

            clientList.sort((a, b) => {
                const cidadeA = a.cidade || a.CIDADE || a['Nome da Cidade'] || '';
                const cidadeB = b.cidade || b.CIDADE || b['Nome da Cidade'] || '';
                const bairroA = a.bairro || a.BAIRRO || '';
                const bairroB = b.bairro || b.BAIRRO || '';
                if (cidadeA < cidadeB) return -1;
                if (cidadeA > cidadeB) return 1;
                if (bairroA < bairroB) return -1;
                if (bairroA > bairroB) return 1;
                return 0;
            });

            const tableRows = [];
            let totalFaturamento = 0;

            clientList.forEach(client => {
                const fantasia = client.fantasia || client.FANTASIA || client.Fantasia || '';
                const razao = client.razaoSocial || client.Cliente || client.RAZAOSOCIAL || '';
                const nome = fantasia || razao;
                const bairro = client.bairro || client.BAIRRO || client.Bairro || '';
                const cidade = client.cidade || client.CIDADE || client.Cidade || client['Nome da Cidade'] || '';
                const ultCompra = client.ultimaCompra || client['Data da Última Compra'] || client.ULTIMACOMPRA;

                const clientData = [ client['Código'] || '', nome, bairro, cidade, formatDate(ultCompra) || 'N/A' ];
                if (includeFaturamento) {
                    const val = client.total || 0;
                    totalFaturamento += val;
                    clientData.splice(2, 0, val.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }));
                }
                tableRows.push(clientData);
            });

            if (includeFaturamento) {
                const footerRow = [
                    { content: 'TOTAL:', colSpan: 2, styles: { halign: 'right', fontStyle: 'bold', fontSize: 10, fillColor: [50, 50, 50], textColor: [255, 255, 255] } },
                    { content: totalFaturamento.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }), styles: { fontStyle: 'bold', fontSize: 10, fillColor: [50, 50, 50], textColor: [50, 255, 100] } },
                    { content: '', colSpan: 3, styles: { fillColor: [50, 50, 50] } }
                ];
                tableRows.push(footerRow);
            } else {
                const footerRow = [
                    { content: 'TOTAL CLIENTES:', colSpan: 2, styles: { halign: 'right', fontStyle: 'bold', fontSize: 10, fillColor: [50, 50, 50], textColor: [255, 255, 255] } },
                    { content: String(clientList.length), colSpan: 3, styles: { fontStyle: 'bold', fontSize: 10, fillColor: [50, 50, 50], textColor: [255, 255, 255] } }
                ];
                tableRows.push(footerRow);
            }

            doc.autoTable({ head: [tableColumn], body: tableRows, startY: 60, theme: 'grid', styles: { fontSize: 8, cellPadding: 1.5, textColor: [0, 0, 0] }, headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 8, fontStyle: 'bold' }, alternateRowStyles: { fillColor: [240, 248, 255] }, margin: { top: 10 } });
            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) { doc.setPage(i); doc.setFontSize(9); doc.setTextColor(10); doc.text(`Página ${i} de ${pageCount}`, doc.internal.pageSize.width / 2, doc.internal.pageSize.height - 10, { align: 'center' }); }

            let fileNameParam = 'geral';
            if (selectedCitySellers.length === 1) {
                fileNameParam = getFirstName(selectedCitySellers[0]);
            } else if (city) {
                fileNameParam = city;
            }
            const safeFileNameParam = fileNameParam.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            doc.save(`${filename}_${safeFileNameParam}_${new Date().toISOString().slice(0,10)}.pdf`);
        }

        function renderCalendar(year, month) {
            const monthNames = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];

            let calendarHTML = `
                <div class="flex justify-between items-center mb-4">
                    <button id="prev-month-btn" class="p-2 rounded-full hover:bg-slate-600">&lt;</button>
                    <h3 class="font-bold text-lg">${monthNames[month]} ${year}</h3>
                    <button id="next-month-btn" class="p-2 rounded-full hover:bg-slate-600">&gt;</button>
                </div>
                <div class="grid grid-cols-7 gap-1 text-center text-xs text-slate-400 mb-2">
                    <div>Dom</div><div>Seg</div><div>Ter</div><div>Qua</div><div>Qui</div><div>Sex</div><div>Sáb</div>
                </div>
                <div id="calendar-grid" class="grid grid-cols-7 gap-1">
            `;
            const firstDay = new Date(Date.UTC(year, month, 1)).getUTCDay();
            const daysInMonth = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();

            for (let i = 0; i < firstDay; i++) {
                calendarHTML += `<div></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(Date.UTC(year, month, day));
                const dateString = date.toISOString().split('T')[0];
                const isSelected = selectedHolidays.includes(dateString);
                const isToday = date.getTime() === lastSaleDate.getTime();
                let dayClasses = 'p-2 rounded-full cursor-pointer hover:bg-slate-600 flex items-center justify-center';
                if (isSelected) dayClasses += ' bg-red-500 text-white font-bold';
                if (isToday) dayClasses += ' border-2 border-teal-400';

                calendarHTML += `<div class="${dayClasses}" data-date="${dateString}">${day}</div>`;
            }

            calendarHTML += `</div>`;
            calendarContainer.innerHTML = calendarHTML;
        }

        function initializeRedeFilters() {
            const hasRedeData = allClientsData.some(client => client.ramo && client.ramo !== 'N/A');

            const mainRedeFilterWrapper = document.getElementById('main-rede-filter-wrapper');
            const cityRedeFilterWrapper = document.getElementById('city-rede-filter-wrapper');
            const comparisonRedeFilterWrapper = document.getElementById('comparison-rede-filter-wrapper');
            const stockRedeFilterWrapper = document.getElementById('stock-rede-filter-wrapper');

            if (mainRedeFilterWrapper) mainRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
            if (cityRedeFilterWrapper) cityRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
            if (comparisonRedeFilterWrapper) comparisonRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
            if (stockRedeFilterWrapper) stockRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
        }

        function debounce(func, delay = 300) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        function showLoader(text = 'Carregando...') {
            return new Promise(resolve => {
                const loader = document.getElementById('page-transition-loader');
                const loaderText = document.getElementById('loader-text');
                if (loader && loaderText) {
                    document.body.setAttribute('data-loading', 'true');
                    loaderText.textContent = text;
                    loader.classList.remove('opacity-0', 'pointer-events-none');
                    setTimeout(resolve, 50);
                } else {
                    resolve();
                }
            });
        }

        function hideLoader() {
             return new Promise(resolve => {
                const loader = document.getElementById('page-transition-loader');
                if (loader) {
                    document.body.removeAttribute('data-loading');
                    loader.classList.add('opacity-0', 'pointer-events-none');
                    setTimeout(resolve, 300);
                } else {
                    resolve();
                }
            });
        }

        function toggleSidebar() {
            const sideMenu = document.getElementById('side-menu');
            const sidebarOverlay = document.getElementById('sidebar-overlay');

            if (sideMenu) sideMenu.classList.toggle('-translate-x-full');
            if (sidebarOverlay) sidebarOverlay.classList.toggle('hidden');
        }

        async function navigateTo(view) {
            const sideMenu = document.getElementById('side-menu');
            const sidebarOverlay = document.getElementById('sidebar-overlay');

            if (sideMenu) sideMenu.classList.add('-translate-x-full');
            if (sidebarOverlay) sidebarOverlay.classList.add('hidden');

            const viewNameMap = {
                dashboard: 'Dashboard',
                pedidos: 'Pedidos',
                comparativo: 'Comparativo',
                estoque: 'Estoque',
                cobertura: 'Cobertura',
                cidades: 'Cidades',
                semanal: 'Semanal',
                'inovacoes-mes': 'Inovações',
                mix: 'Mix'
            };
            const friendlyName = viewNameMap[view] || 'a página';

            await showLoader(`Carregando ${friendlyName}...`);

            // This function now runs after the loader is visible
            const updateContent = () => {
                [mainDashboard, cityView, weeklyView, comparisonView, stockView, innovationsMonthView, coverageView, document.getElementById('mix-view'), goalsView].forEach(el => {
                    if(el) el.classList.add('hidden');
                });

                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('bg-slate-700', 'text-white');
                    const icon = link.querySelector('svg');
                    if(icon) icon.classList.remove('text-white');
                });

                const activeLink = document.querySelector(`.nav-link[data-target="${view}"]`);
                if (activeLink) {
                    activeLink.classList.add('bg-slate-700', 'text-white');
                    const icon = activeLink.querySelector('svg');
                    if(icon) icon.classList.add('text-white');
                }

                switch(view) {
                    case 'dashboard':
                        mainDashboard.classList.remove('hidden');
                        chartView.classList.remove('hidden');
                        tableView.classList.add('hidden');
                        tablePaginationControls.classList.add('hidden');
                        if (viewState.dashboard.dirty) {
                            updateAllVisuals();
                            viewState.dashboard.dirty = false;
                        }
                        break;
                    case 'pedidos':
                        mainDashboard.classList.remove('hidden');
                        chartView.classList.add('hidden');
                        tableView.classList.remove('hidden');
                        tablePaginationControls.classList.remove('hidden');
                        if (viewState.pedidos.dirty) {
                            updateAllVisuals();
                            viewState.pedidos.dirty = false;
                        }
                        break;
                    case 'comparativo':
                        comparisonView.classList.remove('hidden');
                        if (viewState.comparativo.dirty) {
                            updateAllComparisonFilters();
                            updateComparisonView();
                            viewState.comparativo.dirty = false;
                        }
                        break;
                    case 'estoque':
                        stockView.classList.remove('hidden');
                        if (viewState.estoque.dirty) {
                            handleStockFilterChange();
                            viewState.estoque.dirty = false;
                        }
                        break;
                    case 'cobertura':
                        coverageView.classList.remove('hidden');
                        if (viewState.cobertura.dirty) {
                            updateAllCoverageFilters();
                            updateCoverageView();
                            viewState.cobertura.dirty = false;
                        }
                        break;
                    case 'cidades':
                        cityView.classList.remove('hidden');
                        if (viewState.cidades.dirty) {
                            updateAllCityFilters();
                            updateCityView();
                            viewState.cidades.dirty = false;
                        }
                        break;
                    case 'semanal':
                        weeklyView.classList.remove('hidden');
                        if (viewState.semanal.dirty) {
                            populateWeeklyFilters();
                            updateWeeklyView();
                            viewState.semanal.dirty = false;
                        }
                        break;
                    case 'inovacoes-mes':
                        innovationsMonthView.classList.remove('hidden');
                        if (viewState.inovacoes.dirty) {
                            selectedInnovationsSupervisors = updateSupervisorFilter(document.getElementById('innovations-month-supervisor-filter-dropdown'), document.getElementById('innovations-month-supervisor-filter-text'), selectedInnovationsSupervisors, allSalesData);
                            updateSellerFilter(selectedInnovationsSupervisors, innovationsMonthVendedorFilterDropdown, innovationsMonthVendedorFilterText, [], allSalesData);
                            selectedInnovationsMonthTiposVenda = updateTipoVendaFilter(innovationsMonthTipoVendaFilterDropdown, innovationsMonthTipoVendaFilterText, selectedInnovationsMonthTiposVenda, [...allSalesData, ...allHistoryData]);
                            updateInnovationsMonthView();
                            viewState.inovacoes.dirty = false;
                        }
                        break;
                    case 'mix':
                        document.getElementById('mix-view').classList.remove('hidden');
                        if (viewState.mix.dirty) {
                            updateAllMixFilters();
                            updateMixView();
                            viewState.mix.dirty = false;
                        }
                        break;
                    case 'goals':
                        goalsView.classList.remove('hidden');
                        if (viewState.goals.dirty) {
                            updateGoalsView();
                            viewState.goals.dirty = false;
                        }
                        break;
                }
            };

            updateContent();

            await hideLoader();
        }

        async function enviarDadosParaSupabase(data) {
            const supabaseUrl = document.getElementById('supabase-url').value;
            const supabaseKeyInput = document.getElementById('supabase-key').value.trim();

            // Tentamos obter a sessão atual do usuário
            const { data: { session } } = await supabaseClient.auth.getSession();

            // Definição da chave de autenticação (Token)
            // Prioridade: Chave fornecida manualmente (Service Role) > Token da sessão do usuário logado
            // Isso permite que o usuário use a chave secreta para upload (bypass RLS) mesmo estando logado com um usuário sem permissão.
            const authToken = supabaseKeyInput || session?.access_token;

            // --- VALIDAÇÃO DA CHAVE SECRETA ---
            if (supabaseKeyInput) {
                if (supabaseKeyInput.startsWith('sb_secret')) {
                    alert("A chave 'sb_secret' não é suportada diretamente pelo Uploader. Por favor, utilize a chave **service_role** do tipo JWT (que começa com 'ey...') disponível em Project Settings > API no Dashboard do Supabase.");
                    throw new Error("Formato de chave inválido (sb_secret detectado). Use o JWT service_role.");
                }
                if (supabaseKeyInput.startsWith('sb_publishable')) {
                    alert("Você inseriu a chave PÚBLICA (sb_publishable) no campo de senha. Esta chave não tem permissão para gravar dados. Por favor, insira a chave SECRETA (service_role) que começa com 'ey...'.");
                    throw new Error("Chave pública inserida no lugar da secreta.");
                }
                if (!supabaseKeyInput.includes('.')) {
                    alert("O formato da chave secreta parece inválido. O sistema espera um Token JWT (que contém pontos separando as partes) e geralmente começa com 'ey...'. Verifique se copiou a chave 'service_role' (secret) correta.");
                    throw new Error("Formato de chave inválido (JWT esperado).");
                }
            }
            // ----------------------------------

            // Definição da API Key (Header 'apikey')
            // O Supabase exige que o header 'apikey' contenha a chave ANÔNIMA para passar pelo Gateway sem erro de "Forbidden use of secret key".
            // O header 'Authorization' carrega o token real (Sessão ou Chave Secreta).
            const apiKeyHeader = (typeof SUPABASE_ANON_KEY !== 'undefined') ? SUPABASE_ANON_KEY : supabaseKeyInput;

            if (!supabaseUrl || !authToken) {
                alert("Por favor, preencha a URL e certifique-se de estar logado ou forneça a Chave Secreta.");
                return;
            }

            // Removido: const sbClient = supabase.createClient(supabaseUrl, supabaseKey);
            // Motivo: "Forbidden use of secret API key in browser"

            const statusText = document.getElementById('status-text');
            const progressBar = document.getElementById('progress-bar');
            const statusContainer = document.getElementById('status-container');

            statusContainer.classList.remove('hidden');
            const updateStatus = (msg, percent) => {
                statusText.textContent = msg;
                progressBar.style.width = `${percent}%`;
            };

            const BATCH_SIZE = 1000;

            const performUpsert = async (table, batch) => {
                const response = await fetch(`${supabaseUrl}/rest/v1/${table}`, {
                    method: 'POST',
                    headers: {
                        'apikey': apiKeyHeader,
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'resolution=merge-duplicates'
                    },
                    body: JSON.stringify(batch)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erro Supabase (${response.status}): ${errorText}`);
                }
            };

            const clearTable = async (table, pkColumn = 'id') => {
                // Deleta todas as linhas da tabela (onde pkColumn não é nulo)
                // É mais seguro usar uma condição que sempre é verdadeira se não houver truncate explícito
                const response = await fetch(`${supabaseUrl}/rest/v1/${table}?${pkColumn}=not.is.null`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': apiKeyHeader,
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erro ao limpar tabela ${table}: ${errorText}`);
                }
            };

            // List of columns that are dates and need conversion from timestamp (ms) to ISO String
            const dateColumns = new Set(['dtped', 'dtsaida', 'ultimacompra', 'datacadastro', 'dtcadastro', 'updated_at']);

            const formatValue = (key, value) => {
                // If it's a date column and value is a number, convert to ISO string
                if (dateColumns.has(key) && typeof value === 'number') {
                    // Check for valid timestamp (not 0 or crazy value) if needed,
                    // but usually new Date(val).toISOString() handles valid ms numbers.
                    // Postgres timestamp range: 4713 BC to 294276 AD.
                    // 1764720000000 is year 2025, which is fine.
                    try {
                        return new Date(value).toISOString();
                    } catch (e) {
                        return null; // Fallback for invalid dates
                    }
                }
                return value;
            };

            const uploadColumnarBatch = async (table, columnarData) => {
                const totalRows = columnarData.length;
                const columns = columnarData.columns;

                for (let i = 0; i < totalRows; i += BATCH_SIZE) {
                    const batch = [];
                    const end = Math.min(i + BATCH_SIZE, totalRows);

                    for (let j = i; j < end; j++) {
                        const row = {};
                        for (const col of columns) {
                            // OPTION B: Convert keys to lowercase to match Supabase DB schema
                            const lowerKey = col.toLowerCase();
                            const val = columnarData.values[col][j];
                            row[lowerKey] = formatValue(lowerKey, val);
                        }
                        batch.push(row);
                    }

                    await performUpsert(table, batch);

                    const progress = Math.round((i / totalRows) * 100);
                    updateStatus(`Enviando ${table}: ${progress}%`, progress);
                }
            };

            const uploadArrayBatch = async (table, arrayData) => {
                for (let i = 0; i < arrayData.length; i += BATCH_SIZE) {
                    const rawBatch = arrayData.slice(i, i + BATCH_SIZE);

                    // OPTION B: Convert keys to lowercase for Supabase
                    const batch = rawBatch.map(item => {
                        const newItem = {};
                        for (const key in item) {
                            const lowerKey = key.toLowerCase();
                            newItem[lowerKey] = formatValue(lowerKey, item[key]);
                        }
                        return newItem;
                    });

                    await performUpsert(table, batch);
                     const progress = Math.round((i / arrayData.length) * 100);
                    updateStatus(`Enviando ${table}: ${progress}%`, progress);
                }
            }

            try {
                if (data.detailed && data.detailed.length > 0) {
                    await clearTable('data_detailed');
                    await uploadColumnarBatch('data_detailed', data.detailed);
                }
                if (data.history && data.history.length > 0) {
                    await clearTable('data_history');
                    await uploadColumnarBatch('data_history', data.history);
                }
                if (data.byOrder && data.byOrder.length > 0) {
                    await clearTable('data_orders');
                    await uploadArrayBatch('data_orders', data.byOrder);
                }
                if (data.clients && data.clients.length > 0) {
                    await clearTable('data_clients');
                    await uploadColumnarBatch('data_clients', data.clients);
                }
                if (data.stock && data.stock.length > 0) {
                    await clearTable('data_stock');
                    await uploadArrayBatch('data_stock', data.stock);
                }
                if (data.innovations && data.innovations.length > 0) {
                    await clearTable('data_innovations');
                    await uploadArrayBatch('data_innovations', data.innovations);
                }
                if (data.product_details && data.product_details.length > 0) {
                    await clearTable('data_product_details', 'code');
                    await uploadArrayBatch('data_product_details', data.product_details);
                }
                if (data.active_products && data.active_products.length > 0) {
                    await clearTable('data_active_products', 'code');
                    await uploadArrayBatch('data_active_products', data.active_products);
                }
                if (data.metadata && data.metadata.length > 0) {
                    await clearTable('data_metadata', 'key');
                    await uploadArrayBatch('data_metadata', data.metadata);
                }

                updateStatus('Upload Concluído com Sucesso!', 100);
                alert('Dados enviados com sucesso!');
                setTimeout(() => statusContainer.classList.add('hidden'), 3000);

            } catch (error) {
                console.error(error);
                updateStatus('Erro: ' + error.message, 0);
                alert('Erro durante o upload: ' + error.message);
            }
        }

        function setupEventListeners() {
            // Uploader Logic
            const openAdminBtn = document.getElementById('open-admin-btn');
            const adminModal = document.getElementById('admin-uploader-modal');
            const adminCloseBtn = document.getElementById('admin-modal-close-btn');

            if (openAdminBtn) {
                openAdminBtn.addEventListener('click', () => {
                    adminModal.classList.remove('hidden');
                });
            }
            if (adminCloseBtn) {
                adminCloseBtn.addEventListener('click', () => {
                    adminModal.classList.add('hidden');
                });
            }

            const generateBtn = document.getElementById('generate-btn');
            if (generateBtn) {
                generateBtn.addEventListener('click', () => {
                    const salesFile = document.getElementById('sales-file-input').files[0];
                    const clientsFile = document.getElementById('clients-file-input').files[0];
                    const productsFile = document.getElementById('products-file-input').files[0];
                    const historyFile = document.getElementById('history-file-input').files[0];
                    const innovationsFile = document.getElementById('innovations-file-input').files[0];

                    if (!salesFile && !historyFile) {
                        alert("Pelo menos o arquivo de Vendas ou Histórico é necessário.");
                        return;
                    }

                    // Initialize Worker
                    const blob = new Blob([document.getElementById('worker-script').textContent], { type: 'text/javascript' });
                    const worker = new Worker(window.URL.createObjectURL(blob));

                    document.getElementById('status-container').classList.remove('hidden');
                    document.getElementById('status-text').textContent = "Processando arquivos...";

                    worker.postMessage({ salesFile, clientsFile, productsFile, historyFile, innovationsFile });

                    worker.onmessage = (e) => {
                        const { type, data, status, percentage, message } = e.data;
                        if (type === 'progress') {
                            document.getElementById('status-text').textContent = status;
                            document.getElementById('progress-bar').style.width = percentage + '%';
                        } else if (type === 'result') {
                            enviarDadosParaSupabase(data);
                            worker.terminate();
                        } else if (type === 'error') {
                            alert('Erro no processamento: ' + message);
                            worker.terminate();
                        }
                    };
                });
            }

            // Helper to mark dirty states
            const markDirty = (view) => {
                if (viewState[view]) viewState[view].dirty = true;
            };

            document.querySelectorAll('.sidebar-toggle').forEach(btn => btn.addEventListener('click', toggleSidebar));
            const closeSidebarBtn = document.getElementById('close-sidebar-btn');
            if(closeSidebarBtn) closeSidebarBtn.addEventListener('click', toggleSidebar);
            const sidebarOverlay = document.getElementById('sidebar-overlay');
            if(sidebarOverlay) sidebarOverlay.addEventListener('click', toggleSidebar);

            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    const target = e.currentTarget.dataset.target;
                    navigateTo(target);
                });
            });

            // --- Dashboard/Pedidos Filters ---
            const updateDashboard = () => {
                markDirty('dashboard'); markDirty('pedidos');
                updateAllVisuals();
            };

            const supervisorFilterBtn = document.getElementById('supervisor-filter-btn');
            const supervisorFilterDropdown = document.getElementById('supervisor-filter-dropdown');
            supervisorFilterBtn.addEventListener('click', () => supervisorFilterDropdown.classList.toggle('hidden'));
            supervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMainSupervisors.push(value);
                    else selectedMainSupervisors = selectedMainSupervisors.filter(s => s !== value);

                    selectedSellers = []; // Reset sellers when supervisor changes to avoid inconsistent state? Or keep valid intersection?
                    // Better: Re-run updateSellerFilter which filters 'selectedSellers' to only keep valid ones.
                    selectedMainSupervisors = updateSupervisorFilter(supervisorFilterDropdown, document.getElementById('supervisor-filter-text'), selectedMainSupervisors, allSalesData);
                    selectedSellers = updateSellerFilter(selectedMainSupervisors, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData);
                    mainTableState.currentPage = 1;
                    updateDashboard();
                }
            });

            const fornecedorFilterBtn = document.getElementById('fornecedor-filter-btn');
            const fornecedorFilterDropdown = document.getElementById('fornecedor-filter-dropdown');
            fornecedorFilterBtn.addEventListener('click', () => fornecedorFilterDropdown.classList.toggle('hidden'));
            fornecedorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMainSuppliers.push(value);
                    else selectedMainSuppliers = selectedMainSuppliers.filter(s => s !== value);

                    let supplierDataSource = [...allSalesData, ...allHistoryData];
                    if (currentFornecedor) {
                        supplierDataSource = supplierDataSource.filter(s => s.OBSERVACAOFOR === currentFornecedor);
                    }
                    selectedMainSuppliers = updateSupplierFilter(fornecedorFilterDropdown, document.getElementById('fornecedor-filter-text'), selectedMainSuppliers, supplierDataSource, 'main');
                    mainTableState.currentPage = 1;
                    updateDashboard();
                }
            });

            vendedorFilterBtn.addEventListener('click', () => vendedorFilterDropdown.classList.toggle('hidden'));
            vendedorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedSellers.push(value); else selectedSellers = selectedSellers.filter(s => s !== value);
                    selectedSellers = updateSellerFilter(selectedMainSupervisors, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData);
                    mainTableState.currentPage = 1;
                    updateDashboard();
                }
            });

            tipoVendaFilterBtn.addEventListener('click', () => tipoVendaFilterDropdown.classList.toggle('hidden'));
            tipoVendaFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedTiposVenda.push(value);
                    else selectedTiposVenda = selectedTiposVenda.filter(s => s !== value);
                    selectedTiposVenda = updateTipoVendaFilter(tipoVendaFilterDropdown, tipoVendaFilterText, selectedTiposVenda, allSalesData);
                    mainTableState.currentPage = 1;
                    updateDashboard();
                }
            });

            posicaoFilter.addEventListener('change', () => { mainTableState.currentPage = 1; updateDashboard(); });
            const debouncedUpdateDashboard = debounce(updateDashboard, 400);
            codcliFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                mainTableState.currentPage = 1;
                debouncedUpdateDashboard();
            });
            clearFiltersBtn.addEventListener('click', () => { resetMainFilters(); markDirty('dashboard'); markDirty('pedidos'); });

            prevPageBtn.addEventListener('click', () => {
                if (mainTableState.currentPage > 1) {
                    mainTableState.currentPage--;
                    renderTable(mainTableState.filteredData);
                }
            });
            nextPageBtn.addEventListener('click', () => {
                if (mainTableState.currentPage < mainTableState.totalPages) {
                    mainTableState.currentPage++;
                    renderTable(mainTableState.filteredData);
                }
            });

            mainComRedeBtn.addEventListener('click', () => mainRedeFilterDropdown.classList.toggle('hidden'));
            mainRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    mainRedeGroupFilter = button.dataset.group;
                    mainRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    if (mainRedeGroupFilter !== 'com_rede') {
                        mainRedeFilterDropdown.classList.add('hidden');
                        selectedMainRedes = [];
                    }
                    updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);
                    mainTableState.currentPage = 1;
                    updateDashboard();
                }
            });
            mainRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMainRedes.push(value);
                    else selectedMainRedes = selectedMainRedes.filter(r => r !== value);
                    selectedMainRedes = updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);
                    mainTableState.currentPage = 1;
                    updateDashboard();
                }
            });

            // --- City View Filters ---
            const updateCity = () => {
                markDirty('cidades');
                handleCityFilterChange();
            };

            const citySupervisorFilterBtn = document.getElementById('city-supervisor-filter-btn');
            const citySupervisorFilterDropdown = document.getElementById('city-supervisor-filter-dropdown');
            citySupervisorFilterBtn.addEventListener('click', () => citySupervisorFilterDropdown.classList.toggle('hidden'));
            citySupervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedCitySupervisors.push(value);
                    else selectedCitySupervisors = selectedCitySupervisors.filter(s => s !== value);

                    selectedCitySellers = [];
                    handleCityFilterChange();
                }
            });

            cityVendedorFilterBtn.addEventListener('click', () => cityVendedorFilterDropdown.classList.toggle('hidden'));
            cityVendedorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedCitySellers.includes(value)) selectedCitySellers.push(value);
                    } else {
                        selectedCitySellers = selectedCitySellers.filter(s => s !== value);
                    }
                    handleCityFilterChange({ skipFilter: 'seller' });
                }
            });

            cityTipoVendaFilterBtn.addEventListener('click', () => cityTipoVendaFilterDropdown.classList.toggle('hidden'));
            cityTipoVendaFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedCityTiposVenda.includes(value)) selectedCityTiposVenda.push(value);
                    } else {
                        selectedCityTiposVenda = selectedCityTiposVenda.filter(s => s !== value);
                    }
                    handleCityFilterChange({ skipFilter: 'tipoVenda' });
                }
            });

            cityComRedeBtn.addEventListener('click', () => cityRedeFilterDropdown.classList.toggle('hidden'));
            cityRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    cityRedeGroupFilter = button.dataset.group;
                    cityRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');

                    if (cityRedeGroupFilter !== 'com_rede') {
                        cityRedeFilterDropdown.classList.add('hidden');
                        selectedCityRedes = [];
                    }
                    handleCityFilterChange();
                }
            });
            cityRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedCityRedes.push(value);
                    else selectedCityRedes = selectedCityRedes.filter(r => r !== value);

                    cityRedeGroupFilter = 'com_rede';
                    cityRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    cityComRedeBtn.classList.add('active');

                    handleCityFilterChange({ skipFilter: 'rede' });
                }
            });

            clearCityFiltersBtn.addEventListener('click', () => { resetCityFilters(); markDirty('cidades'); });
            const debouncedUpdateCity = debounce(updateCity, 400);
            cityCodCliFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                debouncedUpdateCity();
            });

            cityNameFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[0-9]/g, '');
                const { clients } = getCityFilteredData({ excludeFilter: 'city' });
                updateCitySuggestions(cityNameFilter, citySuggestions, clients);
            });
            cityNameFilter.addEventListener('focus', () => {
                const { clients } = getCityFilteredData({ excludeFilter: 'city' });
                citySuggestions.classList.remove('manual-hide');
                updateCitySuggestions(cityNameFilter, citySuggestions, clients);
            });
            cityNameFilter.addEventListener('blur', () => setTimeout(() => citySuggestions.classList.add('hidden'), 150));
            cityNameFilter.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    citySuggestions.classList.add('hidden', 'manual-hide');
                    handleCityFilterChange();
                    e.target.blur();
                }
            });

            document.addEventListener('click', (e) => {
                if (!supervisorFilterBtn.contains(e.target) && !supervisorFilterDropdown.contains(e.target)) supervisorFilterDropdown.classList.add('hidden');
                if (!fornecedorFilterBtn.contains(e.target) && !fornecedorFilterDropdown.contains(e.target)) fornecedorFilterDropdown.classList.add('hidden');
                if (!vendedorFilterBtn.contains(e.target) && !vendedorFilterDropdown.contains(e.target)) vendedorFilterDropdown.classList.add('hidden');
                if (!tipoVendaFilterBtn.contains(e.target) && !tipoVendaFilterDropdown.contains(e.target)) tipoVendaFilterDropdown.classList.add('hidden');

                if (!citySupervisorFilterBtn.contains(e.target) && !citySupervisorFilterDropdown.contains(e.target)) citySupervisorFilterDropdown.classList.add('hidden');
                if (!cityVendedorFilterBtn.contains(e.target) && !cityVendedorFilterDropdown.contains(e.target)) cityVendedorFilterDropdown.classList.add('hidden');
                if (!cityTipoVendaFilterBtn.contains(e.target) && !cityTipoVendaFilterDropdown.contains(e.target)) cityTipoVendaFilterDropdown.classList.add('hidden');
                if (!cityComRedeBtn.contains(e.target) && !cityRedeFilterDropdown.contains(e.target)) cityRedeFilterDropdown.classList.add('hidden');
                if (!mainComRedeBtn.contains(e.target) && !mainRedeFilterDropdown.contains(e.target)) mainRedeFilterDropdown.classList.add('hidden');

                if (!comparisonSupervisorFilterBtn.contains(e.target) && !comparisonSupervisorFilterDropdown.contains(e.target)) comparisonSupervisorFilterDropdown.classList.add('hidden');
                if (!comparisonComRedeBtn.contains(e.target) && !comparisonRedeFilterDropdown.contains(e.target)) comparisonRedeFilterDropdown.classList.add('hidden');
                if (!comparisonVendedorFilterBtn.contains(e.target) && !comparisonVendedorFilterDropdown.contains(e.target)) comparisonVendedorFilterDropdown.classList.add('hidden');
                if (!comparisonTipoVendaFilterBtn.contains(e.target) && !comparisonTipoVendaFilterDropdown.contains(e.target)) comparisonTipoVendaFilterDropdown.classList.add('hidden');
                if (!comparisonSupplierFilterBtn.contains(e.target) && !comparisonSupplierFilterDropdown.contains(e.target)) comparisonSupplierFilterDropdown.classList.add('hidden');
                if (!comparisonProductFilterBtn.contains(e.target) && !comparisonProductFilterDropdown.contains(e.target)) comparisonProductFilterDropdown.classList.add('hidden');

                if (!stockSupervisorFilterBtn.contains(e.target) && !stockSupervisorFilterDropdown.contains(e.target)) stockSupervisorFilterDropdown.classList.add('hidden');
                if (!stockComRedeBtn.contains(e.target) && !stockRedeFilterDropdown.contains(e.target)) stockRedeFilterDropdown.classList.add('hidden');
                if (!stockVendedorFilterBtn.contains(e.target) && !stockVendedorFilterDropdown.contains(e.target)) stockVendedorFilterDropdown.classList.add('hidden');
                if (!stockSupplierFilterBtn.contains(e.target) && !stockSupplierFilterDropdown.contains(e.target)) stockSupplierFilterDropdown.classList.add('hidden');
                if (!stockProductFilterBtn.contains(e.target) && !stockProductFilterDropdown.contains(e.target)) stockProductFilterDropdown.classList.add('hidden');
                if (!stockTipoVendaFilterBtn.contains(e.target) && !stockTipoVendaFilterDropdown.contains(e.target)) stockTipoVendaFilterDropdown.classList.add('hidden');

                if (!innovationsMonthSupervisorFilterBtn.contains(e.target) && !innovationsMonthSupervisorFilterDropdown.contains(e.target)) innovationsMonthSupervisorFilterDropdown.classList.add('hidden');
                if (!coverageSupervisorFilterBtn.contains(e.target) && !coverageSupervisorFilterDropdown.contains(e.target)) coverageSupervisorFilterDropdown.classList.add('hidden');

                if (e.target.closest('[data-pedido-id]')) { e.preventDefault(); openModal(e.target.closest('[data-pedido-id]').dataset.pedidoId); }
                if (e.target.closest('[data-codcli]')) { e.preventDefault(); openClientModal(e.target.closest('[data-codcli]').dataset.codcli); }
                if (e.target.closest('#city-suggestions > div')) { cityNameFilter.value = e.target.textContent; citySuggestions.classList.add('hidden'); updateCityView(); }
                if (e.target.closest('#comparison-city-suggestions > div')) { comparisonCityFilter.value = e.target.textContent; comparisonCitySuggestions.classList.add('hidden'); updateAllComparisonFilters(); updateComparisonView(); }
                else if (!comparisonCityFilter.contains(e.target)) comparisonCitySuggestions.classList.add('hidden');
                if (e.target.closest('#stock-city-suggestions > div')) { stockCityFilter.value = e.target.textContent; stockCitySuggestions.classList.add('hidden'); handleStockFilterChange(); }
                else if (!stockCityFilter.contains(e.target)) stockCitySuggestions.classList.add('hidden');
            });

            fornecedorToggleContainerEl.querySelectorAll('.fornecedor-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const fornecedor = btn.dataset.fornecedor;
                    if (currentFornecedor === fornecedor) { currentFornecedor = ''; btn.classList.remove('active'); } else { currentFornecedor = fornecedor; fornecedorToggleContainerEl.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); }

                    let supplierDataSource = [...allSalesData, ...allHistoryData];
                    if (currentFornecedor) {
                        supplierDataSource = supplierDataSource.filter(s => s.OBSERVACAOFOR === currentFornecedor);
                    }
                    selectedMainSuppliers = updateSupplierFilter(document.getElementById('fornecedor-filter-dropdown'), document.getElementById('fornecedor-filter-text'), selectedMainSuppliers, supplierDataSource, 'main');

                    selectedMainSupervisors = updateSupervisorFilter(document.getElementById('supervisor-filter-dropdown'), document.getElementById('supervisor-filter-text'), selectedMainSupervisors, allSalesData);
                    selectedSellers = [];
                    updateSellerFilter(selectedMainSupervisors, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData);
                    mainTableState.currentPage = 1;
                    updateDashboard();
                });
            });

            const updateWeekly = () => {
                markDirty('semanal');
                updateWeeklyView();
            };

            weeklyFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const fornecedor = btn.dataset.fornecedor;
                    if (currentWeeklyFornecedor === fornecedor) { currentWeeklyFornecedor = ''; btn.classList.remove('active'); } else { currentWeeklyFornecedor = fornecedor; weeklyFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); }
                    updateWeekly();
                });
            });
            weeklySupervisorFilter.addEventListener('change', updateWeekly);
            clearWeeklyFiltersBtn.addEventListener('click', () => { resetWeeklyFilters(); markDirty('semanal'); });

            // --- Comparison View Filters ---
            const updateComparison = () => {
                markDirty('comparativo');
                updateAllComparisonFilters();
                updateComparisonView();
            };

            const handleComparisonFilterChange = updateComparison;

            const comparisonSupervisorFilterBtn = document.getElementById('comparison-supervisor-filter-btn');
            const comparisonSupervisorFilterDropdown = document.getElementById('comparison-supervisor-filter-dropdown');
            comparisonSupervisorFilterBtn.addEventListener('click', () => comparisonSupervisorFilterDropdown.classList.toggle('hidden'));
            comparisonSupervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedComparisonSupervisors.push(value);
                    else selectedComparisonSupervisors = selectedComparisonSupervisors.filter(s => s !== value);
                    selectedComparisonSellers = [];
                    handleComparisonFilterChange();
                }
            });

            comparisonFilialFilter.addEventListener('change', handleComparisonFilterChange);
            comparisonVendedorFilterBtn.addEventListener('click', () => comparisonVendedorFilterDropdown.classList.toggle('hidden'));
            comparisonVendedorFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) selectedComparisonSellers.push(value); else selectedComparisonSellers = selectedComparisonSellers.filter(s => s !== value); handleComparisonFilterChange(); } });
            comparisonTipoVendaFilterBtn.addEventListener('click', () => comparisonTipoVendaFilterDropdown.classList.toggle('hidden'));
            comparisonTipoVendaFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedComparisonTiposVenda.includes(value)) selectedComparisonTiposVenda.push(value);
                    } else {
                        selectedComparisonTiposVenda = selectedComparisonTiposVenda.filter(s => s !== value);
                    }
                    selectedComparisonTiposVenda = updateTipoVendaFilter(comparisonTipoVendaFilterDropdown, comparisonTipoVendaFilterText, selectedComparisonTiposVenda, [...allSalesData, ...allHistoryData]);
                    handleComparisonFilterChange();
                }
            });
            comparisonFornecedorToggleContainer.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { const fornecedor = e.target.dataset.fornecedor; if (currentComparisonFornecedor === fornecedor) { currentComparisonFornecedor = ''; e.target.classList.remove('active'); } else { currentComparisonFornecedor = fornecedor; comparisonFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); } handleComparisonFilterChange(); } });
            comparisonSupplierFilterBtn.addEventListener('click', () => comparisonSupplierFilterDropdown.classList.toggle('hidden'));
            comparisonSupplierFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox' && e.target.dataset.filterType === 'comparison') { const { value, checked } = e.target; if (checked) selectedComparisonSuppliers.push(value); else selectedComparisonSuppliers = selectedComparisonSuppliers.filter(s => s !== value); handleComparisonFilterChange(); } });

            comparisonComRedeBtn.addEventListener('click', () => comparisonRedeFilterDropdown.classList.toggle('hidden'));
            comparisonRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    comparisonRedeGroupFilter = button.dataset.group;
                    comparisonRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    if (comparisonRedeGroupFilter !== 'com_rede') {
                        comparisonRedeFilterDropdown.classList.add('hidden');
                        selectedComparisonRedes = [];
                    }
                    updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);
                    handleComparisonFilterChange();
                }
            });
            comparisonRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedComparisonRedes.push(value);
                    else selectedComparisonRedes = selectedComparisonRedes.filter(r => r !== value);

                    comparisonRedeGroupFilter = 'com_rede';
                    comparisonRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    comparisonComRedeBtn.classList.add('active');

                    selectedComparisonRedes = updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);
                    handleComparisonFilterChange();
                }
            });

            comparisonCityFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[0-9]/g, '');
                const { currentSales, historySales } = getComparisonFilteredData({ excludeFilter: 'city' });
                comparisonCitySuggestions.classList.remove('manual-hide');
                updateComparisonCitySuggestions([...currentSales, ...historySales]);
            });
            comparisonCityFilter.addEventListener('focus', () => {
                const { currentSales, historySales } = getComparisonFilteredData({ excludeFilter: 'city' });
                comparisonCitySuggestions.classList.remove('manual-hide');
                updateComparisonCitySuggestions([...currentSales, ...historySales]);
            });
            comparisonCityFilter.addEventListener('blur', () => setTimeout(() => comparisonCitySuggestions.classList.add('hidden'), 150));
            comparisonCityFilter.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    comparisonCitySuggestions.classList.add('hidden', 'manual-hide');
                    handleComparisonFilterChange();
                    e.target.blur();
                }
            });
            comparisonCitySuggestions.addEventListener('click', (e) => {
                if (e.target.tagName === 'DIV') {
                    comparisonCityFilter.value = e.target.textContent;
                    comparisonCitySuggestions.classList.add('hidden');
                    handleComparisonFilterChange();
                }
            });

            clearComparisonFiltersBtn.addEventListener('click', resetComparisonFilters);

            const handleProductFilterChange = (e, selectedArray) => {
                 if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedArray.includes(value)) selectedArray.push(value);
                    } else {
                        const index = selectedArray.indexOf(value);
                        if (index > -1) selectedArray.splice(index, 1);
                    }
                    return true;
                }
                return false;
            }

            comparisonProductFilterBtn.addEventListener('click', () => {
                updateComparisonProductFilter();
                comparisonProductFilterDropdown.classList.toggle('hidden');
            });

            const debouncedComparisonProductSearch = debounce(updateComparisonProductFilter, 250);
            comparisonProductFilterDropdown.addEventListener('input', (e) => {
                if (e.target.id === 'comparison-product-search-input') {
                    debouncedComparisonProductSearch();
                }
            });
            comparisonProductFilterDropdown.addEventListener('change', (e) => {
                if(e.target.dataset.filterType === 'comparison' && handleProductFilterChange(e, selectedComparisonProducts)) {
                    handleComparisonFilterChange();
                    updateComparisonProductFilter();
                }
            });
            stockProductFilterBtn.addEventListener('click', () => {
                updateStockProductFilter();
                stockProductFilterDropdown.classList.toggle('hidden');
            });

            const debouncedStockProductSearch = debounce(updateStockProductFilter, 250);
            stockProductFilterDropdown.addEventListener('input', (e) => {
                if (e.target.id === 'stock-product-search-input') {
                    debouncedStockProductSearch();
                }
            });

            stockProductFilterDropdown.addEventListener('change', (e) => {
                if(e.target.dataset.filterType === 'stock' && handleProductFilterChange(e, selectedStockProducts)) {
                    handleStockFilterChange();
                    updateStockProductFilter();
                }
            });

            stockFilialFilter.addEventListener('change', handleStockFilterChange);
            clearStockFiltersBtn.addEventListener('click', resetStockFilters);
            stockFornecedorToggleContainer.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { const fornecedor = e.target.dataset.fornecedor; if (currentStockFornecedor === fornecedor) { currentStockFornecedor = ''; e.target.classList.remove('active'); } else { currentStockFornecedor = fornecedor; stockFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); } handleStockFilterChange(); } });

            const stockSupervisorFilterBtn = document.getElementById('stock-supervisor-filter-btn');
            const stockSupervisorFilterDropdown = document.getElementById('stock-supervisor-filter-dropdown');
            stockSupervisorFilterBtn.addEventListener('click', () => stockSupervisorFilterDropdown.classList.toggle('hidden'));
            stockSupervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedStockSupervisors.push(value);
                    else selectedStockSupervisors = selectedStockSupervisors.filter(s => s !== value);

                    selectedStockSellers = [];
                    handleStockFilterChange();
                }
            });

            stockVendedorFilterBtn.addEventListener('click', () => stockVendedorFilterDropdown.classList.toggle('hidden'));
            stockVendedorFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) selectedStockSellers.push(value); else selectedStockSellers = selectedStockSellers.filter(s => s !== value); handleStockFilterChange({ skipFilter: 'seller' }); } });
            stockSupplierFilterBtn.addEventListener('click', () => stockSupplierFilterDropdown.classList.toggle('hidden'));
            stockSupplierFilterDropdown.addEventListener('change', (e) => { if (e.target.dataset.filterType === 'stock' && e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) { if(!selectedStockSuppliers.includes(value)) selectedStockSuppliers.push(value); } else { selectedStockSuppliers = selectedStockSuppliers.filter(s => s !== value); } handleStockFilterChange({ skipFilter: 'supplier' }); } });

            stockTipoVendaFilterBtn.addEventListener('click', () => stockTipoVendaFilterDropdown.classList.toggle('hidden'));
            stockTipoVendaFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedStockTiposVenda.includes(value)) selectedStockTiposVenda.push(value);
                    } else {
                        selectedStockTiposVenda = selectedStockTiposVenda.filter(s => s !== value);
                    }
                    selectedStockTiposVenda = updateTipoVendaFilter(stockTipoVendaFilterDropdown, stockTipoVendaFilterText, selectedStockTiposVenda, [...allSalesData, ...allHistoryData]);
                    handleStockFilterChange({ skipFilter: 'tipoVenda' });
                }
            });

            stockCityFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[0-9]/g, '');
                const cityData = getStockFilteredData({ excludeFilter: 'city' });
                stockCitySuggestions.classList.remove('manual-hide');
                updateStockCitySuggestions([...cityData.sales, ...cityData.history]);
            });
            stockCityFilter.addEventListener('focus', () => {
                const cityData = getStockFilteredData({ excludeFilter: 'city' });
                stockCitySuggestions.classList.remove('manual-hide');
                updateStockCitySuggestions([...cityData.sales, ...cityData.history]);
            });
            stockCityFilter.addEventListener('blur', () => setTimeout(() => stockCitySuggestions.classList.add('hidden'), 150));
            stockCityFilter.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    stockCitySuggestions.classList.add('hidden', 'manual-hide');
                    handleStockFilterChange();
                    e.target.blur();
                }
            });
            stockCitySuggestions.addEventListener('click', (e) => {
                if (e.target.tagName === 'DIV') {
                    stockCityFilter.value = e.target.textContent;
                    stockCitySuggestions.classList.add('hidden');
                    handleStockFilterChange();
                }
            });

            stockComRedeBtn.addEventListener('click', () => stockRedeFilterDropdown.classList.toggle('hidden'));
            stockRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    stockRedeGroupFilter = button.dataset.group;
                    stockRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    if (stockRedeGroupFilter !== 'com_rede') {
                        stockRedeFilterDropdown.classList.add('hidden');
                        selectedStockRedes = [];
                    }
                    updateRedeFilter(stockRedeFilterDropdown, stockComRedeBtnText, selectedStockRedes, allClientsData, 'Com Rede');
                    handleStockFilterChange();
                }
            });
            stockRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedStockRedes.push(value);
                    else selectedStockRedes = selectedStockRedes.filter(r => r !== value);
                    selectedStockRedes = updateRedeFilter(stockRedeFilterDropdown, stockComRedeBtnText, selectedStockRedes, allClientsData, 'Com Rede');
                    handleStockFilterChange();
                }
            });


            comparisonTendencyToggle.addEventListener('click', () => {
                useTendencyComparison = !useTendencyComparison;
                comparisonTendencyToggle.textContent = useTendencyComparison ? 'Ver Dados Reais' : 'Calcular Tendência';
                comparisonTendencyToggle.classList.toggle('bg-orange-600');
                comparisonTendencyToggle.classList.toggle('hover:bg-orange-500');
                comparisonTendencyToggle.classList.toggle('bg-purple-600');
                comparisonTendencyToggle.classList.toggle('hover:bg-purple-500');
                updateComparison();
            });

            toggleWeeklyBtn.addEventListener('click', () => {
                comparisonChartType = 'weekly';
                toggleWeeklyBtn.classList.add('active');
                toggleMonthlyBtn.classList.remove('active');
                document.getElementById('comparison-monthly-metric-container').classList.add('hidden');
                updateComparison();
            });

            toggleMonthlyBtn.addEventListener('click', () => {
                comparisonChartType = 'monthly';
                toggleMonthlyBtn.classList.add('active');
                toggleWeeklyBtn.classList.remove('active');
                // The toggle visibility is handled inside updateComparisonView based on mode
                updateComparison();
            });

            // New Metric Toggle Listeners
            const toggleMonthlyFatBtn = document.getElementById('toggle-monthly-fat-btn');
            const toggleMonthlyClientsBtn = document.getElementById('toggle-monthly-clients-btn');

            if (toggleMonthlyFatBtn && toggleMonthlyClientsBtn) {
                toggleMonthlyFatBtn.addEventListener('click', () => {
                    comparisonMonthlyMetric = 'faturamento';
                    toggleMonthlyFatBtn.classList.add('active');
                    toggleMonthlyClientsBtn.classList.remove('active');
                    updateComparison();
                });

                toggleMonthlyClientsBtn.addEventListener('click', () => {
                    comparisonMonthlyMetric = 'clientes';
                    toggleMonthlyClientsBtn.classList.add('active');
                    toggleMonthlyFatBtn.classList.remove('active');
                    updateComparison();
                });
            }

            mainHolidayPickerBtn.addEventListener('click', () => {
                renderCalendar(calendarState.year, calendarState.month);
                holidayModal.classList.remove('hidden');
            });
            comparisonHolidayPickerBtn.addEventListener('click', () => {
                renderCalendar(calendarState.year, calendarState.month);
                holidayModal.classList.remove('hidden');
            });
            holidayModalCloseBtn.addEventListener('click', () => holidayModal.classList.add('hidden'));
            holidayModalDoneBtn.addEventListener('click', () => {
                holidayModal.classList.add('hidden');
                const holidayBtnText = selectedHolidays.length > 0 ? `${selectedHolidays.length} feriado(s)` : 'Selecionar Feriados';
                comparisonHolidayPickerBtn.textContent = holidayBtnText;
                mainHolidayPickerBtn.textContent = holidayBtnText;
                updateComparison();
                updateDashboard();
            });
            calendarContainer.addEventListener('click', (e) => {
                if (e.target.id === 'prev-month-btn') {
                    calendarState.month--;
                    if (calendarState.month < 0) {
                        calendarState.month = 11;
                        calendarState.year--;
                    }
                    renderCalendar(calendarState.year, calendarState.month);
                } else if (e.target.id === 'next-month-btn') {
                    calendarState.month++;
                    if (calendarState.month > 11) {
                        calendarState.month = 0;
                        calendarState.year++;
                    }
                    renderCalendar(calendarState.year, calendarState.month);
                } else if (e.target.dataset.date) {
                    const dateString = e.target.dataset.date;
                    const index = selectedHolidays.indexOf(dateString);
                    if (index > -1) {
                        selectedHolidays.splice(index, 1);
                    } else {
                        selectedHolidays.push(dateString);
                    }
                    renderCalendar(calendarState.year, calendarState.month);
                }
            });


            document.getElementById('export-active-pdf-btn').addEventListener('click', () => exportClientsPDF(activeClientsForExport, 'Relatório de Clientes Ativos no Mês', 'clientes_ativos', true));
            document.getElementById('export-inactive-pdf-btn').addEventListener('click', () => exportClientsPDF(inactiveClientsForExport, 'Relatório de Clientes Sem Vendas no Mês', 'clientes_sem_vendas', false));
            modalCloseBtn.addEventListener('click', () => modal.classList.add('hidden'));
            clientModalCloseBtn.addEventListener('click', () => clientModal.classList.add('hidden'));
            faturamentoBtn.addEventListener('click', () => { currentProductMetric = 'faturamento'; faturamentoBtn.classList.add('active'); pesoBtn.classList.remove('active'); updateDashboard(); });
            pesoBtn.addEventListener('click', () => { currentProductMetric = 'peso'; pesoBtn.classList.add('active'); faturamentoBtn.classList.remove('active'); updateDashboard(); });

            // --- Innovations View Filters ---
            const updateInnovations = () => {
                markDirty('inovacoes');
                updateInnovationsMonthView();
            };

            innovationsMonthCategoryFilter.addEventListener('change', updateInnovations);

            const debouncedUpdateInnovationsMonth = debounce(updateInnovations, 400);

            const innovationsMonthSupervisorFilterBtn = document.getElementById('innovations-month-supervisor-filter-btn');
            const innovationsMonthSupervisorFilterDropdown = document.getElementById('innovations-month-supervisor-filter-dropdown');
            innovationsMonthSupervisorFilterBtn.addEventListener('click', () => innovationsMonthSupervisorFilterDropdown.classList.toggle('hidden'));
            innovationsMonthSupervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedInnovationsSupervisors.push(value);
                    else selectedInnovationsSupervisors = selectedInnovationsSupervisors.filter(s => s !== value);

                    selectedInnovationsSupervisors = updateSupervisorFilter(innovationsMonthSupervisorFilterDropdown, document.getElementById('innovations-month-supervisor-filter-text'), selectedInnovationsSupervisors, allSalesData, true);

                    selectedInnovationsMonthSellers = [];
                    updateSellerFilter(selectedInnovationsSupervisors, innovationsMonthVendedorFilterDropdown, innovationsMonthVendedorFilterText, selectedInnovationsMonthSellers, allSalesData);
                    debouncedUpdateInnovationsMonth();
                }
            });

            innovationsMonthVendedorFilterBtn.addEventListener('click', () => innovationsMonthVendedorFilterDropdown.classList.toggle('hidden'));
            innovationsMonthVendedorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedInnovationsMonthSellers.includes(value)) selectedInnovationsMonthSellers.push(value);
                    } else {
                        selectedInnovationsMonthSellers = selectedInnovationsMonthSellers.filter(s => s !== value);
                    }
                    updateSellerFilter(selectedInnovationsSupervisors, innovationsMonthVendedorFilterDropdown, innovationsMonthVendedorFilterText, selectedInnovationsMonthSellers, allSalesData);
                    debouncedUpdateInnovationsMonth();
                }
            });

            innovationsMonthCityFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[0-9]/g, '');
                const cityDataSource = getInnovationsMonthFilteredData({ excludeFilter: 'city' }).clients;
                innovationsMonthCitySuggestions.classList.remove('manual-hide');
                updateCitySuggestions(innovationsMonthCityFilter, innovationsMonthCitySuggestions, cityDataSource);
            });
            innovationsMonthCityFilter.addEventListener('focus', () => {
                const cityDataSource = getInnovationsMonthFilteredData({ excludeFilter: 'city' }).clients;
                innovationsMonthCitySuggestions.classList.remove('manual-hide');
                updateCitySuggestions(innovationsMonthCityFilter, innovationsMonthCitySuggestions, cityDataSource);
            });
            innovationsMonthCityFilter.addEventListener('blur', () => setTimeout(() => innovationsMonthCitySuggestions.classList.add('hidden'), 150));
            innovationsMonthCityFilter.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    innovationsMonthCitySuggestions.classList.add('hidden', 'manual-hide');
                    debouncedUpdateInnovationsMonth();
                    e.target.blur();
                }
            });
            innovationsMonthCitySuggestions.addEventListener('click', (e) => {
                if (e.target.tagName === 'DIV') {
                    innovationsMonthCityFilter.value = e.target.textContent;
                    innovationsMonthCitySuggestions.classList.add('hidden');
                    debouncedUpdateInnovationsMonth();
                }
            });

            innovationsMonthFilialFilter.addEventListener('change', debouncedUpdateInnovationsMonth);
            clearInnovationsMonthFiltersBtn.addEventListener('click', () => { resetInnovationsMonthFilters(); markDirty('inovacoes'); });
            exportInnovationsMonthPdfBtn.addEventListener('click', exportInnovationsMonthPDF);

            innovationsMonthTipoVendaFilterBtn.addEventListener('click', () => innovationsMonthTipoVendaFilterDropdown.classList.toggle('hidden'));
            innovationsMonthTipoVendaFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedInnovationsMonthTiposVenda.includes(value)) selectedInnovationsMonthTiposVenda.push(value);
                    } else {
                        selectedInnovationsMonthTiposVenda = selectedInnovationsMonthTiposVenda.filter(s => s !== value);
                    }
                    selectedInnovationsMonthTiposVenda = updateTipoVendaFilter(innovationsMonthTipoVendaFilterDropdown, innovationsMonthTipoVendaFilterText, selectedInnovationsMonthTiposVenda, [...allSalesData, ...allHistoryData]);
                    debouncedUpdateInnovationsMonth();
                }
            });


            document.getElementById('export-coverage-pdf-btn').addEventListener('click', exportCoveragePDF);

            const coverageChartToggleBtn = document.getElementById('coverage-chart-toggle-btn');
            if (coverageChartToggleBtn) {
                coverageChartToggleBtn.addEventListener('click', () => {
                    currentCoverageChartMode = currentCoverageChartMode === 'city' ? 'seller' : 'city';
                    updateCoverageView();
                });
            }

            // --- Mix View Event Listeners ---
            // --- Goals View Event Listeners ---
            const updateGoals = () => {
                markDirty('goals');
                handleGoalsFilterChange();
            };

            document.addEventListener('goalsCleared', () => {
                updateGoals();
            });

            const debouncedUpdateGoals = debounce(updateGoals, 400);

            async function loadGoalsFromSupabase() {
                try {
                    const monthKey = new Date().toISOString().slice(0, 7);
                    const { data, error } = await window.supabaseClient
                        .from('goals_distribution')
                        .select('goals_data')
                        .eq('month_key', monthKey)
                        .eq('supplier', 'ALL')
                        .eq('brand', 'GENERAL')
                        .maybeSingle();

                    if (error) {
                        console.error('Erro ao carregar metas:', error);
                        return;
                    }

                    if (data && data.goals_data) {
                        const gd = data.goals_data;
                        let clientsData = {};
                        let targetsData = {};

                        if (gd.clients || gd.targets) {
                            clientsData = gd.clients || {};
                            targetsData = gd.targets || {};
                        } else {
                            clientsData = gd;
                        }

                        globalClientGoals = new Map();
                        for (const [key, val] of Object.entries(clientsData)) {
                            const clientMap = new Map();
                            for (const [k, v] of Object.entries(val)) {
                                clientMap.set(k, v);
                            }
                            globalClientGoals.set(key, clientMap);
                        }

                        if (targetsData && Object.keys(targetsData).length > 0) {
                            for (const key in targetsData) {
                                goalsTargets[key] = targetsData[key];
                            }
                        }

                        console.log('Metas carregadas do Supabase.');
                        updateGoals();
                    }
                } catch (err) {
                    console.error('Exceção ao carregar metas:', err);
                }
            }

            // Trigger Load
            loadGoalsFromSupabase();

            // Sub-tabs Switching
            const goalsSubTabsContainer = document.getElementById('goals-sub-tabs-container');
            if (goalsSubTabsContainer) {
                goalsSubTabsContainer.addEventListener('click', (e) => {
                    const btn = e.target.closest('.goals-sub-tab');
                    if (!btn) return;

                    // Ensure metrics are ready
                    if (Object.keys(globalGoalsMetrics).length === 0) {
                        calculateGoalsMetrics();
                    }

                    // Remove active styles from ALL sub-tabs across both groups
                    document.querySelectorAll('.goals-sub-tab').forEach(b => {
                        b.classList.remove('active', 'text-teal-400', 'font-bold', 'border-b-2', 'border-teal-400');
                        b.classList.add('text-slate-400', 'font-medium');
                        const indicator = b.querySelector('.indicator');
                        if (indicator) indicator.remove();
                    });

                    btn.classList.remove('text-slate-400', 'font-medium');
                    btn.classList.add('active', 'text-teal-400', 'font-bold', 'border-b-2', 'border-teal-400');

                    const indicator = document.createElement('span');
                    indicator.className = 'w-2 h-2 rounded-full bg-teal-400 inline-block indicator mr-2';
                    btn.prepend(indicator);

                    currentGoalsSupplier = btn.dataset.supplier;
                    currentGoalsBrand = btn.dataset.brand || null;

                    const cacheKey = currentGoalsSupplier + (currentGoalsBrand ? `_${currentGoalsBrand}` : '');

                    // --- Update Metrics Display and Pre-fill Inputs ---
                    const metrics = globalGoalsMetrics[cacheKey];

                    if (!goalsTargets[cacheKey]) {
                        goalsTargets[cacheKey] = { fat: 0, vol: 0 };
                    }
                    const target = goalsTargets[cacheKey];

                    if (metrics) {
                        // PRE-FILL logic: If target is 0 (uninitialized), use Previous Month values as default suggestion
                        if (target.fat === 0) target.fat = metrics.prevFat;
                        if (target.vol === 0) target.vol = metrics.prevVol;
                    }

                    // Update Input Fields
                    const fatInput = document.getElementById('goal-global-fat');
                    const volInput = document.getElementById('goal-global-vol');

                    if (fatInput) fatInput.value = target.fat.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                    if (volInput) volInput.value = target.vol.toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });
                    // ----------------------------------------------------------

                    goalsTableState.currentPage = 1;
                    updateGoals();
                });
            }

            // Category Toggle Logic
            const btnPepsico = document.getElementById('goals-category-pepsico-btn');
            const btnElmaChips = document.getElementById('goals-category-elmachips-btn');
            const btnFoods = document.getElementById('goals-category-foods-btn');
            const btnSummary = document.getElementById('goals-category-summary-btn');
            const subTabsPepsico = document.getElementById('goals-sub-tabs-pepsico');
            const subTabsElmaChips = document.getElementById('goals-sub-tabs-elmachips');
            const subTabsFoods = document.getElementById('goals-sub-tabs-foods');

            // Containers
            const goalsMainContainer = document.getElementById('goals-input-cards');
            const goalsTableContainer = document.getElementById('goals-table-container'); // Main table wrapper
            const goalsFiltersContainer = document.querySelector('#goals-gv-content > div.mb-4'); // Filters wrapper
            const goalsSummaryContainer = document.getElementById('goals-summary-content');

            // Filter Wrappers
            const wrapperSupervisor = document.getElementById('goals-gv-supervisor-filter-wrapper');
            const wrapperSeller = document.getElementById('goals-gv-seller-filter-wrapper');
            const wrapperCodCli = document.getElementById('goals-gv-codcli-filter-wrapper');

            const toggleGoalsView = (view) => {
                // Reset Buttons
                [btnPepsico, btnElmaChips, btnFoods, btnSummary].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('bg-[#0d9488]', 'text-white', 'shadow-lg', 'border-teal-500/50');
                        btn.classList.add('bg-[#334155]', 'text-slate-400', 'border-slate-700');
                    }
                });

                // Hide All Sub-tabs
                if(subTabsPepsico) subTabsPepsico.classList.add('hidden');
                if(subTabsElmaChips) subTabsElmaChips.classList.add('hidden');
                if(subTabsFoods) subTabsFoods.classList.add('hidden');

                // Toggle Content
                if (view === 'summary') {
                    if(btnSummary) {
                        btnSummary.classList.remove('bg-[#334155]', 'text-slate-400', 'border-slate-700');
                        btnSummary.classList.add('bg-[#0d9488]', 'text-white', 'shadow-lg', 'border-teal-500/50');
                    }
                    if(goalsSummaryContainer) goalsSummaryContainer.classList.remove('hidden');
                    if(goalsMainContainer) goalsMainContainer.classList.add('hidden');
                    if(goalsTableContainer) goalsTableContainer.classList.add('hidden');

                    // HIDE Main Filters Container completely
                    if(goalsFiltersContainer) goalsFiltersContainer.classList.add('hidden');

                    // Ensure Summary Filters are initialized/visible (they are inside summary container)
                    updateGoalsSummaryView();
                } else {
                    // Show Main Content
                    if(goalsSummaryContainer) goalsSummaryContainer.classList.add('hidden');
                    if(goalsMainContainer) goalsMainContainer.classList.remove('hidden');
                    if(goalsTableContainer) goalsTableContainer.classList.remove('hidden');

                    // SHOW Main Filters Container and all wrappers
                    if(goalsFiltersContainer) goalsFiltersContainer.classList.remove('hidden');
                    if(wrapperSupervisor) wrapperSupervisor.classList.remove('hidden');
                    if(wrapperSeller) wrapperSeller.classList.remove('hidden');
                    if(wrapperCodCli) wrapperCodCli.classList.remove('hidden');

                    if (view === 'pepsico') {
                        if(btnPepsico) {
                            btnPepsico.classList.remove('bg-[#334155]', 'text-slate-400', 'border-slate-700');
                            btnPepsico.classList.add('bg-[#0d9488]', 'text-white', 'shadow-lg', 'border-teal-500/50');
                        }
                        if(subTabsPepsico) subTabsPepsico.classList.remove('hidden');
                        const firstTab = subTabsPepsico.querySelector('.goals-sub-tab');
                        if (firstTab) firstTab.click();
                    } else if (view === 'elmachips') {
                        if(btnElmaChips) {
                            btnElmaChips.classList.remove('bg-[#334155]', 'text-slate-400', 'border-slate-700');
                            btnElmaChips.classList.add('bg-[#0d9488]', 'text-white', 'shadow-lg', 'border-teal-500/50');
                        }
                        if(subTabsElmaChips) subTabsElmaChips.classList.remove('hidden');

                        // Select First Tab of Elma Chips
                        const firstTab = subTabsElmaChips.querySelector('.goals-sub-tab');
                        if (firstTab) firstTab.click();
                    } else if (view === 'foods') {
                        if(btnFoods) {
                            btnFoods.classList.remove('bg-[#334155]', 'text-slate-400', 'border-slate-700');
                            btnFoods.classList.add('bg-[#0d9488]', 'text-white', 'shadow-lg', 'border-teal-500/50');
                        }
                        if(subTabsFoods) subTabsFoods.classList.remove('hidden');

                        // Select First Tab of Foods
                        const firstTab = subTabsFoods.querySelector('.goals-sub-tab');
                        if (firstTab) firstTab.click();
                    }
                }
            };

            if (btnPepsico && btnElmaChips && btnFoods && btnSummary) {
                btnPepsico.addEventListener('click', () => toggleGoalsView('pepsico'));
                btnElmaChips.addEventListener('click', () => toggleGoalsView('elmachips'));
                btnFoods.addEventListener('click', () => toggleGoalsView('foods'));
                btnSummary.addEventListener('click', () => toggleGoalsView('summary'));
            }

            // Tab Switching
            document.getElementById('goals-tabs').addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    const tab = e.target.dataset.tab;
                    document.querySelectorAll('#goals-tabs button').forEach(btn => {
                        btn.classList.remove('border-teal-500', 'text-teal-500', 'active');
                        btn.classList.add('border-transparent', 'hover:text-slate-300', 'hover:border-slate-300', 'text-slate-400');
                    });
                    e.target.classList.remove('border-transparent', 'hover:text-slate-300', 'hover:border-slate-300', 'text-slate-400');
                    e.target.classList.add('border-teal-500', 'text-teal-500', 'active');

                    if (tab === 'gv') {
                        goalsGvContent.classList.remove('hidden');
                        goalsSvContent.classList.add('hidden');
                        updateGoals(); // Refresh GV view
                    } else if (tab === 'sv') {
                        goalsGvContent.classList.add('hidden');
                        goalsSvContent.classList.remove('hidden');
                        // Initialize SV filters if needed - Wait, updateSupervisorFilter should be called first or on load
                        // But we want to refresh data
                        updateGoalsSvView();
                    }
                }
            });

            // SV Sub-tabs Logic and Toggle Logic REMOVED (Replaced by Single Table View)

            // GV Filters
            goalsGvSupervisorFilterBtn.addEventListener('click', () => goalsGvSupervisorFilterDropdown.classList.toggle('hidden'));
            goalsGvSupervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedGoalsGvSupervisors.push(value);
                    else selectedGoalsGvSupervisors = selectedGoalsGvSupervisors.filter(s => s !== value);

                    selectedGoalsGvSupervisors = updateSupervisorFilter(goalsGvSupervisorFilterDropdown, goalsGvSupervisorFilterText, selectedGoalsGvSupervisors, allSalesData, true);

                    // Reset sellers or keep intersection?
                    // Standard: Update Seller Options based on Supervisor
                    selectedGoalsGvSellers = [];
                    selectedGoalsGvSellers = updateSellerFilter(selectedGoalsGvSupervisors, goalsGvSellerFilterDropdown, goalsGvSellerFilterText, selectedGoalsGvSellers, allSalesData);

                    updateGoals();
                }
            });

            goalsGvSellerFilterBtn.addEventListener('click', () => goalsGvSellerFilterDropdown.classList.toggle('hidden'));
            goalsGvSellerFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedGoalsGvSellers.push(value);
                    else selectedGoalsGvSellers = selectedGoalsGvSellers.filter(s => s !== value);

                    selectedGoalsGvSellers = updateSellerFilter(selectedGoalsGvSupervisors, goalsGvSellerFilterDropdown, goalsGvSellerFilterText, selectedGoalsGvSellers, allSalesData, true);

                    updateGoals();
                }
            });

            goalsGvCodcliFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                debouncedUpdateGoals();
            });

            // --- Summary View Independent Filters ---
            const goalsSummarySupervisorFilterBtn = document.getElementById('goals-summary-supervisor-filter-btn');
            const goalsSummarySupervisorFilterDropdown = document.getElementById('goals-summary-supervisor-filter-dropdown');
            const clearGoalsSummaryFiltersBtn = document.getElementById('clear-goals-summary-filters-btn');

            if (goalsSummarySupervisorFilterBtn && goalsSummarySupervisorFilterDropdown) {
                goalsSummarySupervisorFilterBtn.addEventListener('click', () => goalsSummarySupervisorFilterDropdown.classList.toggle('hidden'));

                goalsSummarySupervisorFilterDropdown.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        const { value, checked } = e.target;
                        if (checked) selectedGoalsSummarySupervisors.push(value);
                        else selectedGoalsSummarySupervisors = selectedGoalsSummarySupervisors.filter(s => s !== value);

                        updateSupervisorFilter(goalsSummarySupervisorFilterDropdown, document.getElementById('goals-summary-supervisor-filter-text'), selectedGoalsSummarySupervisors, allSalesData, true);
                        updateGoalsSummaryView();
                    }
                });
            }

            if (clearGoalsSummaryFiltersBtn) {
                clearGoalsSummaryFiltersBtn.addEventListener('click', () => {
                    selectedGoalsSummarySupervisors = [];
                    updateSupervisorFilter(goalsSummarySupervisorFilterDropdown, document.getElementById('goals-summary-supervisor-filter-text'), selectedGoalsSummarySupervisors, allSalesData, true);
                    updateGoalsSummaryView();
                });
            }

            // Close dropdowns on outside click
            document.addEventListener('click', (e) => {
                if (goalsSummarySupervisorFilterBtn && goalsSummarySupervisorFilterDropdown) {
                    if (!goalsSummarySupervisorFilterBtn.contains(e.target) && !goalsSummarySupervisorFilterDropdown.contains(e.target)) {
                        goalsSummarySupervisorFilterDropdown.classList.add('hidden');
                    }
                }
            });

            const btnDistributeFat = document.getElementById('btn-distribute-fat');
            if (btnDistributeFat) {
                btnDistributeFat.addEventListener('click', () => {
                    const filterDesc = getFilterDescription();
                    const val = document.getElementById('goal-global-fat').value;
                    showConfirmationModal(`Você deseja inserir esta meta de Faturamento (${val}) para: ${filterDesc}?`, () => {
                        distributeGoals('fat');
                    });
                });
            }

            const btnDistributeVol = document.getElementById('btn-distribute-vol');
            if (btnDistributeVol) {
                btnDistributeVol.addEventListener('click', () => {
                    const filterDesc = getFilterDescription();
                    const val = document.getElementById('goal-global-vol').value;
                    showConfirmationModal(`Você deseja inserir esta meta de Volume (${val}) para: ${filterDesc}?`, () => {
                        distributeGoals('vol');
                    });
                });
            }

            const btnDistributeMixSalty = document.getElementById('btn-distribute-mix-salty');
            if (btnDistributeMixSalty) {
                btnDistributeMixSalty.addEventListener('click', () => {
                    const sellerName = selectedGoalsGvSellers[0];
                    if (!sellerName) return;
                    const valStr = document.getElementById('goal-global-mix-salty').value;
                    showConfirmationModal(`Confirmar ajuste de Meta Mix Salty para ${valStr} (Vendedor: ${getFirstName(sellerName)})?`, () => {
                        const val = parseFloat(valStr.replace(/\./g, '').replace(',', '.')) || 0;

                        // Calculate Natural Base again to store Delta
                        // We need the natural base for THIS seller to calculate delta (Input - Natural)
                        // It's cleaner if updateGoalsView handles this logic directly in the listener,
                        // OR we store the natural base somewhere.
                        // For simplicity, let's just trigger a custom event or call a handler that has access to context.
                        // Actually, since we need "Natural" value which varies by filter context, it's safer to handle this
                        // inside updateGoalsView where metrics are available, OR make this listener smart enough.

                        // Let's use the adjustment map directly.
                        // But we don't know the natural value here easily without recalculating.
                        // Solution: The input value IS the target. We want to store the adjustment.
                        // Adjustment = Target - Natural.

                        // Let's implement a specific helper function "saveMixAdjustment" that recalculates natural base for single seller.
                        saveMixAdjustment('salty', val, sellerName);
                    });
                });
            }

            const btnDistributeMixFoods = document.getElementById('btn-distribute-mix-foods');
            if (btnDistributeMixFoods) {
                btnDistributeMixFoods.addEventListener('click', () => {
                    const sellerName = selectedGoalsGvSellers[0];
                    if (!sellerName) return;
                    const valStr = document.getElementById('goal-global-mix-foods').value;
                    showConfirmationModal(`Confirmar ajuste de Meta Mix Foods para ${valStr} (Vendedor: ${getFirstName(sellerName)})?`, () => {
                        const val = parseFloat(valStr.replace(/\./g, '').replace(',', '.')) || 0;
                        saveMixAdjustment('foods', val, sellerName);
                    });
                });
            }

            // Add Input Listeners for Real-time State Updates
            const fatInput = document.getElementById('goal-global-fat');
            const volInput = document.getElementById('goal-global-vol');

            // REMOVED: Automatic update on change/input to prevent overwriting user input before distribution.
            // Values are now read directly from the input when the "Distribute" button is clicked.

            clearGoalsGvFiltersBtn.addEventListener('click', () => { resetGoalsGvFilters(); markDirty('goals'); });

            // SV Filters
            goalsSvSupervisorFilterBtn.addEventListener('click', () => goalsSvSupervisorFilterDropdown.classList.toggle('hidden'));
            goalsSvSupervisorFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedGoalsSvSupervisors.push(value);
                    else selectedGoalsSvSupervisors = selectedGoalsSvSupervisors.filter(s => s !== value);

                    selectedGoalsSvSupervisors = updateSupervisorFilter(goalsSvSupervisorFilterDropdown, goalsSvSupervisorFilterText, selectedGoalsSvSupervisors, allSalesData, true);
                    updateGoalsSvView();
                }
            });

            document.getElementById('goals-sv-export-xlsx-btn').addEventListener('click', exportGoalsSvXLSX);

            document.addEventListener('click', (e) => {
                if (!goalsGvSupervisorFilterBtn.contains(e.target) && !goalsGvSupervisorFilterDropdown.contains(e.target)) goalsGvSupervisorFilterDropdown.classList.add('hidden');
                if (!goalsGvSellerFilterBtn.contains(e.target) && !goalsGvSellerFilterDropdown.contains(e.target)) goalsGvSellerFilterDropdown.classList.add('hidden');
                if (!goalsSvSupervisorFilterBtn.contains(e.target) && !goalsSvSupervisorFilterDropdown.contains(e.target)) goalsSvSupervisorFilterDropdown.classList.add('hidden');
            });

            document.getElementById('goals-prev-page-btn').addEventListener('click', () => {
                if (goalsTableState.currentPage > 1) {
                    goalsTableState.currentPage--;
                    updateGoalsView();
                }
            });
            document.getElementById('goals-next-page-btn').addEventListener('click', () => {
                if (goalsTableState.currentPage < goalsTableState.totalPages) {
                    goalsTableState.currentPage++;
                    updateGoalsView();
                }
            });


            const updateMix = () => {
                markDirty('mix');
                handleMixFilterChange();
            };

            document.getElementById('mix-supervisor-filter-btn').addEventListener('click', (e) => {
                document.getElementById('mix-supervisor-filter-dropdown').classList.toggle('hidden');
            });
            document.getElementById('mix-supervisor-filter-dropdown').addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMixSupervisors.push(value);
                    else selectedMixSupervisors = selectedMixSupervisors.filter(s => s !== value);
                    selectedMixSellers = [];
                    updateMix();
                }
            });

            document.getElementById('mix-vendedor-filter-btn').addEventListener('click', (e) => {
                document.getElementById('mix-vendedor-filter-dropdown').classList.toggle('hidden');
            });
            document.getElementById('mix-vendedor-filter-dropdown').addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMixSellers.push(value);
                    else selectedMixSellers = selectedMixSellers.filter(s => s !== value);
                    handleMixFilterChange({ skipFilter: 'seller' });
                    markDirty('mix');
                }
            });

            document.getElementById('mix-tipo-venda-filter-btn').addEventListener('click', (e) => {
                document.getElementById('mix-tipo-venda-filter-dropdown').classList.toggle('hidden');
            });
            document.getElementById('mix-tipo-venda-filter-dropdown').addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMixTiposVenda.push(value);
                    else selectedMixTiposVenda = selectedMixTiposVenda.filter(s => s !== value);
                    handleMixFilterChange({ skipFilter: 'tipoVenda' });
                    markDirty('mix');
                }
            });

            document.getElementById('mix-filial-filter').addEventListener('change', updateMix);

            const mixCityFilter = document.getElementById('mix-city-filter');
            const mixCitySuggestions = document.getElementById('mix-city-suggestions');

            mixCityFilter.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[0-9]/g, '');
                const { clients } = getMixFilteredData({ excludeFilter: 'city' });
                mixCitySuggestions.classList.remove('manual-hide');
                updateCitySuggestions(mixCityFilter, mixCitySuggestions, clients);
            });
            mixCityFilter.addEventListener('focus', () => {
                const { clients } = getMixFilteredData({ excludeFilter: 'city' });
                mixCitySuggestions.classList.remove('manual-hide');
                updateCitySuggestions(mixCityFilter, mixCitySuggestions, clients);
            });
            mixCityFilter.addEventListener('blur', () => setTimeout(() => mixCitySuggestions.classList.add('hidden'), 150));
            mixCityFilter.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    mixCitySuggestions.classList.add('hidden', 'manual-hide');
                    updateMix();
                    e.target.blur();
                }
            });
            mixCitySuggestions.addEventListener('click', (e) => {
                if (e.target.tagName === 'DIV') {
                    mixCityFilter.value = e.target.textContent;
                    mixCitySuggestions.classList.add('hidden');
                    updateMix();
                }
            });

            document.getElementById('mix-com-rede-btn').addEventListener('click', () => {
