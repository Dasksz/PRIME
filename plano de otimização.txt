Plano de Alteração do Código index.html (0% a 100%)
Aqui está o plano detalhado para refatorar o seu index.html.

Fase 1: A Demolição (Removendo o Carregamento Antigo)
Objetivo: Parar de carregar milhões de linhas para o navegador.

Elimine carregarDadosDoSupabase: Apague toda a função async function carregarDadosDoSupabase(supabaseClient) { ... }.

Elimine os "Chunks": Apague as funções fetchHistoryInChunks e fetchDetailedInChunks que estavam dentro dela.

Remova a Lógica Pesada do Cliente: Apague toda a função function initializeOptimizedDataStructures() { ... }.

Remova as Variáveis Globais de Dados: No início do seu <script id="report-logic-script" ...>, apague as variáveis globais que guardavam os dados brutos.

let allSalesData = embeddedData.detailed || []; (Apague)

let allHistoryData = embeddedData.history || []; (Apague)

const aggregatedOrders = embeddedData.byOrder || []; (Apague)

const allClientsData = embeddedData.clients || []; (Mantenha esta! Vamos carregá-la na inicialização).

const stockData05 = ... e stockData08 = ... (Apague)

const optimizedData = { ... }; (Apague)

Apague todas as variáveis que dependiam destes dados, como clientLastBranch, clientRamoMap, lastSaleDate, optimizedData.salesByProduct, etc.

Fase 2: A Nova Fundação (Carregando Filtros Dinamicamente)
Objetivo: Fazer o dashboard carregar, popular os filtros a partir do backend e exibir os dados iniciais.

Modifique o "Porteiro" (onAuthStateChange):

No script no final do <body>, encontre a função supabaseClient.auth.onAuthStateChange(async (event, session) => { ... });.

Dentro do if (profile && profile.status === 'aprovado') { ... }, substitua a linha:

carregarDadosDoSupabase(supabaseClient);

pela chamada da nossa nova função: initializeNewDashboard(supabaseClient);

Crie a initializeNewDashboard (O Novo Ponto de Partida):

No <script id="report-logic-script">, adicione esta nova função async. Ela será chamada em vez de carregarDadosDoSupabase.

JavaScript

// Variáveis globais para guardar os dados dos filtros
let g_allClientsData = [];
let g_supervisors = [];
let g_vendedores = [];
let g_fornecedores = [];
let g_tiposVenda = [];
let g_redes = [];
let g_productDetails = new Map(); // Vamos precisar disto
let g_innovationsCategories = []; // Para ecrã de inovações

// O novo ponto de partida, chamado pelo "porteiro"
async function initializeNewDashboard(supabaseClient) {
    const loaderText = document.getElementById('loader-text');

    try {
        loaderText.textContent = 'Carregando filtros e dados de clientes...';

        // 1. Carrega dados que SÃO pequenos e usados em todo o lado
        const [
            clientPromise, 
            prodDetailsPromise, 
            innovCategoriesPromise
        ] = await Promise.all([
            supabaseClient.from('data_clients').select('*'),
            supabaseClient.from('data_product_details').select('code, descricao, fornecedor, codfor, dtcadastro'),
            supabaseClient.from('data_innovations').select('inovacoes, codigo, produto')
        ]);

        g_allClientsData = clientPromise.data || [];
        (prodDetailsPromise.data || []).forEach(p => g_productDetails.set(p.code, p));
        g_innovationsCategories = innovCategoriesPromise.data || [];

        loaderText.textContent = 'Carregando opções de filtros...';

        // 2. Carrega as opções dos filtros usando as RPCs
        const [
            supPromise, 
            fornPromise, 
            tipoPromise, 
            redePromise
        ] = await Promise.all([
            supabaseClient.rpc('get_distinct_supervisors'),
            supabaseClient.rpc('get_distinct_fornecedores'),
            supabaseClient.rpc('get_distinct_tipos_venda'),
            supabaseClient.rpc('get_distinct_redes')
        ]);

        g_supervisors = (supPromise.data || []).map(d => d.superv);
        g_fornecedores = fornPromise.data || []; // {codfor, fornecedor}
        g_tiposVenda = (tipoPromise.data || []).map(d => d.tipovenda);
        g_redes = (redePromise.data || []).map(d => d.ramo);

        // 3. Popula os filtros em TODOS os ecrãs
        populateAllFilterDropdowns(); // Vamos criar esta função

        // 4. Carrega os dados do primeiro ecrã (Dashboard)
        loaderText.textContent = 'Carregando KPIs iniciais...';
        await updateAllDashboardVisuals(); // Vamos refatorar esta

        // 5. Mostra o dashboard
        loader.style.opacity = '0';
        setTimeout(() => loader.classList.add('hidden'), 300);
        document.getElementById('dashboard-view').classList.remove('hidden');

    } catch (error) {
        console.error('Erro fatal na inicialização:', error);
        loaderText.innerHTML = `<span class="text-red-400">Falha ao carregar dados: ${error.message}</span>`;
    }
}
Crie a populateAllFilterDropdowns:

Esta função enche todos os <select> e menus de dropdown de uma só vez.

JavaScript

function populateAllFilterDropdowns() {
    // Exemplo para Supervisores (faça para todos os ecrãs)
    const supSelects = [
        'supervisor-filter', 'orders-supervisor-filter', 'city-supervisor-filter', 
        'comparison-supervisor-filter', 'stock-supervisor-filter', 
        'innovations-supervisor-filter', 'innovations-month-supervisor-filter', 
        'coverage-supervisor-filter'
    ];
    const supOptions = '<option value="">Todos</option>' + g_supervisors.map(s => `<option value="${s}">${s}</option>`).join('');
    supSelects.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = supOptions;
    });

    // Exemplo para Fornecedores (faça para todos os ecrãs)
    const fornSelects = ['fornecedor-filter', 'orders-fornecedor-filter'];
    const fornOptions = '<option value="">Todos</option>' + g_fornecedores.map(f => `<option value="${f.codfor}">${f.codfor} - ${f.fornecedor}</option>`).join('');
    fornSelects.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = fornOptions;
    });

    // ... Repita para updateSellerFilter, updateTipoVendaFilter, updateRedeFilter
    // ... Usando g_vendedores (ainda vazio), g_tiposVenda, g_redes
    // ... A sua lógica original de updateSellerFilter precisa ser ajustada para usar a RPC get_distinct_vendedores
}
Fase 3: A Reconstrução (Onde a Mágica Acontece)
Objetivo: Fazer com que cada ecrã peça apenas os dados de que necessita, quando necessita, usando as RPCs.

Crie uma Função Auxiliar de Filtros:

Esta função lê a UI e prepara o JSON para as RPCs. É a peça mais importante.

JavaScript

function getFiltersForRPC(viewId = 'dashboard-view') {
    let prefix = '';
    let pastaVar = window.currentFornecedor;
    let sellersVar = window.selectedSellers;
    let redesVar = window.selectedMainRedes;
    let redeGroupVar = window.mainRedeGroupFilter;

    // Mapeia o ID do ecrã para os prefixos e variáveis corretos
    if (viewId === 'orders-view') {
        prefix = 'orders-';
        pastaVar = window.currentOrdersFornecedor;
        sellersVar = window.selectedOrdersSellers;
        redesVar = window.selectedOrdersRedes;
        redeGroupVar = window.ordersRedeGroupFilter;
    } else if (viewId === 'city-view') {
        prefix = 'city-';
        pastaVar = null; // city-view não tem filtro de pasta
        sellersVar = window.selectedCitySellers;
        redesVar = window.selectedCityRedes;
        redeGroupVar = window.cityRedeGroupFilter;
    }
    // ... Adicione 'else if' para 'comparison-view', 'stock-view', etc.

    // Lê os valores dos elementos da UI
    const supervisor = document.getElementById(prefix + 'supervisor-filter')?.value || null;
    const codcli = document.getElementById(prefix + 'codcli-filter')?.value || null;
    const posicao = document.getElementById(prefix + 'posicao-filter')?.value || null;
    const codfor = document.getElementById(prefix + 'fornecedor-filter')?.value || null;
    const cidade = document.getElementById(prefix + 'city-filter')?.value || null;
    const filial = document.getElementById(prefix + 'filial-filter')?.value || 'ambas';

    const tiposVenda = window['selected' + (prefix || 'Main') + 'TiposVenda'] || null;

    return {
        p_pasta: pastaVar,
        p_supervisor: supervisor,
        p_vendedor_nomes: (sellersVar && sellersVar.length > 0) ? sellersVar : null,
        p_codcli: codcli,
        p_posicao: posicao,
        p_codfor: codfor,
        p_tipos_venda: (tiposVenda && tiposVenda.length > 0) ? tiposVenda : null,
        p_rede_group: redeGroupVar || null,
        p_redes: (redesVar && redesVar.length > 0) ? redesVar : null,
        p_cidade: cidade,
        p_filial: filial
    };
}
Refatore updateDashboardViewVisuals (Ecrã Principal):

Transforme-a numa função async.

Substitua toda a lógica de getFilteredData e calculateSummaryFromData.

JavaScript

async function updateDashboardViewVisuals() {
    // 1. Obter filtros
    const filters = getFiltersForRPC('dashboard-view');

    // 2. Chamar RPCs em paralelo
    const [
        kpiPromise,
        salesPersonPromise,
        categoryPromise,
        topProductsPromise
    ] = [
        supabaseClient.rpc('get_main_kpis', filters),
        supabaseClient.rpc('get_sales_by_group', { ...filters, p_group_by: filters.p_supervisor ? 'vendedor' : 'supervisor' }),
        supabaseClient.rpc('get_sales_by_group', { ...filters, p_group_by: 'categoria' }),
        supabaseClient.rpc('get_top_products', { ...filters, p_metric: currentProductMetric })
    ];

    // 3. Aguardar e processar KPIs
    const { data: kpiData, error: kpiError } = await kpiPromise;
    if (kpiError) { console.error('KPI Error:', kpiError); return; }

    const kpis = kpiData[0];
    const baseClientes = kpis.base_clientes_filtro;
    const pdvsPositivados = kpis.total_pdvs_positivados;
    const percPositivacao = baseClientes > 0 ? (pdvsPositivados / baseClientes) * 100 : 0;

    totalVendasEl.textContent = kpis.total_faturamento.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
    totalPesoEl.textContent = (kpis.total_peso / 1000).toLocaleString('pt-BR', { ... });
    kpiSkuPdVEl.textContent = (pdvsPositivados > 0 ? kpis.total_skus / pdvsPositivados : 0).toLocaleString('pt-BR', { ... });
    kpiPositivacaoEl.textContent = `${percPositivacao.toFixed(1)}%`;
    kpiPositivacaoPercentEl.textContent = `${pdvsPositivados.toLocaleString('pt-BR')} PDVs`;

    // 4. Aguardar e processar Gráficos
    const { data: salesPersonData } = await salesPersonPromise;
    createChart('salesByPersonChart', 'bar', salesPersonData.map(d => getFirstName(d.group_name)), salesPersonData.map(d => d.total_faturamento), ...);

    const { data: categoryData } = await categoryPromise;
    createChart('faturamentoPorFornecedorChart', 'bar', categoryData.map(d => d.group_name), categoryData.map(d => d.total_faturamento), ...);

    const { data: topProductsData } = await topProductsPromise;
    createChart('salesByProductBarChart', 'bar', 
        topProductsData.map(p => `(${p.codigo_produto}) ${p.descricao_produto}`), 
        topProductsData.map(p => p.valor_metrica), ...);

    // 5. Tendência (requer RPC do ecrã 'comparison')
    // Por agora, pode desativar ou chamar a RPC 'get_comparison_data'
    const { data: trendData } = await supabaseClient.rpc('get_comparison_data', filters);
    const currentSales = trendData.filter(d => d.origem === 'current');
    const historySales = trendData.filter(d => d.origem === 'history');
    // Agora a sua função 'updateTrendChart' original vai funcionar,
    // mas com MUITO menos dados.
    updateTrendChart(currentSales, historySales);
}
Refatore updateOrdersViewVisuals (Ecrã de Pedidos):

Esta função agora lida com a paginação no servidor.

JavaScript

async function updateOrdersViewVisuals() {
    // 1. Obter filtros
    const filters = getFiltersForRPC('orders-view');

    // 2. Chamar RPCs de KPIs e Contagem
    const kpiPromise = supabaseClient.rpc('get_main_kpis', filters);
    const countPromise = supabaseClient.rpc('get_orders_count', filters);

    // 3. Chamar RPC da Tabela Paginada
    const tablePromise = supabaseClient.rpc('get_paginated_orders', {
        ...filters,
        p_page_number: mainTableState.currentPage,
        p_page_size: mainTableState.itemsPerPage
    });

    // 4. Processar KPIs
    const { data: kpiData } = await kpiPromise;
    // (Popule os KPIs 'orders-total-vendas', 'orders-kpi-positivacao', etc.
    //  usando a mesma lógica do ecrã principal, mas com kpiData[0])

    // 5. Processar Tabela e Contagem
    const { data: totalCount } = await countPromise;
    const { data: ordersData, error: ordersError } = await tablePromise;

    if (ordersError) { console.error('Orders Error:', ordersError); return; }

    mainTableState.filteredData = ordersData; // A sua função renderTable usará isto
    mainTableState.totalPages = Math.ceil(totalCount / mainTableState.itemsPerPage);

    renderTable(ordersData); // A sua função original renderTable deve funcionar!

    // 6. Atualizar controlos de paginação
    pageInfoText.textContent = `Página ${mainTableState.currentPage} de ${mainTableState.totalPages} (Total: ${totalCount} pedidos)`;
    prevPageBtn.disabled = mainTableState.currentPage === 1;
    nextPageBtn.disabled = mainTableState.currentPage === mainTableState.totalPages;
    tablePaginationControls.classList.remove('hidden');
}
Refatore os EventListeners:

Todos os EventListeners de filtros (supervisorFilter.addEventListener, clearFiltersBtn.addEventListener, etc.) agora devem:

Atualizar as suas variáveis de estado (ex: selectedSellers, currentFornecedor).

Chamar await updateDashboardViewVisuals(); (ou a função do ecrã respetivo).

Os botões de paginação (prevPageBtn, nextPageBtn) devem:

mainTableState.currentPage++;

Chamar await updateOrdersViewVisuals();

Fase 4: O Acabamento (Refatorar Ecrãs Restantes)
Use a mesma estratégia da Fase 3 para todos os outros ecrãs (city, weekly, comparison, stock, innovations, coverage).

Ecrã city-view:

Chame a RPC get_city_analysis.

A RPC devolve duas listas: tipo_analise = 'chart' e tipo_analise = 'client_list'.

Use os dados de 'chart' para o createChart('salesByClientInCityChart', ...).

Use os dados de 'client_list' para popular o gráfico customerStatusChart (contando os status_cliente) e as duas tabelas (filtrando por status_cliente).

Ecrã weekly-view:

Chame a RPC get_weekly_sales_and_rankings.

Faça um "loop" nos resultados:

const vendas = data.filter(d => d.tipo_dado === 'venda_semanal'); (Use para o gráfico principal).

const positivacao = data.filter(d => d.tipo_dado === 'rank_positivacao'); (Use para o gráfico de positivação).

...etc.

A sua lógica JS de createChart permanece a mesma, apenas recebe os dados já prontos.

Ecrã comparison-view:

Chame a RPC get_comparison_data.

const currentSales = data.filter(d => d.origem === 'current');

const historySales = data.filter(d => d.origem === 'history');

Isto é chave: Agora, as suas funções JS originais monthlyKpiAverage, calculateAverageMix..., updateComparisonView vão funcionar, mas sobre um conjunto de dados 1000x menor (apenas os dados pré-filtrados pela RPC).

Ecrã stock-view:

Chame a RPC get_stock_analysis_data.

Separe os dados:

const salesData = data.filter(d => d.origem === 'sale');

const stockMap = new Map(data.filter(d => d.origem === 'stock').map(s => [s.produto, s.stock_qty]));

const productDetailsMap = new Map(data.filter(d => d.origem === 'product').map(p => [p.produto, p]));

Novamente, a sua lógica updateStockView original vai funcionar, mas sobre dados pré-filtrados e pré-unidos, tornando-a instantânea.

Ecrãs innovations-view / coverage-view / innovations-month-view:

Estes são os mais fáceis de refatorar.

Obtenha a lista de p_product_codes (seja do filtro, seja da g_innovationsCategories).

Chame a RPC get_coverage_analysis com essa lista e os filtros.

A RPC devolve exatamente o que você precisa para a tabela: produto, stock_qty, current_pdvs, previous_pdvs, total_active_clients.

A sua lógica JS apenas calcula as percentagens (current_pdvs / total_active_clients * 100) e desenha a tabela/gráficos.

Fase 5: Limpeza Final
Apague Funções JS Antigas: Apague calculateSummaryFromData, getFilteredData (a versão antiga), getWeekOfMonth (agora é feito em SQL), etc.

Apague o Script de Uploader (do index.html): O seu index.html contém o script id="worker-script". Mova-o para um ficheiro separado (uploader.js ou worker.js) e remova-o do index.html. O seu dashboard principal não deve conter o código do uploader.

Apague o HTML do Uploader: Remova o div id="admin-uploader-modal" do seu index.html. Crie uma página separada admin.html que contenha apenas esse modal e o script do worker. Isso reduzirá o tamanho do seu index.html em 40% e melhora a segurança.

Ao seguir este plano, a sua aplicação passará de um sistema que "puxa" 1 milhão de linhas para um sistema que "pede" 10 a 100 linhas de resultados já calculados. A diferença de desempenho será da ordem de minutos para milissegundos. Boa programação!
