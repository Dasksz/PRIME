                        return colValues[prop][i];
                    }
                    return data[i][prop];
                };

                for (let i = 0; i < data.length; i++) {
                    // Optimized: Do not create Proxy 'sale' object here. Read directly.
                    // This avoids massive Proxy creation and Date object conversion overhead.

                    const id = `${isHistory ? 'h' : 'c'}_${i}`;

                    if (dataMap instanceof IndexMap) {
                        dataMap.set(id, i);
                    } else {
                        // For non-IndexMap usage, we store the object (or Proxy if Columnar)
                        dataMap.set(id, isColumnar ? data.get(i) : data[i]);
                    }

                    const supervisor = getVal(i, 'SUPERV') || 'N/A';
                    const rca = getVal(i, 'NOME') || 'N/A';
                    const pasta = getVal(i, 'OBSERVACAOFOR') || 'N/A';
                    const supplier = getVal(i, 'CODFOR');
                    const client = getVal(i, 'CODCLI');
                    const position = getVal(i, 'POSICAO') || 'N/A';
                    const rede = clientRamoMap.get(client) || 'N/A';
                    const tipoVenda = getVal(i, 'TIPOVENDA');
                    const product = getVal(i, 'PRODUTO');
                    // Optimized: Lookup City from Client Map (Removed from Sales Data to save space)
                    const clientObj = clientMapForKPIs.get(String(client));
                    const city = (clientObj ? (clientObj.cidade || clientObj['Nome da Cidade']) : 'N/A').toLowerCase();
                    const filial = getVal(i, 'FILIAL');
                    const codUsur = getVal(i, 'CODUSUR');
                    const codSupervisor = getVal(i, 'CODSUPERVISOR');

                    if (!bySupervisor.has(supervisor)) bySupervisor.set(supervisor, new Set()); bySupervisor.get(supervisor).add(id);
                    if (!byRca.has(rca)) byRca.set(rca, new Set()); byRca.get(rca).add(id);
                    if (!byPasta.has(pasta)) byPasta.set(pasta, new Set()); byPasta.get(pasta).add(id);
                    if (supplier) { if (!bySupplier.has(supplier)) bySupplier.set(supplier, new Set()); bySupplier.get(supplier).add(id); }
                    if (client) { if (!byClient.has(client)) byClient.set(client, new Set()); byClient.get(client).add(id); }
                    if (tipoVenda) { if (!byTipoVenda.has(tipoVenda)) byTipoVenda.set(tipoVenda, new Set()); byTipoVenda.get(tipoVenda).add(id); }
                    if (position) { if (!byPosition.has(position)) byPosition.set(position, new Set()); byPosition.get(position).add(id); }
                    if (rede) { if (!byRede.has(rede)) byRede.set(rede, new Set()); byRede.get(rede).add(id); }
                    if (product) { if (!byProduct.has(product)) byProduct.set(product, new Set()); byProduct.get(product).add(id); }
                    if (city) { if (!byCity.has(city)) byCity.set(city, new Set()); byCity.get(city).add(id); }
                    if (filial) { if (!byFilial.has(filial)) byFilial.set(filial, new Set()); byFilial.get(filial).add(id); }

                    if (codUsur && supervisor) { if (!supervisorToRcaMap.has(supervisor)) supervisorToRcaMap.set(supervisor, new Set()); supervisorToRcaMap.get(supervisor).add(codUsur); }
                    if (supplier && product) { if (!optimizedData.productsBySupplier.has(supplier)) optimizedData.productsBySupplier.set(supplier, new Set()); optimizedData.productsBySupplier.get(supplier).add(product); }
                    if (rca && codUsur) { optimizedData.rcaCodeByName.set(rca, codUsur); optimizedData.rcaNameByCode.set(codUsur, rca); }
                    if (supervisor && codSupervisor) { optimizedData.supervisorCodeByName.set(supervisor, codSupervisor); }
                    if (client && filial) { clientLastBranch.set(client, filial); }
                    if (product && pasta && !optimizedData.productPastaMap.has(product)) { optimizedData.productPastaMap.set(product, pasta); }

                    const dtPed = getVal(i, 'DTPED');
                    if (dtPed) {
                        // dtPed is likely a number (timestamp).
                        // If it's a number, new Date(dtPed) works.
                        // If it's a string, parseDate(dtPed) (from local function or global?)
                        // Global parseDate handles numbers too.
                        const dateObj = (typeof dtPed === 'number') ? new Date(dtPed) : parseDate(dtPed);

                        if(dateObj && !isNaN(dateObj.getTime())) {
                            const dayOfWeek = dateObj.getUTCDay();
                            if (dayOfWeek >= 1 && dayOfWeek <= 5) workingDaysSet.add(dateObj.toISOString().split('T')[0]);
                        }
                    }

                    if (product) {
                        const targetMap = isHistory ? optimizedData.salesByProduct.history : optimizedData.salesByProduct.current;
                        if (!targetMap.has(product)) targetMap.set(product, []);
                        // Here we still push the item object because consumers expect it.
                        // Ideally we would store indices, but that requires larger refactor.
                        // Since this is subset by product, it might be acceptable, or we create Proxy on demand.
                        targetMap.get(product).push(isColumnar ? data.get(i) : data[i]);
                    }
                }
            };

            processDatasetForIndices(allSalesData, optimizedData.indices.current, optimizedData.salesById, false);
            processDatasetForIndices(allHistoryData, optimizedData.indices.history, optimizedData.historyById, true);

            // --- POPULATE MISSING PASTA FOR UNSOLD PRODUCTS ---
            // Build a map of CODFOR -> PASTA using sold products
            const codforToPastaMap = new Map();
            optimizedData.productPastaMap.forEach((pasta, productCode) => {
                const details = productDetailsMap.get(productCode);
                if (details && details.codfor) {
                    if (!codforToPastaMap.has(details.codfor)) {
                        codforToPastaMap.set(details.codfor, pasta);
                    }
                }
            });

            // Backfill Pasta for products that have no sales (and thus no entry in productPastaMap yet)
            productDetailsMap.forEach((details, productCode) => {
                if (!optimizedData.productPastaMap.has(productCode) && details.codfor) {
                    const inferredPasta = codforToPastaMap.get(details.codfor);
                    if (inferredPasta) {
                        optimizedData.productPastaMap.set(productCode, inferredPasta);
                    }
                }
            });
            // --- END BACKFILL ---

            supervisorToRcaMap.forEach((rcas, supervisor) => {
                optimizedData.rcasBySupervisor.set(supervisor, Array.from(rcas));
            });

            // Process Aggregated Orders (Remap only)
            for(let i = 0; i < aggregatedOrders.length; i++) {
                const sale = aggregatedOrders[i];
                // Convert to Date if number
                if (sale.DTPED && !(sale.DTPED instanceof Date)) sale.DTPED = new Date(sale.DTPED);
                if (sale.DTSAIDA && !(sale.DTSAIDA instanceof Date)) sale.DTSAIDA = new Date(sale.DTSAIDA);

                if (sale.CODCLI !== americanasCodCli) {
                    const currentSellerCode = clientToCurrentSellerMap.get(sale.CODCLI);
                    if (currentSellerCode) {
                        const sellerDetails = sellerDetailsMap.get(currentSellerCode);
                        if (sellerDetails) {
                            sale.CODUSUR = currentSellerCode;
                            sale.NOME = sellerDetails.name;
                            sale.SUPERV = sellerDetails.supervisor;
                        }
                    }
                }
            }

            sortedWorkingDays = Array.from(workingDaysSet).sort((a, b) => new Date(a) - new Date(b));
            maxWorkingDaysStock = workingDaysSet.size > 0 ? workingDaysSet.size : 1;
            customWorkingDaysStock = maxWorkingDaysStock;

            setTimeout(() => {
                const maxDaysLabel = document.getElementById('max-working-days-label');
                if (maxDaysLabel) maxDaysLabel.textContent = `(Máx: ${maxWorkingDaysStock})`;
                const daysInput = document.getElementById('stock-working-days-input');
                if(daysInput) daysInput.value = customWorkingDaysStock;
            }, 0);
        }

        aggregatedOrders.sort((a, b) => {
            const dateA = parseDate(a.DTPED);
            const dateB = parseDate(b.DTPED);
            if (!dateA) return 1;
            if (!dateB) return -1;
            return dateB - dateA;
        });

        Chart.register(ChartDataLabels);

        const mainDashboard = document.getElementById('main-dashboard');
        const cityView = document.getElementById('city-view');
        const weeklyView = document.getElementById('weekly-view');
        const comparisonView = document.getElementById('comparison-view');
        const stockView = document.getElementById('stock-view');

        const showWeeklyBtn = document.getElementById('show-weekly-btn');
        const showCityBtn = document.getElementById('show-city-btn');
        const backToMainFromCityBtn = document.getElementById('back-to-main-from-city-btn');
        const backToMainFromWeeklyBtn = document.getElementById('back-to-main-from-weekly-btn');
        const backToMainFromComparisonBtn = document.getElementById('back-to-main-from-comparison-btn');
        const backToMainFromStockBtn = document.getElementById('back-to-main-from-stock-btn');

        const totalVendasEl = document.getElementById('total-vendas');
        const totalPesoEl = document.getElementById('total-peso');
        const kpiSkuPdVEl = document.getElementById('kpi-sku-pdv');
        const kpiPositivacaoEl = document.getElementById('kpi-positivacao');
        const kpiPositivacaoPercentEl = document.getElementById('kpi-positivacao-percent');


        const viewChartBtn = document.getElementById('viewChartBtn');
        const viewTableBtn = document.getElementById('viewTableBtn');
        const viewComparisonBtn = document.getElementById('viewComparisonBtn');
        const viewStockBtn = document.getElementById('viewStockBtn');
        const chartView = document.getElementById('chartView');
        const tableView = document.getElementById('tableView');
        const faturamentoBtn = document.getElementById('faturamentoBtn');
        const pesoBtn = document.getElementById('pesoBtn');

        const supervisorFilter = document.getElementById('supervisor-filter');
        const fornecedorFilter = document.getElementById('fornecedor-filter');
        const vendedorFilterBtn = document.getElementById('vendedor-filter-btn');
        const vendedorFilterText = document.getElementById('vendedor-filter-text');
        const vendedorFilterDropdown = document.getElementById('vendedor-filter-dropdown');

        const tipoVendaFilterBtn = document.getElementById('tipo-venda-filter-btn');
        const tipoVendaFilterText = document.getElementById('tipo-venda-filter-text');
        const tipoVendaFilterDropdown = document.getElementById('tipo-venda-filter-dropdown');

        const mainRedeGroupContainer = document.getElementById('main-rede-group-container');
        const mainComRedeBtn = document.getElementById('main-com-rede-btn');
        const mainComRedeBtnText = document.getElementById('main-com-rede-btn-text');
        const mainRedeFilterDropdown = document.getElementById('main-rede-filter-dropdown');

        const posicaoFilter = document.getElementById('posicao-filter');
        const codcliFilter = document.getElementById('codcli-filter');
        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        const salesByPersonTitle = document.getElementById('sales-by-person-title');
        const fornecedorToggleContainerEl = document.getElementById('fornecedor-toggle-container');

        const citySupervisorFilter = document.getElementById('city-supervisor-filter');
        const cityVendedorFilterBtn = document.getElementById('city-vendedor-filter-btn');
        const cityVendedorFilterText = document.getElementById('city-vendedor-filter-text');
        const cityVendedorFilterDropdown = document.getElementById('city-vendedor-filter-dropdown');
        const cityNameFilter = document.getElementById('city-name-filter');
        const cityCodCliFilter = document.getElementById('city-codcli-filter');
        const citySuggestions = document.getElementById('city-suggestions');
        const clearCityFiltersBtn = document.getElementById('clear-city-filters-btn');
        const totalFaturamentoCidadeEl = document.getElementById('total-faturamento-cidade');
        const totalClientesCidadeEl = document.getElementById('total-clientes-cidade');
        const cityActiveDetailTableBody = document.getElementById('city-active-detail-table-body');
        const cityInactiveDetailTableBody = document.getElementById('city-inactive-detail-table-body');

        const cityRedeGroupContainer = document.getElementById('city-rede-group-container');
        const cityComRedeBtn = document.getElementById('city-com-rede-btn');
        const cityComRedeBtnText = document.getElementById('city-com-rede-btn-text');
        const cityRedeFilterDropdown = document.getElementById('city-rede-filter-dropdown');

        const cityTipoVendaFilterBtn = document.getElementById('city-tipo-venda-filter-btn');
        const cityTipoVendaFilterText = document.getElementById('city-tipo-venda-filter-text');
        const cityTipoVendaFilterDropdown = document.getElementById('city-tipo-venda-filter-dropdown');

        const weeklySupervisorFilter = document.getElementById('weekly-supervisor-filter');
        const clearWeeklyFiltersBtn = document.getElementById('clear-weekly-filters-btn');
        const totalMesSemanalEl = document.getElementById('total-mes-semanal');
        const weeklyFornecedorToggleContainer = document.getElementById('weekly-fornecedor-toggle-container');

        const comparisonSupervisorFilter = document.getElementById('comparison-supervisor-filter');
        const comparisonVendedorFilterBtn = document.getElementById('comparison-vendedor-filter-btn');
        const comparisonVendedorFilterText = document.getElementById('comparison-vendedor-filter-text');
        const comparisonVendedorFilterDropdown = document.getElementById('comparison-vendedor-filter-dropdown');
        const comparisonFornecedorToggleContainer = document.getElementById('comparison-fornecedor-toggle-container');
        const comparisonFilialFilter = document.getElementById('comparison-filial-filter');

        const comparisonSupplierFilterBtn = document.getElementById('comparison-supplier-filter-btn');
        const comparisonSupplierFilterText = document.getElementById('comparison-supplier-filter-text');
        const comparisonSupplierFilterDropdown = document.getElementById('comparison-supplier-filter-dropdown');

        const comparisonCityFilter = document.getElementById('comparison-city-filter');
        const comparisonCitySuggestions = document.getElementById('comparison-city-suggestions');
        const comparisonProductFilterBtn = document.getElementById('comparison-product-filter-btn');
        const comparisonProductFilterText = document.getElementById('comparison-product-filter-text');
        const comparisonProductFilterDropdown = document.getElementById('comparison-product-filter-dropdown');

        const comparisonRedeGroupContainer = document.getElementById('comparison-rede-group-container');
        const comparisonComRedeBtn = document.getElementById('comparison-com-rede-btn');
        const comparisonComRedeBtnText = document.getElementById('comparison-com-rede-btn-text');
        const comparisonRedeFilterDropdown = document.getElementById('comparison-rede-filter-dropdown');

        const comparisonTipoVendaFilterBtn = document.getElementById('comparison-tipo-venda-filter-btn');
        const comparisonTipoVendaFilterText = document.getElementById('comparison-tipo-venda-filter-text');
        const comparisonTipoVendaFilterDropdown = document.getElementById('comparison-tipo-venda-filter-dropdown');

        const clearComparisonFiltersBtn = document.getElementById('clear-comparison-filters-btn');
        const comparisonTendencyToggle = document.getElementById('comparison-tendency-toggle');

        const comparisonChartTitle = document.getElementById('comparison-chart-title');
        const toggleWeeklyBtn = document.getElementById('toggle-weekly-btn');
        const toggleMonthlyBtn = document.getElementById('toggle-monthly-btn');
        const weeklyComparisonChartContainer = document.getElementById('weeklyComparisonChartContainer');
        const monthlyComparisonChartContainer = document.getElementById('monthlyComparisonChartContainer');

        const stockFilialFilter = document.getElementById('stock-filial-filter');
        const stockRedeGroupContainer = document.getElementById('stock-rede-group-container');
        const stockComRedeBtn = document.getElementById('stock-com-rede-btn');
        const stockComRedeBtnText = document.getElementById('stock-com-rede-btn-text');
        const stockRedeFilterDropdown = document.getElementById('stock-rede-filter-dropdown');
        const stockFornecedorToggleContainer = document.getElementById('stock-fornecedor-toggle-container');
        const stockSupervisorFilter = document.getElementById('stock-supervisor-filter');
        const stockVendedorFilterBtn = document.getElementById('stock-vendedor-filter-btn');
        const stockVendedorFilterText = document.getElementById('stock-vendedor-filter-text');
        const stockVendedorFilterDropdown = document.getElementById('stock-vendedor-filter-dropdown');
        const stockSupplierFilterBtn = document.getElementById('stock-supplier-filter-btn');
        const stockSupplierFilterText = document.getElementById('stock-supplier-filter-text');
        const stockSupplierFilterDropdown = document.getElementById('stock-supplier-filter-dropdown');
        const stockCityFilter = document.getElementById('stock-city-filter');
        const stockCitySuggestions = document.getElementById('stock-city-suggestions');
        const stockProductFilterBtn = document.getElementById('stock-product-filter-btn');
        const stockProductFilterText = document.getElementById('stock-product-filter-text');
        const stockProductFilterDropdown = document.getElementById('stock-product-filter-dropdown');
        const stockTipoVendaFilterBtn = document.getElementById('stock-tipo-venda-filter-btn');
        const stockTipoVendaFilterText = document.getElementById('stock-tipo-venda-filter-text');
        const stockTipoVendaFilterDropdown = document.getElementById('stock-tipo-venda-filter-dropdown');
        const clearStockFiltersBtn = document.getElementById('clear-stock-filters-btn');
        const stockAnalysisTableBody = document.getElementById('stock-analysis-table-body');
        const growthTableBody = document.getElementById('growth-table-body');
        const declineTableBody = document.getElementById('decline-table-body');
        const newProductsTableBody = document.getElementById('new-products-table-body');
        const lostProductsTableBody = document.getElementById('lost-products-table-body');


        const innovationsMonthView = document.getElementById('innovations-month-view');
        const innovationsMonthChartContainer = document.getElementById('innovations-month-chartContainer');
        const innovationsMonthTableBody = document.getElementById('innovations-month-table-body');
        const innovationsMonthCategoryFilter = document.getElementById('innovations-month-category-filter');
        const innovationsMonthSupervisorFilter = document.getElementById('innovations-month-supervisor-filter');
        const innovationsMonthVendedorFilterBtn = document.getElementById('innovations-month-vendedor-filter-btn');
        const innovationsMonthVendedorFilterText = document.getElementById('innovations-month-vendedor-filter-text');
        const innovationsMonthVendedorFilterDropdown = document.getElementById('innovations-month-vendedor-filter-dropdown');
        const innovationsMonthCityFilter = document.getElementById('innovations-month-city-filter');
        const innovationsMonthCitySuggestions = document.getElementById('innovations-month-city-suggestions');
        const clearInnovationsMonthFiltersBtn = document.getElementById('clear-innovations-month-filters-btn');
        const innovationsMonthFilialFilter = document.getElementById('innovations-month-filial-filter');
        const innovationsMonthActiveClientsKpi = document.getElementById('innovations-month-active-clients-kpi');
        const innovationsMonthTopCoverageKpi = document.getElementById('innovations-month-top-coverage-kpi');
        const innovationsMonthTopCoverageValueKpi = document.getElementById('innovations-month-top-coverage-value-kpi');
        const innovationsMonthTopCoverageCountKpi = document.getElementById('innovations-month-top-coverage-count-kpi');
        const innovationsMonthSelectionCoverageValueKpi = document.getElementById('innovations-month-selection-coverage-value-kpi');
        const innovationsMonthSelectionCoverageCountKpi = document.getElementById('innovations-month-selection-coverage-count-kpi');
        const innovationsMonthSelectionCoverageValueKpiPrevious = document.getElementById('innovations-month-selection-coverage-value-kpi-previous');
        const innovationsMonthSelectionCoverageCountKpiPrevious = document.getElementById('innovations-month-selection-coverage-count-kpi-previous');
        const innovationsMonthBonusCoverageValueKpi = document.getElementById('innovations-month-bonus-coverage-value-kpi');
        const innovationsMonthBonusCoverageCountKpi = document.getElementById('innovations-month-bonus-coverage-count-kpi');
        const innovationsMonthBonusCoverageValueKpiPrevious = document.getElementById('innovations-month-bonus-coverage-value-kpi-previous');
        const innovationsMonthBonusCoverageCountKpiPrevious = document.getElementById('innovations-month-bonus-coverage-count-kpi-previous');
        const exportInnovationsMonthPdfBtn = document.getElementById('export-innovations-month-pdf-btn');
        const innovationsMonthTipoVendaFilterBtn = document.getElementById('innovations-month-tipo-venda-filter-btn');
        const innovationsMonthTipoVendaFilterText = document.getElementById('innovations-month-tipo-venda-filter-text');
        const innovationsMonthTipoVendaFilterDropdown = document.getElementById('innovations-month-tipo-venda-filter-dropdown');

        const coverageView = document.getElementById('coverage-view');
        const viewCoverageBtn = document.getElementById('viewCoverageBtn');
        const backToMainFromCoverageBtn = document.getElementById('back-to-main-from-coverage-btn');
        const coverageSupervisorFilter = document.getElementById('coverage-supervisor-filter');
        const coverageVendedorFilterBtn = document.getElementById('coverage-vendedor-filter-btn');
        const coverageVendedorFilterText = document.getElementById('coverage-vendedor-filter-text');
        const coverageVendedorFilterDropdown = document.getElementById('coverage-vendedor-filter-dropdown');
        const coverageSupplierFilterBtn = document.getElementById('coverage-supplier-filter-btn');
        const coverageSupplierFilterText = document.getElementById('coverage-supplier-filter-text');
        const coverageSupplierFilterDropdown = document.getElementById('coverage-supplier-filter-dropdown');
        const coverageCityFilter = document.getElementById('coverage-city-filter');
        const coverageCitySuggestions = document.getElementById('coverage-city-suggestions');
        const coverageProductFilterBtn = document.getElementById('coverage-product-filter-btn');
        const coverageProductFilterText = document.getElementById('coverage-product-filter-text');
        const coverageProductFilterDropdown = document.getElementById('coverage-product-filter-dropdown');
        const clearCoverageFiltersBtn = document.getElementById('clear-coverage-filters-btn');
        const coverageFilialFilter = document.getElementById('coverage-filial-filter');
        const coverageIncludeBonusCheckbox = document.getElementById('coverage-include-bonus');

        const coverageActiveClientsKpi = document.getElementById('coverage-active-clients-kpi');
        const coverageSelectionCoverageValueKpiPrevious = document.getElementById('coverage-selection-coverage-value-kpi-previous');
        const coverageSelectionCoverageCountKpiPrevious = document.getElementById('coverage-selection-coverage-count-kpi-previous');
        const coverageSelectionCoverageValueKpi = document.getElementById('coverage-selection-coverage-value-kpi');
        const coverageSelectionCoverageCountKpi = document.getElementById('coverage-selection-coverage-count-kpi');
        const coverageTopCoverageValueKpi = document.getElementById('coverage-top-coverage-value-kpi');
        const coverageTopCoverageProductKpi = document.getElementById('coverage-top-coverage-product-kpi');
        const coverageTotalBoxesEl = document.getElementById('coverage-total-boxes');

        const coverageTableBody = document.getElementById('coverage-table-body');

        // --- Goals View Elements ---
        const goalsView = document.getElementById('goals-view');
        const goalsGvContent = document.getElementById('goals-gv-content');
        const goalsSvContent = document.getElementById('goals-sv-content');
        const goalsGvTableBody = document.getElementById('goals-gv-table-body');
        const goalsGvTotalValueEl = document.getElementById('goals-gv-total-value');

        const goalsGvSupervisorFilterBtn = document.getElementById('goals-gv-supervisor-filter-btn');
        const goalsGvSupervisorFilterText = document.getElementById('goals-gv-supervisor-filter-text');
        const goalsGvSupervisorFilterDropdown = document.getElementById('goals-gv-supervisor-filter-dropdown');

        const goalsGvSellerFilterBtn = document.getElementById('goals-gv-seller-filter-btn');
        const goalsGvSellerFilterText = document.getElementById('goals-gv-seller-filter-text');
        const goalsGvSellerFilterDropdown = document.getElementById('goals-gv-seller-filter-dropdown');

        const goalsGvCodcliFilter = document.getElementById('goals-gv-codcli-filter');
        const clearGoalsGvFiltersBtn = document.getElementById('clear-goals-gv-filters-btn');

        const goalsSvSupervisorFilterBtn = document.getElementById('goals-sv-supervisor-filter-btn');
        const goalsSvSupervisorFilterText = document.getElementById('goals-sv-supervisor-filter-text');
        const goalsSvSupervisorFilterDropdown = document.getElementById('goals-sv-supervisor-filter-dropdown');


        const modal = document.getElementById('order-details-modal');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalPedidoId = document.getElementById('modal-pedido-id');
        const modalHeaderInfo = document.getElementById('modal-header-info');
        const modalTableBody = document.getElementById('modal-table-body');
        const modalFooterTotal = document.getElementById('modal-footer-total');

        const clientModal = document.getElementById('client-details-modal');
        const clientModalCloseBtn = document.getElementById('client-modal-close-btn');
        const clientModalContent = document.getElementById('client-modal-content');

        const holidayModal = document.getElementById('holiday-modal');
        const holidayModalCloseBtn = document.getElementById('holiday-modal-close-btn');
        const holidayModalDoneBtn = document.getElementById('holiday-modal-done-btn');
        const mainHolidayPickerBtn = document.getElementById('main-holiday-picker-btn');
        const comparisonHolidayPickerBtn = document.getElementById('comparison-holiday-picker-btn');
        const calendarContainer = document.getElementById('calendar-container');

        const tablePaginationControls = document.getElementById('table-pagination-controls');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const pageInfoText = document.getElementById('page-info-text');

        // --- View State Management ---
        const viewState = {
            dashboard: { dirty: true },
            pedidos: { dirty: true },
            comparativo: { dirty: true },
            estoque: { dirty: true },
            cobertura: { dirty: true },
            cidades: { dirty: true },
            semanal: { dirty: true },
            inovacoes: { dirty: true, cache: null, lastTypesKey: '' },
            mix: { dirty: true },
            goals: { dirty: true }
        };

        // Render IDs for Race Condition Guard
        let mixRenderId = 0;
        let coverageRenderId = 0;
        let cityRenderId = 0;
        let stockRenderId = 0;
        let comparisonRenderId = 0;
        let goalsRenderId = 0;
        let goalsSvRenderId = 0;

        let charts = {};
        let currentProductMetric = 'faturamento';
        let currentFornecedor = '';
        let currentWeeklyFornecedor = '';
        let currentComparisonFornecedor = '';
        let currentStockFornecedor = '';
        let useTendencyComparison = false;
        let comparisonChartType = 'weekly';
        let comparisonMonthlyMetric = 'faturamento';
        let activeClientsForExport = [];
        let inactiveClientsForExport = [];
        let selectedSellers = [];
        let selectedMainSupervisors = [];
        let selectedMainSuppliers = [];
        let selectedTiposVenda = [];
        let selectedCitySellers = [];
        let selectedCitySupervisors = [];
        let selectedComparisonSellers = [];
        let selectedComparisonSupervisors = [];
        let selectedStockSellers = [];
        let selectedStockSupervisors = [];
        let selectedComparisonSuppliers = [];
        let selectedComparisonProducts = [];
        let selectedStockSuppliers = [];
        let selectedStockProducts = [];
        let selectedStockTiposVenda = [];
        let selectedCoverageTiposVenda = [];
        let selectedComparisonTiposVenda = [];
        let selectedCityTiposVenda = [];
        let historicalBests = {};
        let selectedHolidays = [];
        let stockTrendFilter = 'all';

        let selectedMainRedes = [];
        let selectedCityRedes = [];
        let selectedComparisonRedes = [];
        let selectedStockRedes = [];

        let mainRedeGroupFilter = '';
        let cityRedeGroupFilter = '';
        let comparisonRedeGroupFilter = '';
        let stockRedeGroupFilter = '';

        let selectedInnovationsMonthSellers = [];
        let selectedInnovationsSupervisors = [];
        let selectedInnovationsMonthTiposVenda = [];

        let selectedMixSupervisors = [];
        let selectedMixSellers = [];
        let selectedMixRedes = [];
        let mixRedeGroupFilter = '';
        let selectedMixTiposVenda = [];
        let mixTableDataForExport = [];
        let mixKpiMode = 'total'; // 'total' ou 'atendidos'

        let currentGoalsSupplier = 'PEPSICO_ALL';
        let currentGoalsBrand = null;
        let currentGoalsSvSupplier = '707';
        let currentGoalsSvBrand = null;
        let currentGoalsSvData = [];
        let goalsTableState = {
            currentPage: 1,
            itemsPerPage: 100,
            filteredData: [],
            totalPages: 1
        };
        let goalsTargets = {
            '707': { fat: 0, vol: 0 },
            '708': { fat: 0, vol: 0 },
            '752': { fat: 0, vol: 0 },
            '1119_TODDYNHO': { fat: 0, vol: 0 },
            '1119_TODDY': { fat: 0, vol: 0 },
            '1119_QUAKER_KEROCOCO': { fat: 0, vol: 0 }
        };
        let globalGoalsMetrics = {};
        let globalGoalsTotalsCache = {};
        let globalClientGoals = new Map();
        let goalsPosAdjustments = { 'ELMA_ALL': new Map(), 'FOODS_ALL': new Map(), 'PEPSICO_ALL': new Map(), '707': new Map(), '708': new Map(), '752': new Map(), '1119_TODDYNHO': new Map(), '1119_TODDY': new Map(), '1119_QUAKER_KEROCOCO': new Map() }; // Map<CodCli, Map<Key, {fat: 0, vol: 0}>>
        let goalsMixSaltyAdjustments = { 'PEPSICO_ALL': new Map(), 'ELMA_ALL': new Map(), 'FOODS_ALL': new Map() }; // Map<SellerName, adjustment>
        let goalsMixFoodsAdjustments = { 'PEPSICO_ALL': new Map(), 'ELMA_ALL': new Map(), 'FOODS_ALL': new Map() }; // Map<SellerName, adjustment>
        let quarterMonths = [];

        function identifyQuarterMonths() {
            const months = new Set();
            allHistoryData.forEach(s => {
                const d = parseDate(s.DTPED);
                if(d) {
                    months.add(`${d.getUTCFullYear()}-${d.getUTCMonth()}`);
                }
            });
            const sorted = Array.from(months).sort((a, b) => {
                const [y1, m1] = a.split('-').map(Number);
                const [y2, m2] = b.split('-').map(Number);
                return (y1 * 12 + m1) - (y2 * 12 + m2);
            });
            // Take last 3
            const last3 = sorted.slice(-3);

            const monthNames = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];

            quarterMonths = last3.map(k => {
                const [y, m] = k.split('-');
                return { key: k, label: monthNames[parseInt(m)] };
            });
        }

        function calculateGoalsMetrics() {
            if (quarterMonths.length === 0) identifyQuarterMonths();

            // Helper to init metrics structure
            const createMetric = () => ({
                fat: 0, vol: 0, prevFat: 0, prevVol: 0,
                prevClientsSet: new Set(),
                quarterlyPosClientsSet: new Set(), // New Set for Quarter Active
                monthlyClientsSets: new Map() // Map<MonthKey, Set<CodCli>>
            });

            globalGoalsMetrics = {
                '707': createMetric(),
                '708': createMetric(),
                '752': createMetric(),
                '1119_TODDYNHO': createMetric(),
                '1119_TODDY': createMetric(),
                '1119_QUAKER_KEROCOCO': createMetric(),
                'ELMA_ALL': createMetric(),
                'FOODS_ALL': createMetric(),
                'PEPSICO_ALL': createMetric()
            };

            const currentDate = lastSaleDate;
            const prevMonthDate = new Date(Date.UTC(currentDate.getUTCFullYear(), currentDate.getUTCMonth() - 1, 1));
            const prevMonthIndex = prevMonthDate.getUTCMonth();
            const prevMonthYear = prevMonthDate.getUTCFullYear();

            // Filter clients to match the "Active Structure" definition (Same as Coverage/Goals Table)
            const activeClients = allClientsData.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                if (isAmericanas) return true;
                // STRICT FILTER: Exclude RCA 53 (Balcão) and INATIVOS (Empty RCA1)
                if (rca1 === '53') return false;
                if (rca1 === '') return false; // Exclude INATIVOS
                return true;
            });

            // Optimization: Detect if history is columnar and IndexMap is available
            const isHistoryColumnar = optimizedData.historyById instanceof IndexMap && optimizedData.historyById._source.values;
            const historyValues = isHistoryColumnar ? optimizedData.historyById._source.values : null;

            activeClients.forEach(client => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                // Temp accumulation for this client to ensure Positive Balance check
                const clientTotals = {}; // key -> { prevFat: 0, monthlyFat: Map<MonthKey, val> }

                if (clientHistoryIds) {
                    if (isHistoryColumnar) {
                        // Optimized Path: Use indices
                        clientHistoryIds.forEach(id => {
                            const idx = optimizedData.historyById.getIndex(id);
                            if (idx === undefined) return;

                            const codUsur = historyValues['CODUSUR'][idx];
                             // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Summary Metrics
                            if (String(codCli).trim() === '9569' && (String(codUsur).trim() === '53' || String(codUsur).trim() === '053')) return;

                            let key = null;
                            const codFor = String(historyValues['CODFOR'][idx]);

                            if (codFor === '707') key = '707';
                            else if (codFor === '708') key = '708';
                            else if (codFor === '752') key = '752';
                            else if (codFor === '1119') {
                                const desc = normalize(historyValues['DESCRICAO'][idx] || '');
                                if (desc.includes('TODDYNHO')) key = '1119_TODDYNHO';
                                else if (desc.includes('TODDY')) key = '1119_TODDY';
                                else if (desc.includes('QUAKER') || desc.includes('KEROCOCO')) key = '1119_QUAKER_KEROCOCO';
                            }

                            if (key && globalGoalsMetrics[key]) {
                                const dtPed = historyValues['DTPED'][idx];
                                const d = typeof dtPed === 'number' ? new Date(dtPed) : parseDate(dtPed);
                                const isPrevMonth = d && d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear;

                                // 1. Revenue/Volume metrics (Types 1 & 9) - Global Sums
                                const tipoVenda = historyValues['TIPOVENDA'][idx];
                                if (tipoVenda === '1' || tipoVenda === '9') {
                                    const vlVenda = Number(historyValues['VLVENDA'][idx]) || 0;
                                    const totPeso = Number(historyValues['TOTPESOLIQ'][idx]) || 0;

                                    globalGoalsMetrics[key].fat += vlVenda;
                                    globalGoalsMetrics[key].vol += totPeso;

                                    if (isPrevMonth) {
                                        globalGoalsMetrics[key].prevFat += vlVenda;
                                        globalGoalsMetrics[key].prevVol += totPeso;

                                        // Initialize Client Goal with Prev Month Value
                                        if (!globalClientGoals.has(codCli)) globalClientGoals.set(codCli, new Map());
                                        const cGoals = globalClientGoals.get(codCli);
                                        if (!cGoals.has(key)) cGoals.set(key, { fat: 0, vol: 0 });
                                        const g = cGoals.get(key);
                                        g.fat += vlVenda;
                                        g.vol += totPeso; // Kg
                                    }

                                    // 2. Accumulate for Client Count Check (Balance per period)
                                    if (d) {
                                    if (!clientTotals[key]) clientTotals[key] = { prevFat: 0, monthlyFat: new Map() };

                                    if (isPrevMonth) clientTotals[key].prevFat += vlVenda;

                                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                                    const currentMVal = clientTotals[key].monthlyFat.get(monthKey) || 0;
                                    clientTotals[key].monthlyFat.set(monthKey, currentMVal + vlVenda);
                                    }
                                }
                            }
                        });
                    } else {
                        // Fallback: Original Logic
                        clientHistoryIds.forEach(id => {
                            const sale = optimizedData.historyById.get(id);
                            // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Summary Metrics
                            if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                            let key = null;
                            const codFor = String(sale.CODFOR);

                            if (codFor === '707') key = '707';
                            else if (codFor === '708') key = '708';
                            else if (codFor === '752') key = '752';
                            else if (codFor === '1119') {
                                const desc = normalize(sale.DESCRICAO || '');
                                if (desc.includes('TODDYNHO')) key = '1119_TODDYNHO';
                                else if (desc.includes('TODDY')) key = '1119_TODDY';
                                else if (desc.includes('QUAKER') || desc.includes('KEROCOCO')) key = '1119_QUAKER_KEROCOCO';
                            }

                            if (key && globalGoalsMetrics[key]) {
                                const d = parseDate(sale.DTPED);
                                const isPrevMonth = d && d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear;

                                // 1. Revenue/Volume metrics (Types 1 & 9) - Global Sums
                                if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                    globalGoalsMetrics[key].fat += sale.VLVENDA;
                                    globalGoalsMetrics[key].vol += sale.TOTPESOLIQ;

                                    if (isPrevMonth) {
                                        globalGoalsMetrics[key].prevFat += sale.VLVENDA;
                                        globalGoalsMetrics[key].prevVol += sale.TOTPESOLIQ;

                                        // Initialize Client Goal with Prev Month Value
                                        if (!globalClientGoals.has(codCli)) globalClientGoals.set(codCli, new Map());
                                        const cGoals = globalClientGoals.get(codCli);
                                        if (!cGoals.has(key)) cGoals.set(key, { fat: 0, vol: 0 });
                                        const g = cGoals.get(key);
                                        g.fat += sale.VLVENDA;
                                        g.vol += sale.TOTPESOLIQ; // Kg
                                    }

                                    // 2. Accumulate for Client Count Check (Balance per period)
                                    if (d) {
                                    if (!clientTotals[key]) clientTotals[key] = { prevFat: 0, monthlyFat: new Map() };

                                    if (isPrevMonth) clientTotals[key].prevFat += sale.VLVENDA;

                                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                                    const currentMVal = clientTotals[key].monthlyFat.get(monthKey) || 0;
                                    clientTotals[key].monthlyFat.set(monthKey, currentMVal + sale.VLVENDA);
                                    }
                                }
                            }
                        });
                    }
                }

                // Check thresholds for this client
                for (const key in clientTotals) {
                    const t = clientTotals[key];
                    if (t.prevFat > 1) {
                        globalGoalsMetrics[key].prevClientsSet.add(codCli);
                    }
                    t.monthlyFat.forEach((val, mKey) => {
                        if (val > 1) {
                            if (!globalGoalsMetrics[key].monthlyClientsSets.has(mKey)) {
                                globalGoalsMetrics[key].monthlyClientsSets.set(mKey, new Set());
                            }
                            globalGoalsMetrics[key].monthlyClientsSets.get(mKey).add(codCli);
                        }
                    });
                }
            });

            // Calculate Averages and Finalize
            // First calculate basic metrics for leaf keys
            const leafKeys = ['707', '708', '752', '1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];

            // Helper for aggregation
            const aggregateToAll = (targetKey, sourceKeys) => {
                const target = globalGoalsMetrics[targetKey];
                sourceKeys.forEach(key => {
                    const source = globalGoalsMetrics[key];
                    target.fat += source.fat;
                    target.vol += source.vol;
                    target.prevFat += source.prevFat;
                    target.prevVol += source.prevVol; // Already raw, keep raw for now

                    source.prevClientsSet.forEach(c => target.prevClientsSet.add(c));
                    source.quarterlyPosClientsSet.forEach(c => target.quarterlyPosClientsSet.add(c));

                    source.monthlyClientsSets.forEach((set, monthKey) => {
                        if (!target.monthlyClientsSets.has(monthKey)) {
                            target.monthlyClientsSets.set(monthKey, new Set());
                        }
                        const targetSet = target.monthlyClientsSets.get(monthKey);
                        set.forEach(c => targetSet.add(c));
                    });
                });
            };

            aggregateToAll('ELMA_ALL', ['707', '708', '752']);
            aggregateToAll('FOODS_ALL', ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO']);
            aggregateToAll('PEPSICO_ALL', ['707', '708', '752', '1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO']);

            // Finalize calculations for ALL keys
            for (const key in globalGoalsMetrics) {
                const m = globalGoalsMetrics[key];

                m.avgFat = m.fat / QUARTERLY_DIVISOR;
                m.avgVol = m.vol / QUARTERLY_DIVISOR; // Kg (No / 1000)
                m.prevVol = m.prevVol; // Kg (No / 1000)

                m.prevClients = m.prevClientsSet.size;

                let sumClients = 0;
                m.monthlyClientsSets.forEach(set => sumClients += set.size);
                m.avgClients = sumClients / QUARTERLY_DIVISOR;
            }
        }
        let selectedGoalsGvSupervisors = [];
        let selectedGoalsGvSellers = [];
        let selectedGoalsSvSupervisors = [];
        let selectedGoalsSummarySupervisors = [];

        // let innovationsIncludeBonus = true; // REMOVED
        // let innovationsMonthIncludeBonus = true; // REMOVED

        let innovationsMonthTableDataForExport = [];
        let innovationsByClientForExport = [];
        let categoryLegendForExport = [];
        let chartLabels = [];
        let globalInnovationCategories = null;
        let globalProductToCategoryMap = null;

        let calendarState = { year: lastSaleDate.getUTCFullYear(), month: lastSaleDate.getUTCMonth() };

        let selectedCoverageSellers = [];
        let selectedCoverageSuppliers = [];
        let selectedCoverageSupervisors = [];
        let selectedCoverageProducts = [];
        let coverageUnitPriceFilter = null;
        let customWorkingDaysCoverage = 0;
        let coverageTrendFilter = 'all';
        let coverageTableDataForExport = [];
        let currentCoverageChartMode = 'city';

        const coverageTipoVendaFilterBtn = document.getElementById('coverage-tipo-venda-filter-btn');
        const coverageTipoVendaFilterText = document.getElementById('coverage-tipo-venda-filter-text');
        const coverageTipoVendaFilterDropdown = document.getElementById('coverage-tipo-venda-filter-dropdown');

        let mainTableState = {
            currentPage: 1,
            itemsPerPage: 50,
            filteredData: [],
            totalPages: 1
        };

        let mixTableState = {
            currentPage: 1,
            itemsPerPage: 100,
            filteredData: [],
            totalPages: 1
        };

        const getFirstName = (fullName) => (fullName || '').split(' ')[0];

        function formatDate(date) {
            if (!date) return '';
            const d = parseDate(date);
            if (!d || isNaN(d.getTime())) return '';
            const userTimezoneOffset = d.getTimezoneOffset() * 60000;
            return new Date(d.getTime() + userTimezoneOffset).toLocaleDateString('pt-BR');
        }

        function buildInnovationSalesMaps(salesData, mainTypes, bonusTypes) {
            const mainMap = new Map(); // Map<CODCLI, Map<PRODUTO, Set<CODUSUR>>>
            const bonusMap = new Map();
            const mainSet = new Set(mainTypes);
            const bonusSet = new Set(bonusTypes);

            salesData.forEach(sale => {
                const isMain = mainSet.has(sale.TIPOVENDA);
                const isBonus = bonusSet.has(sale.TIPOVENDA);

                if (!isMain && !isBonus) return;

                const codCli = sale.CODCLI;
                const prod = sale.PRODUTO;
                const rca = sale.CODUSUR;

                if (isMain) {
                    if (!mainMap.has(codCli)) mainMap.set(codCli, new Map());
                    const clientMap = mainMap.get(codCli);
                    if (!clientMap.has(prod)) clientMap.set(prod, new Set());
                    clientMap.get(prod).add(rca);
                }

                if (isBonus) {
                    if (!bonusMap.has(codCli)) bonusMap.set(codCli, new Map());
                    const clientMap = bonusMap.get(codCli);
                    if (!clientMap.has(prod)) clientMap.set(prod, new Set());
                    clientMap.get(prod).add(rca);
                }
            });
            return { mainMap, bonusMap };
        }

        // --- MIX VIEW LOGIC ---
        const MIX_SALTY_CATEGORIES = ['CHEETOS', 'DORITOS', 'FANDANGOS', 'RUFFLES', 'TORCIDA'];
        const MIX_FOODS_CATEGORIES = ['TODDYNHO', 'TODDY ', 'QUAKER', 'KEROCOCO'];

        function getMixFilteredData(options = {}) {
            const { excludeFilter = null } = options;

            const sellersSet = new Set(selectedMixSellers);
            const supervisorsSet = new Set(selectedMixSupervisors);
            const tiposVendaSet = new Set(selectedMixTiposVenda);
            const city = document.getElementById('mix-city-filter').value.trim().toLowerCase();
            const filial = document.getElementById('mix-filial-filter').value;

            let clients = allClientsData;

            if (excludeFilter !== 'rede') {
                 if (mixRedeGroupFilter === 'com_rede') {
                    clients = clients.filter(c => c.ramo && c.ramo !== 'N/A');
                    if (selectedMixRedes.length > 0) {
                        const redeSet = new Set(selectedMixRedes);
                        clients = clients.filter(c => redeSet.has(c.ramo));
                    }
                } else if (mixRedeGroupFilter === 'sem_rede') {
                    clients = clients.filter(c => !c.ramo || c.ramo === 'N/A');
                }
            }

            if (filial !== 'ambas') {
                clients = clients.filter(c => clientLastBranch.get(c['Código']) === filial);
            }

            if (excludeFilter !== 'supervisor' && selectedMixSupervisors.length > 0) {
                const rcasSet = new Set();
                selectedMixSupervisors.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                clients = clients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            if (excludeFilter !== 'seller' && sellersSet.size > 0) {
                const rcasSet = new Set();
                sellersSet.forEach(name => {
                    const code = optimizedData.rcaCodeByName.get(name);
                    if(code) rcasSet.add(code);
                });
                clients = clients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            if (excludeFilter !== 'city' && city) {
                clients = clients.filter(c => c.cidade && c.cidade.toLowerCase() === city);
            }

            // Include only active or Americanas or not RCA 53
            clients = clients.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                return (isAmericanas || rca1 !== '53' || clientsWithSalesThisMonth.has(c['Código']));
            });

            const clientCodes = new Set(clients.map(c => c['Código']));

            const filters = {
                supervisor: supervisorsSet,
                seller: sellersSet,
                city: city,
                filial: filial,
                tipoVenda: tiposVendaSet,
                clientCodes: clientCodes
            };

            const sales = getFilteredDataFromIndices(optimizedData.indices.current, optimizedData.salesById, filters, excludeFilter);

            return { clients, sales };
        }

        function updateAllMixFilters(options = {}) {
            const { skipFilter = null } = options;

            if (skipFilter !== 'supervisor') {
                const { sales } = getMixFilteredData({ excludeFilter: 'supervisor' });
                selectedMixSupervisors = updateSupervisorFilter(document.getElementById('mix-supervisor-filter-dropdown'), document.getElementById('mix-supervisor-filter-text'), selectedMixSupervisors, sales);
            }

            const { sales: salesSeller } = getMixFilteredData({ excludeFilter: 'seller' });
            selectedMixSellers = updateSellerFilter(selectedMixSupervisors, document.getElementById('mix-vendedor-filter-dropdown'), document.getElementById('mix-vendedor-filter-text'), selectedMixSellers, salesSeller, skipFilter === 'seller');

            const { sales: salesTV } = getMixFilteredData({ excludeFilter: 'tipoVenda' });
            selectedMixTiposVenda = updateTipoVendaFilter(document.getElementById('mix-tipo-venda-filter-dropdown'), document.getElementById('mix-tipo-venda-filter-text'), selectedMixTiposVenda, salesTV, skipFilter === 'tipoVenda');

            if (skipFilter !== 'rede') {
                 const { clients: clientsRede } = getMixFilteredData({ excludeFilter: 'rede' });
                 if (mixRedeGroupFilter === 'com_rede') {
                     selectedMixRedes = updateRedeFilter(document.getElementById('mix-rede-filter-dropdown'), document.getElementById('mix-com-rede-btn-text'), selectedMixRedes, clientsRede);
                 }
            }
        }

        function handleMixFilterChange(options = {}) {
            if (window.mixUpdateTimeout) clearTimeout(window.mixUpdateTimeout);
            window.mixUpdateTimeout = setTimeout(() => {
                updateAllMixFilters(options);
                updateMixView();
            }, 10);
        }

        function resetMixFilters() {
            selectedMixSupervisors = [];
            document.getElementById('mix-city-filter').value = '';
            document.getElementById('mix-filial-filter').value = 'ambas';
            selectedMixSellers = [];
            selectedMixTiposVenda = [];
            selectedMixRedes = [];
            mixRedeGroupFilter = '';

            const redeGroupContainer = document.getElementById('mix-rede-group-container');
            redeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            redeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            document.getElementById('mix-rede-filter-dropdown').classList.add('hidden');

            updateAllMixFilters();
            updateMixView();
        }

        function updateMixView() {
            mixRenderId++;
            const currentRenderId = mixRenderId;

            const { clients, sales } = getMixFilteredData();
            // const activeClientCodes = new Set(clients.map(c => c['Código'])); // Not used if iterating clients array

            // Show Loading
            document.getElementById('mix-table-body').innerHTML = '<tr><td colspan="13" class="text-center p-8"><svg class="animate-spin h-8 w-8 text-teal-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></td></tr>';

            // 1. Agregar Valor Líquido por Produto por Cliente (Sync - O(Sales))
            const clientProductNetValues = new Map(); // Map<CODCLI, Map<PRODUTO, NetValue>>
            const clientProductDesc = new Map(); // Map<PRODUTO, Descricao> (Cache)

            sales.forEach(s => {
                if (!s.CODCLI || !s.PRODUTO) return;

                if (!clientProductNetValues.has(s.CODCLI)) {
                    clientProductNetValues.set(s.CODCLI, new Map());
                }
                const clientMap = clientProductNetValues.get(s.CODCLI);
                const currentVal = clientMap.get(s.PRODUTO) || 0;
                clientMap.set(s.PRODUTO, currentVal + (Number(s.VLVENDA) || 0));

                if (!clientProductDesc.has(s.PRODUTO)) {
                    clientProductDesc.set(s.PRODUTO, s.DESCRICAO);
                }
            });

            // 2. Determinar Categorias Positivadas por Cliente
            // Uma categoria é positivada se o cliente comprou Pelo MENOS UM produto dela com valor líquido > 1
            const clientPositivatedCategories = new Map(); // Map<CODCLI, Set<CategoryName>>

            // Sync Loop for Map aggregation is fast enough
            clientProductNetValues.forEach((productsMap, codCli) => {
                const positivatedCats = new Set();

                productsMap.forEach((netValue, prodCode) => {
                    if (netValue > 1) {
                        const desc = normalize(clientProductDesc.get(prodCode) || '');

                        // Checar Salty
                        MIX_SALTY_CATEGORIES.forEach(cat => {
                            if (desc.includes(cat)) positivatedCats.add(cat);
                        });
                        // Checar Foods
                        MIX_FOODS_CATEGORIES.forEach(cat => {
                            if (desc.includes(cat)) positivatedCats.add(cat);
                        });
                    }
                });
                clientPositivatedCategories.set(codCli, positivatedCats);
            });

            let positivadosSalty = 0;
            let positivadosFoods = 0;
            let positivadosBoth = 0;

            const tableData = [];

            // ASYNC CHUNKED PROCESSING for Clients
            runAsyncChunked(clients, (client) => {
                const codcli = client['Código'];
                const positivatedCats = clientPositivatedCategories.get(codcli) || new Set();

                // Determine Status based on "Buying ALL" (Strict Positive)
                const hasSalty = MIX_SALTY_CATEGORIES.every(b => positivatedCats.has(b));
                const hasFoods = MIX_FOODS_CATEGORIES.every(b => positivatedCats.has(b));

                if (hasSalty) positivadosSalty++;
                if (hasFoods) positivadosFoods++;
                if (hasSalty && hasFoods) positivadosBoth++;

                const missing = [];
                // Detailed missing analysis for Salty
                MIX_SALTY_CATEGORIES.forEach(b => { if(!positivatedCats.has(b)) missing.push(b); });
                // Detailed missing analysis for Foods
                MIX_FOODS_CATEGORIES.forEach(b => { if(!positivatedCats.has(b)) missing.push(b); });

                const missingText = missing.length > 0 ? missing.join(', ') : '';

                // Resolve Vendor Name
                const rcaCode = (client.rcas && client.rcas.length > 0) ? client.rcas[0] : null;
                let vendorName = 'N/A';
                if (rcaCode) {
                    vendorName = optimizedData.rcaNameByCode.get(rcaCode) || rcaCode;
                } else {
                    vendorName = 'INATIVOS';
                }

                const rowData = {
                    codcli: codcli,
                    name: client.fantasia || client.razaoSocial,
                    city: client.cidade || client.CIDADE || client['Nome da Cidade'] || 'N/A',
                    vendedor: vendorName,
                    hasSalty: hasSalty,
                    hasFoods: hasFoods,
                    brands: positivatedCats,
                    missingText: missingText,
                    score: missing.length
                };
                tableData.push(rowData);
            }, () => {
                // --- ON COMPLETE (Render) ---
                if (currentRenderId !== mixRenderId) return;

                let baseClientCount;
                const kpiTitleEl = document.getElementById('mix-kpi-title');

                if (mixKpiMode === 'atendidos') {
                    baseClientCount = getPositiveClientsWithNewLogic(sales);
                    if (kpiTitleEl) kpiTitleEl.textContent = 'Clientes Atendidos';
                } else {
                    baseClientCount = clients.length;
                    if (kpiTitleEl) kpiTitleEl.textContent = 'Total Clientes (Filtro)';
                }

                const saltyPct = baseClientCount > 0 ? (positivadosSalty / baseClientCount) * 100 : 0;
                const foodsPct = baseClientCount > 0 ? (positivadosFoods / baseClientCount) * 100 : 0;
                const bothPct = baseClientCount > 0 ? (positivadosBoth / baseClientCount) * 100 : 0;

                // Update KPIs
                document.getElementById('mix-total-clients-kpi').textContent = baseClientCount.toLocaleString('pt-BR');
                document.getElementById('mix-salty-kpi').textContent = `${saltyPct.toFixed(1)}%`;
                document.getElementById('mix-salty-count-kpi').textContent = `${positivadosSalty} clientes`;
                document.getElementById('mix-foods-kpi').textContent = `${foodsPct.toFixed(1)}%`;
                document.getElementById('mix-foods-count-kpi').textContent = `${positivadosFoods} clientes`;
                document.getElementById('mix-both-kpi').textContent = `${bothPct.toFixed(1)}%`;
                document.getElementById('mix-both-count-kpi').textContent = `${positivadosBoth} clientes`;

                // Charts
                const distributionData = [
                    positivadosBoth,
                    positivadosSalty - positivadosBoth,
                    positivadosFoods - positivadosBoth,
                    baseClientCount - (positivadosSalty + positivadosFoods - positivadosBoth)
                ];

                createChart('mixDistributionChart', 'doughnut', ['Mix Ideal (Ambos)', 'Só Salty', 'Só Foods', 'Nenhum'], distributionData, {
                    backgroundColor: ['#a855f7', '#14b8a6', '#f59e0b', '#475569'],
                    plugins: { legend: { position: 'right' } }
                });

                // Seller Efficiency Chart
                const sellerStats = {};
                tableData.forEach(row => {
                    const seller = row.vendedor;
                    if (!sellerStats[seller]) sellerStats[seller] = { total: 0, both: 0, salty: 0, foods: 0 };
                    sellerStats[seller].total++;
                    if (row.hasSalty && row.hasFoods) sellerStats[seller].both++;
                    if (row.hasSalty) sellerStats[seller].salty++;
                    if (row.hasFoods) sellerStats[seller].foods++;
                });

                const sortedSellers = Object.entries(sellerStats)
                    .sort(([,a], [,b]) => b.both - a.both)
                    .slice(0, 10);

                createChart('mixSellerChart', 'bar', sortedSellers.map(([name]) => getFirstName(name)),
                    [
                        { label: 'Mix Ideal', data: sortedSellers.map(([,s]) => s.both), backgroundColor: '#a855f7' },
                        { label: 'Salty Total', data: sortedSellers.map(([,s]) => s.salty), backgroundColor: '#14b8a6', hidden: true },
                        { label: 'Foods Total', data: sortedSellers.map(([,s]) => s.foods), backgroundColor: '#f59e0b', hidden: true }
                    ],
                    { scales: { x: { stacked: false }, y: { stacked: false } } }
                );

                // Render Table with Detailed Columns
                tableData.sort((a, b) => {
                    // Sort by City (Alphabetical), then by Client Name
                    const cityA = (a.city || '').toLowerCase();
                    const cityB = (b.city || '').toLowerCase();
                    if (cityA < cityB) return -1;
                    if (cityA > cityB) return 1;
                    return (a.name || '').localeCompare(b.name || '');
                });

                mixTableDataForExport = tableData;

                mixTableState.filteredData = tableData;
                mixTableState.totalPages = Math.ceil(tableData.length / mixTableState.itemsPerPage);
                if (mixTableState.currentPage > mixTableState.totalPages && mixTableState.totalPages > 0) {
                    mixTableState.currentPage = mixTableState.totalPages;
                } else if (mixTableState.totalPages === 0) {
                     mixTableState.currentPage = 1;
                }

                const startIndex = (mixTableState.currentPage - 1) * mixTableState.itemsPerPage;
                const endIndex = startIndex + mixTableState.itemsPerPage;
                const pageData = tableData.slice(startIndex, endIndex);

                const checkIcon = `<svg class="w-4 h-4 text-green-400 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
                const dashIcon = `<span class="text-slate-600 text-xs">-</span>`;

                const xIcon = `<svg class="w-3 h-3 text-red-500 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;

                let tableHTML = pageData.map(row => {
                    let saltyCols = MIX_SALTY_CATEGORIES.map(b => `<td class="px-1 py-2 text-center border-l border-slate-500">${row.brands.has(b) ? checkIcon : xIcon}</td>`).join('');
                    let foodsCols = MIX_FOODS_CATEGORIES.map(b => `<td class="px-1 py-2 text-center border-l border-slate-500">${row.brands.has(b) ? checkIcon : xIcon}</td>`).join('');

                    return `
                    <tr class="hover:bg-slate-700/50 border-b border-slate-500 last:border-0">
                        <td class="px-2 py-2 font-medium text-slate-300 text-xs">${row.codcli}</td>
                        <td class="px-2 py-2 text-xs truncate max-w-[150px]" title="${row.name}">${row.name}</td>
                        <td class="px-2 py-2 text-xs text-slate-300 truncate max-w-[100px]">${row.city}</td>
                        <td class="px-2 py-2 text-xs text-slate-400 truncate max-w-[100px]">${getFirstName(row.vendedor)}</td>
                        ${saltyCols}
                        ${foodsCols}
                    </tr>
                `}).join('');

                // Append Footer with Totals
                tableHTML += `
                    <tr class="bg-slate-800 font-bold border-t-2 border-slate-500 text-xs sticky bottom-0 z-20">
                        <td colspan="4" class="px-2 py-3 text-right text-white">TOTAL POSITIVADOS:</td>
                        <td colspan="${MIX_SALTY_CATEGORIES.length}" class="px-2 py-3 text-center text-teal-400 text-sm border-l border-slate-500">${positivadosSalty}</td>
                        <td colspan="${MIX_FOODS_CATEGORIES.length}" class="px-2 py-3 text-center text-yellow-400 text-sm border-l border-slate-500">${positivadosFoods}</td>
                    </tr>
                `;

                document.getElementById('mix-table-body').innerHTML = tableHTML;

                const controls = document.getElementById('mix-pagination-controls');
                const infoText = document.getElementById('mix-page-info-text');
                const prevBtn = document.getElementById('mix-prev-page-btn');
                const nextBtn = document.getElementById('mix-next-page-btn');

                if (tableData.length > 0 && mixTableState.totalPages > 1) {
                    infoText.textContent = `Página ${mixTableState.currentPage} de ${mixTableState.totalPages} (Total: ${tableData.length} clientes)`;
                    prevBtn.disabled = mixTableState.currentPage === 1;
                    nextBtn.disabled = mixTableState.currentPage === mixTableState.totalPages;
                    controls.classList.remove('hidden');
                } else {
                    controls.classList.add('hidden');
                }
            }, () => currentRenderId !== mixRenderId);
        }

        async function exportMixPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('landscape');

            const supervisor = document.getElementById('mix-supervisor-filter-text').textContent;
            const vendedor = document.getElementById('mix-vendedor-filter-text').textContent;
            const city = document.getElementById('mix-city-filter').value.trim();
            const generationDate = new Date().toLocaleString('pt-BR');

            doc.setFontSize(18);
            doc.text('Relatório de Detalhado - Mix Salty & Foods', 14, 22);
            doc.setFontSize(10);
            doc.setTextColor(10);
            doc.text(`Data de Emissão: ${generationDate}`, 14, 30);
            doc.text(`Filtros: Supervisor: ${supervisor} | Vendedor: ${vendedor} | Cidade: ${city || 'Todas'}`, 14, 36);

            // Determine dynamic columns
            const saltyCols = MIX_SALTY_CATEGORIES.map(c => c.substring(0, 8)); // Truncate headers
            const foodsCols = MIX_FOODS_CATEGORIES.map(c => c.substring(0, 8));

            const head = [['Cód', 'Cliente', 'Cidade', 'Vendedor', ...saltyCols, ...foodsCols]];

            const body = mixTableDataForExport.map(row => {
                const saltyCells = MIX_SALTY_CATEGORIES.map(b => row.brands.has(b) ? 'OK' : 'X');
                const foodsCells = MIX_FOODS_CATEGORIES.map(b => row.brands.has(b) ? 'OK' : 'X');
                return [
                    row.codcli,
                    row.name,
                    row.city || '',
                    getFirstName(row.vendedor),
                    ...saltyCells,
                    ...foodsCells
                ];
            });

            // Calculate Totals for Footer
            let totalSalty = 0;
            let totalFoods = 0;
            mixTableDataForExport.forEach(row => {
                if(row.hasSalty) totalSalty++;
                if(row.hasFoods) totalFoods++;
            });

            const footerRow = [
                { content: 'TOTAL POSITIVADOS:', colSpan: 4, styles: { halign: 'right', fontStyle: 'bold', fontSize: 12, textColor: [255, 255, 255], fillColor: [50, 50, 50] } },
                { content: String(totalSalty), colSpan: MIX_SALTY_CATEGORIES.length, styles: { halign: 'center', fontStyle: 'bold', fontSize: 12, textColor: [45, 212, 191], fillColor: [50, 50, 50] } }, // Teal-400
                { content: String(totalFoods), colSpan: MIX_FOODS_CATEGORIES.length, styles: { halign: 'center', fontStyle: 'bold', fontSize: 12, textColor: [250, 204, 21], fillColor: [50, 50, 50] } } // Yellow-400
            ];

            body.push(footerRow);

            doc.autoTable({
                head: head,
                body: body,
                startY: 45,
                theme: 'grid',
                styles: { fontSize: 6, cellPadding: 1, textColor: [0, 0, 0], halign: 'center' },
                headStyles: { fillColor: [20, 184, 166], textColor: 255, fontStyle: 'bold', fontSize: 8 },
                columnStyles: {
                    0: { halign: 'left', cellWidth: 15 },
                    1: { halign: 'left', cellWidth: 40 },
                    2: { halign: 'left', cellWidth: 25 },
                    3: { halign: 'left', cellWidth: 20 },
                },
                didParseCell: function(data) {
                    if (data.section === 'body') {
                        // Colorize OK/X cells
                        if (data.cell.raw === 'OK') {
                            data.cell.styles.textColor = [0, 128, 0]; // Stronger Green
                            data.cell.styles.fontStyle = 'bold';
                        }
                        if (data.cell.raw === 'X') {
                            data.cell.styles.textColor = [220, 0, 0]; // Stronger Red
                            data.cell.styles.fontStyle = 'bold';
                        }
                    }
                }
            });

            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(9);
                doc.setTextColor(10);
                doc.text(`Página ${i} de ${pageCount}`, doc.internal.pageSize.width / 2, doc.internal.pageSize.height - 10, { align: 'center' });
            }

            let fileNameParam = 'geral';
            if (selectedMixSellers.length === 1) {
                fileNameParam = getFirstName(selectedMixSellers[0]);
            } else if (city) {
                fileNameParam = city;
            }
            const safeFileNameParam = fileNameParam.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            doc.save(`relatorio_mix_detalhado_${safeFileNameParam}_${new Date().toISOString().slice(0,10)}.pdf`);
        }

        // --- GOALS VIEW LOGIC ---

        function exportGoalsSvXLSX() {
            if (typeof XLSX === 'undefined') {
                alert("Erro: Biblioteca XLSX não carregada. Verifique sua conexão com a internet.");
                return;
            }

            if (!currentGoalsSvData || currentGoalsSvData.length === 0) {
                try { updateGoalsSvView(); } catch (e) { console.error(e); }
                if (!currentGoalsSvData || currentGoalsSvData.length === 0) {
                    alert("Sem dados para exportar.");
                    return;
                }
            }

            const wb = XLSX.utils.book_new();
            const ws_data = [];

            // Estilos
            const headerStyle = { font: { bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "0F172A" } }, alignment: { horizontal: "center", vertical: "center" }, border: { bottom: { style: "thin", color: { rgb: "475569" } } } };
            const subHeaderStyle = { font: { bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "1E293B" } }, alignment: { horizontal: "center", vertical: "center" }, border: { bottom: { style: "thin", color: { rgb: "334155" } } } };
            const editableStyle = { fill: { fgColor: { rgb: "FEF9C3" } }, border: { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } } }; // Light Yellow
            const readOnlyStyle = { fill: { fgColor: { rgb: "F1F5F9" } } }; // Light Slate
            const totalRowStyle = { font: { bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "334155" } }, border: { top: { style: "thick" } } };
            const grandTotalStyle = { font: { bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "0F172A" } }, border: { top: { style: "thick" } } };

            // Format Strings
            const fmtMoney = "\"R$ \"#,##0.00";
            const fmtVol = "0.00 \"Kg\"";
            const fmtInt = "0";
            const fmtDec1 = "0.0";

            // Cores de Grupo
            const colorMap = {
                'total_elma': { fgColor: { rgb: "14B8A6" } }, // Teal
                'total_foods': { fgColor: { rgb: "F59E0B" } }, // Amber/Yellow
                'tonelada_elma': { fgColor: { rgb: "F97316" } }, // Orange
                'tonelada_foods': { fgColor: { rgb: "F97316" } },
                'mix_salty': { fgColor: { rgb: "14B8A6" } },
                'mix_foods': { fgColor: { rgb: "F59E0B" } },
                'geral': { fgColor: { rgb: "3B82F6" } }, // Blue
                'pedev': { fgColor: { rgb: "EC4899" } } // Pink
            };

            const createCell = (v, s = {}, z = null) => {
                const cell = { v, t: 'n' };
                if (z) {
                    cell.z = z;
                    cell.s = { ...s, numFmt: z };
                } else {
                    cell.s = s;
                }
                if (typeof v === 'string') cell.t = 's';
                return cell;
            };

            // --- 1. Headers ---
            const row1 = [createCell("CÓD", headerStyle), createCell("VENDEDOR", headerStyle)];
            const merges = [{ s: { r: 0, c: 0 }, e: { r: 2, c: 0 } }, { s: { r: 0, c: 1 }, e: { r: 2, c: 1 } }];
            let colIdx = 2;

            const svColumns = [
                { id: 'total_elma', label: 'TOTAL ELMA', type: 'standard', isAgg: true },
                { id: '707', label: 'EXTRUSADOS', type: 'standard' },
                { id: '708', label: 'NÃO EXTRUSADOS', type: 'standard' },
                { id: '752', label: 'TORCIDA', type: 'standard' },
                { id: 'tonelada_elma', label: 'KG ELMA', type: 'tonnage', isAgg: true },
                { id: 'mix_salty', label: 'MIX SALTY', type: 'mix', isAgg: true },
                { id: 'total_foods', label: 'TOTAL FOODS', type: 'standard', isAgg: true },
                { id: '1119_TODDYNHO', label: 'TODDYNHO', type: 'standard' },
                { id: '1119_TODDY', label: 'TODDY', type: 'standard' },
                { id: '1119_QUAKER_KEROCOCO', label: 'QUAKER / KEROCOCO', type: 'standard' },
                { id: 'tonelada_foods', label: 'KG FOODS', type: 'tonnage', isAgg: true },
                { id: 'mix_foods', label: 'MIX FOODS', type: 'mix', isAgg: true },
                { id: 'geral', label: 'GERAL', type: 'geral', isAgg: true },
                { id: 'pedev', label: 'AUDITORIA PEDEV', type: 'pedev', isAgg: true }
            ];

            const colMap = {};

            svColumns.forEach(col => {
                colMap[col.id] = colIdx;
                const style = { ...headerStyle };
                if (colorMap[col.id]) style.fill = colorMap[col.id]; // Apply Group Color

                row1.push(createCell(col.label, style));
                let span = 0;
                if (col.type === 'standard') span = 4;
                else if (col.type === 'tonnage' || col.type === 'mix') span = 3;
                else if (col.type === 'geral') span = 4;
                else if (col.type === 'pedev') span = 1;

                merges.push({ s: { r: 0, c: colIdx }, e: { r: 0, c: colIdx + span - 1 } });
                for (let k = 1; k < span; k++) row1.push(createCell("", style));
                colIdx += span;
            });
            ws_data.push(row1);

            // Row 2: Metric Names
            const row2 = [createCell("", headerStyle), createCell("", headerStyle)];
            svColumns.forEach(col => {
                const style = { ...subHeaderStyle, font: { bold: true, color: { rgb: "FFFFFF" } } };
                if (col.type === 'standard') {
                    row2.push(createCell("FATURAMENTO", style), createCell("", style), createCell("POSITIVAÇÃO", style), createCell("", style));
                    merges.push({ s: { r: 1, c: colMap[col.id] }, e: { r: 1, c: colMap[col.id] + 1 } });
                    merges.push({ s: { r: 1, c: colMap[col.id] + 2 }, e: { r: 1, c: colMap[col.id] + 3 } });
                } else if (col.type === 'tonnage') {
                    row2.push(createCell("MÉDIA TRIM.", style), createCell("META KG", style), createCell("", style));
                    merges.push({ s: { r: 1, c: colMap[col.id] + 1 }, e: { r: 1, c: colMap[col.id] + 2 } });
                } else if (col.type === 'mix') {
                    row2.push(createCell("MÉDIA TRIM.", style), createCell("META MIX", style), createCell("", style));
                    merges.push({ s: { r: 1, c: colMap[col.id] + 1 }, e: { r: 1, c: colMap[col.id] + 2 } });
                } else if (col.type === 'geral') {
                    row2.push(createCell("FATURAMENTO", style), createCell("", style), createCell("TONELADA", style), createCell("POSITIVAÇÃO", style));
                    merges.push({ s: { r: 1, c: colMap[col.id] }, e: { r: 1, c: colMap[col.id] + 1 } });
                } else {
                    row2.push(createCell("META", style));
                }
            });
            ws_data.push(row2);

            // Row 3: Subtitles
            const row3 = [createCell("", subHeaderStyle), createCell("", subHeaderStyle)];
            svColumns.forEach(col => {
                if (col.type === 'standard') {
                    row3.push(createCell("Meta", subHeaderStyle), createCell("Ajuste", subHeaderStyle), createCell("Meta", subHeaderStyle), createCell("Ajuste", subHeaderStyle));
                } else if (col.type === 'tonnage') {
                    row3.push(createCell("Volume", subHeaderStyle), createCell("Volume", subHeaderStyle), createCell("Ajuste", subHeaderStyle));
                } else if (col.type === 'mix') {
                    row3.push(createCell("Qtd", subHeaderStyle), createCell("Meta", subHeaderStyle), createCell("Ajuste", subHeaderStyle));
                } else if (col.type === 'geral') {
                    row3.push(createCell("Média Trim.", subHeaderStyle), createCell("Meta", subHeaderStyle), createCell("Meta", subHeaderStyle), createCell("Meta", subHeaderStyle));
                } else {
                    row3.push(createCell("", subHeaderStyle));
                }
            });
            ws_data.push(row3);

            // --- 2. Data Rows ---
            let currentRow = 3;
            const colCellsForGrandTotal = {};
            svColumns.forEach(c => colCellsForGrandTotal[c.id] = { fat: [], pos: [], vol: [], mix: [], avg: [] });

            currentGoalsSvData.forEach(sup => {
                const sellers = sup.sellers;
                const colCellsForSupTotal = {};
                svColumns.forEach(c => colCellsForSupTotal[c.id] = { fat: [], pos: [], vol: [], mix: [], avg: [] });

                sellers.forEach(seller => {
                    const rowData = [createCell(seller.code), createCell(seller.name)];

                    svColumns.forEach(col => {
                        const d = seller.data[col.id] || { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgMix: 0, metaMix: 0, avgFat: 0 };
                        const cIdx = colMap[col.id];
                        const excelRow = currentRow + 1;
                        const getColLet = (idx) => XLSX.utils.encode_col(idx);

                        // Highlight Logic
                        const isEditable = !col.isAgg; // Base columns are editable (Yellow)
                        const cellStyle = isEditable ? editableStyle : readOnlyStyle;
                        const aggCellStyle = readOnlyStyle; // Aggregated columns (Light Grey)

                        if (col.type === 'standard') {
                            rowData.push(createCell(d.metaFat, readOnlyStyle, fmtMoney));

                            // Formula for Aggregate Logic
                            if (col.id === 'total_elma' || col.id === 'total_foods') {
                                const ids = col.id === 'total_elma' ? ['707', '708', '752'] : ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];
                                const compCols = ids.map(id => colMap[id] + 1);
                                const compColsPos = ids.map(id => colMap[id] + 3);
                                const formulaFat = compCols.map(c => `${getColLet(c)}${excelRow}`).join("+");

                                rowData.push({ t: 'n', v: d.metaFat, f: formulaFat, s: { ...aggCellStyle, numFmt: fmtMoney }, z: fmtMoney });
                                rowData.push(createCell(d.metaPos, readOnlyStyle, fmtInt));
                                // Static value for Positivation (Unique Clients), no formula
                                rowData.push(createCell(d.metaPos, aggCellStyle, fmtInt));
                            } else {
                                // Editable Cells
                                rowData.push(createCell(d.metaFat, cellStyle, fmtMoney));
                                rowData.push(createCell(d.metaPos, readOnlyStyle, fmtInt));
                                rowData.push(createCell(d.metaPos, cellStyle, fmtInt));
                            }

                            colCellsForSupTotal[col.id].fat.push(`${getColLet(cIdx + 1)}${excelRow}`);
                            colCellsForSupTotal[col.id].pos.push(`${getColLet(cIdx + 3)}${excelRow}`);

                        } else if (col.type === 'tonnage') {
                            rowData.push(createCell(d.avgVol, readOnlyStyle, fmtVol));
                            rowData.push(createCell(d.metaVol, readOnlyStyle, fmtVol));
                            rowData.push(createCell(d.metaVol, isEditable ? cellStyle : aggCellStyle, fmtVol));
                            colCellsForSupTotal[col.id].vol.push(`${getColLet(cIdx + 2)}${excelRow}`);
                            colCellsForSupTotal[col.id].avg.push(`${getColLet(cIdx)}${excelRow}`);

                        } else if (col.type === 'mix') {
                            rowData.push(createCell(d.avgMix, readOnlyStyle, fmtDec1));
                            rowData.push(createCell(d.metaMix, readOnlyStyle, fmtInt));
                            rowData.push(createCell(d.metaMix, isEditable ? cellStyle : aggCellStyle, fmtInt));
                            colCellsForSupTotal[col.id].mix.push(`${getColLet(cIdx + 2)}${excelRow}`);
                            colCellsForSupTotal[col.id].avg.push(`${getColLet(cIdx)}${excelRow}`);

                        } else if (col.type === 'geral') {
                            const elmaIdx = colMap['total_elma'];
                            const foodsIdx = colMap['total_foods'];
                            const elmaTonIdx = colMap['tonelada_elma'];
                            const foodsTonIdx = colMap['tonelada_foods'];

                            const fFat = `${getColLet(elmaIdx + 1)}${excelRow}+${getColLet(foodsIdx + 1)}${excelRow}`;
                            const fTon = `${getColLet(elmaTonIdx + 2)}${excelRow}+${getColLet(foodsTonIdx + 2)}${excelRow}`;

                            // REMOVED Formula for Positivation. Used static value instead.
                            // const fPos = `${getColLet(elmaIdx + 3)}${excelRow}+${getColLet(foodsIdx + 3)}${excelRow}`;

                            rowData.push(createCell(d.avgFat, readOnlyStyle, fmtMoney));
                            rowData.push({ t: 'n', v: d.metaFat, f: fFat, s: { ...aggCellStyle, numFmt: fmtMoney }, z: fmtMoney });
                            rowData.push({ t: 'n', v: d.metaVol, f: fTon, s: { ...aggCellStyle, numFmt: fmtVol }, z: fmtVol });
                            // Use static adjusted value for Positivation (PEPSICO_ALL)
                            rowData.push(createCell(d.metaPos, aggCellStyle, fmtInt));

                            colCellsForSupTotal[col.id].fat.push(`${getColLet(cIdx + 1)}${excelRow}`);
                            colCellsForSupTotal[col.id].vol.push(`${getColLet(cIdx + 2)}${excelRow}`);
                            colCellsForSupTotal[col.id].pos.push(`${getColLet(cIdx + 3)}${excelRow}`);
                            colCellsForSupTotal[col.id].avg.push(`${getColLet(cIdx)}${excelRow}`);

                        } else if (col.type === 'pedev') {
                            const elmaIdx = colMap['total_elma'];
                            const fPedev = `ROUND(${getColLet(elmaIdx + 3)}${excelRow}*0.9, 0)`;
                            rowData.push({ t: 'n', v: d.metaPos, f: fPedev, s: { ...aggCellStyle, numFmt: fmtInt }, z: fmtInt });
                            colCellsForSupTotal[col.id].pos.push(`${getColLet(cIdx)}${excelRow}`);
                        }
                    });
                    ws_data.push(rowData);
                    currentRow++;
                });

                // Supervisor Total Row
                const supRowData = [createCell(sup.code, totalRowStyle), createCell(sup.name.toUpperCase(), totalRowStyle)];
                const excelSupRow = currentRow + 1;

                svColumns.forEach(col => {
                    const cIdx = colMap[col.id];
                    const getColLet = (idx) => XLSX.utils.encode_col(idx);

                    if (col.type === 'standard') {
                        const rangeFat = colCellsForSupTotal[col.id].fat;
                        const fFatRange = rangeFat.length > 0 ? `SUM(${rangeFat[0]}:${rangeFat[rangeFat.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fFatRange, s: { ...totalRowStyle, numFmt: fmtMoney }, z: fmtMoney });
                        supRowData.push({ t: 'n', v: 0, f: fFatRange, s: { ...totalRowStyle, numFmt: fmtMoney }, z: fmtMoney });

                        const rangePos = colCellsForSupTotal[col.id].pos;
                        const fPosRange = rangePos.length > 0 ? `SUM(${rangePos[0]}:${rangePos[rangePos.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fPosRange, s: { ...totalRowStyle, numFmt: fmtInt }, z: fmtInt });
                        supRowData.push({ t: 'n', v: 0, f: fPosRange, s: { ...totalRowStyle, numFmt: fmtInt }, z: fmtInt });

                        colCellsForGrandTotal[col.id].fat.push(`${getColLet(cIdx+1)}${excelSupRow}`);
                        colCellsForGrandTotal[col.id].pos.push(`${getColLet(cIdx+3)}${excelSupRow}`);

                    } else if (col.type === 'tonnage') {
                        const rangeAvg = colCellsForSupTotal[col.id].avg;
                        const fAvgRange = rangeAvg.length > 0 ? `SUM(${rangeAvg[0]}:${rangeAvg[rangeAvg.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fAvgRange, s: { ...totalRowStyle, numFmt: fmtVol }, z: fmtVol });

                        const rangeVol = colCellsForSupTotal[col.id].vol;
                        const fVolRange = rangeVol.length > 0 ? `SUM(${rangeVol[0]}:${rangeVol[rangeVol.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fVolRange, s: { ...totalRowStyle, numFmt: fmtVol }, z: fmtVol });
                        supRowData.push({ t: 'n', v: 0, f: fVolRange, s: { ...totalRowStyle, numFmt: fmtVol }, z: fmtVol });

                        colCellsForGrandTotal[col.id].vol.push(`${getColLet(cIdx+2)}${excelSupRow}`);
                        colCellsForGrandTotal[col.id].avg.push(`${getColLet(cIdx)}${excelSupRow}`);

                    } else if (col.type === 'mix') {
                        const rangeAvg = colCellsForSupTotal[col.id].avg;
                        const fAvgRange = rangeAvg.length > 0 ? `SUM(${rangeAvg[0]}:${rangeAvg[rangeAvg.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fAvgRange, s: { ...totalRowStyle, numFmt: fmtDec1 }, z: fmtDec1 });

                        const rangeMix = colCellsForSupTotal[col.id].mix;
                        const fMixRange = rangeMix.length > 0 ? `SUM(${rangeMix[0]}:${rangeMix[rangeMix.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fMixRange, s: { ...totalRowStyle, numFmt: fmtInt }, z: fmtInt });
                        supRowData.push({ t: 'n', v: 0, f: fMixRange, s: { ...totalRowStyle, numFmt: fmtInt }, z: fmtInt });

                        colCellsForGrandTotal[col.id].mix.push(`${getColLet(cIdx+2)}${excelSupRow}`);
                        colCellsForGrandTotal[col.id].avg.push(`${getColLet(cIdx)}${excelSupRow}`);

                    } else if (col.type === 'geral') {
                        const rangeAvg = colCellsForSupTotal[col.id].avg;
                        const fAvgRange = rangeAvg.length > 0 ? `SUM(${rangeAvg[0]}:${rangeAvg[rangeAvg.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fAvgRange, s: { ...totalRowStyle, numFmt: fmtMoney }, z: fmtMoney });

                        const rangeFat = colCellsForSupTotal[col.id].fat;
                        const fFatRange = rangeFat.length > 0 ? `SUM(${rangeFat[0]}:${rangeFat[rangeFat.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fFatRange, s: { ...totalRowStyle, numFmt: fmtMoney }, z: fmtMoney });

                        const rangeVol = colCellsForSupTotal[col.id].vol;
                        const fVolRange = rangeVol.length > 0 ? `SUM(${rangeVol[0]}:${rangeVol[rangeVol.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fVolRange, s: { ...totalRowStyle, numFmt: fmtVol }, z: fmtVol });

                        const rangePos = colCellsForSupTotal[col.id].pos;
                        const fPosRange = rangePos.length > 0 ? `SUM(${rangePos[0]}:${rangePos[rangePos.length-1]})` : "0";
                        supRowData.push({ t: 'n', v: 0, f: fPosRange, s: { ...totalRowStyle, numFmt: fmtInt }, z: fmtInt });

                        colCellsForGrandTotal[col.id].fat.push(`${getColLet(cIdx+1)}${excelSupRow}`);
                        colCellsForGrandTotal[col.id].vol.push(`${getColLet(cIdx+2)}${excelSupRow}`);
                        colCellsForGrandTotal[col.id].pos.push(`${getColLet(cIdx+3)}${excelSupRow}`);
                        colCellsForGrandTotal[col.id].avg.push(`${getColLet(cIdx)}${excelSupRow}`);

                    } else if (col.type === 'pedev') {
                        const elmaIdx = colMap['total_elma'];
                        const fPedev = `ROUND(${getColLet(elmaIdx + 3)}${excelSupRow}*0.9, 0)`;
                        supRowData.push({ t: 'n', v: 0, f: fPedev, s: { ...totalRowStyle, numFmt: fmtInt }, z: fmtInt });
                        colCellsForGrandTotal[col.id].pos.push(`${getColLet(cIdx)}${excelSupRow}`);
                    }
                });

                ws_data.push(supRowData);
                currentRow++;
            });

            // Grand Total Row
            const grandRowData = [createCell("GV", grandTotalStyle), createCell("GERAL PRIME", grandTotalStyle)];
            svColumns.forEach(col => {
                if (col.type === 'standard') {
                    const rangeFat = colCellsForGrandTotal[col.id].fat;
                    const fFat = rangeFat.length > 0 ? rangeFat.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fFat, s: { ...grandTotalStyle, numFmt: fmtMoney }, z: fmtMoney });
                    grandRowData.push({ t: 'n', v: 0, f: fFat, s: { ...grandTotalStyle, numFmt: fmtMoney }, z: fmtMoney });

                    const rangePos = colCellsForGrandTotal[col.id].pos;
                    const fPos = rangePos.length > 0 ? rangePos.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fPos, s: { ...grandTotalStyle, numFmt: fmtInt }, z: fmtInt });
                    grandRowData.push({ t: 'n', v: 0, f: fPos, s: { ...grandTotalStyle, numFmt: fmtInt }, z: fmtInt });

                } else if (col.type === 'tonnage') {
                    const rangeAvg = colCellsForGrandTotal[col.id].avg;
                    const fAvg = rangeAvg.length > 0 ? rangeAvg.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fAvg, s: { ...grandTotalStyle, numFmt: fmtVol }, z: fmtVol });

                    const rangeVol = colCellsForGrandTotal[col.id].vol;
                    const fVol = rangeVol.length > 0 ? rangeVol.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fVol, s: { ...grandTotalStyle, numFmt: fmtVol }, z: fmtVol });
                    grandRowData.push({ t: 'n', v: 0, f: fVol, s: { ...grandTotalStyle, numFmt: fmtVol }, z: fmtVol });

                } else if (col.type === 'mix') {
                    const rangeAvg = colCellsForGrandTotal[col.id].avg;
                    const fAvg = rangeAvg.length > 0 ? rangeAvg.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fAvg, s: { ...grandTotalStyle, numFmt: fmtDec1 }, z: fmtDec1 });

                    const rangeMix = colCellsForGrandTotal[col.id].mix;
                    const fMix = rangeMix.length > 0 ? rangeMix.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fMix, s: { ...grandTotalStyle, numFmt: fmtInt }, z: fmtInt });
                    grandRowData.push({ t: 'n', v: 0, f: fMix, s: { ...grandTotalStyle, numFmt: fmtInt }, z: fmtInt });

                } else if (col.type === 'geral') {
                    const rangeAvg = colCellsForGrandTotal[col.id].avg;
                    const fAvg = rangeAvg.length > 0 ? rangeAvg.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fAvg, s: { ...grandTotalStyle, numFmt: fmtMoney }, z: fmtMoney });

                    const rangeFat = colCellsForGrandTotal[col.id].fat;
                    const fFat = rangeFat.length > 0 ? rangeFat.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fFat, s: { ...grandTotalStyle, numFmt: fmtMoney }, z: fmtMoney });

                    const rangeVol = colCellsForGrandTotal[col.id].vol;
                    const fVol = rangeVol.length > 0 ? rangeVol.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fVol, s: { ...grandTotalStyle, numFmt: fmtVol }, z: fmtVol });

                    const rangePos = colCellsForGrandTotal[col.id].pos;
                    const fPos = rangePos.length > 0 ? rangePos.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fPos, s: { ...grandTotalStyle, numFmt: fmtInt }, z: fmtInt });

                } else if (col.type === 'pedev') {
                    const rangePos = colCellsForGrandTotal[col.id].pos;
                    const fPos = rangePos.length > 0 ? rangePos.join("+") : "0";
                    grandRowData.push({ t: 'n', v: 0, f: fPos, s: { ...grandTotalStyle, numFmt: fmtInt }, z: fmtInt });
                }
            });
            ws_data.push(grandRowData);

            // Create Sheet
            const ws = XLSX.utils.aoa_to_sheet(ws_data);
            ws['!merges'] = merges;

            // Auto-width
            const wscols = [{ wch: 10 }, { wch: 20 }];
            for(let i = 2; i < 50; i++) wscols.push({ wch: 12 });
            ws['!cols'] = wscols;

            // Add Sheet to Workbook
            XLSX.utils.book_append_sheet(wb, ws, "Metas SV");
            XLSX.writeFile(wb, "Metas_Fechamento_SV.xlsx");
        }

        function isActiveClient(c) {
            const rca1 = String(c.rca1 || '').trim();
            const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
            if (isAmericanas) return true;
            // STRICT FILTER: Exclude RCA 53 (Balcão) and INATIVOS
            if (rca1 === '53') return false;
            if (rca1 === '') return false; // Exclude INATIVOS
            return true;
        }

        function getGoalsFilteredData() {
            const sellersSet = new Set(selectedGoalsGvSellers);
            const supervisorsSet = new Set(selectedGoalsGvSupervisors);
            const codCli = goalsGvCodcliFilter.value.trim();

            let clients = allClientsData;

            // Apply "Active" Filter logic
            clients = clients.filter(c => isActiveClient(c));

            // Filter by Supervisor
            if (supervisorsSet.size > 0) {
                const rcasSet = new Set();
                supervisorsSet.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                clients = clients.filter(c => {
                    const clientRcas = (c.rcas && Array.isArray(c.rcas)) ? c.rcas : [];
                    return clientRcas.some(r => rcasSet.has(r));
                });
            }

            // Filter by Seller
            if (sellersSet.size > 0) {
                const rcasSet = new Set();
                sellersSet.forEach(name => {
                    const code = optimizedData.rcaCodeByName.get(name);
                    if(code) rcasSet.add(code);
                });
                clients = clients.filter(c => {
                    const clientRcas = (c.rcas && Array.isArray(c.rcas)) ? c.rcas : [];
                    return clientRcas.some(r => rcasSet.has(r));
                });
            }

            // Filter by Client Code
            if (codCli) {
                clients = clients.filter(c => String(c['Código']) === codCli);
            }

            return clients;
        }

        function parseInputMoney(id) {
            const el = document.getElementById(id);
            if (!el) return 0;
            let val = el.value.replace(/\./g, '').replace(',', '.');
            return parseFloat(val) || 0;
        }

        function getMetricsForSupervisors(supervisorsList) {
            // Helper to init metrics structure
            const createMetric = () => ({
                fat: 0, vol: 0, prevFat: 0, prevVol: 0,
                prevClientsSet: new Set(),
                quarterlyPosClientsSet: new Set(), // New Set for Quarter Active
                monthlyClientsSets: new Map() // Map<MonthKey, Set<CodCli>>
            });

            const metricsMap = {
                '707': createMetric(),
                '708': createMetric(),
                '752': createMetric(),
                '1119_TODDYNHO': createMetric(),
                '1119_TODDY': createMetric(),
                '1119_QUAKER_KEROCOCO': createMetric(),
                'ELMA_ALL': createMetric(),
                'FOODS_ALL': createMetric(),
                'PEPSICO_ALL': createMetric()
            };

            const currentDate = lastSaleDate;
            const prevMonthDate = new Date(Date.UTC(currentDate.getUTCFullYear(), currentDate.getUTCMonth() - 1, 1));
            const prevMonthIndex = prevMonthDate.getUTCMonth();
            const prevMonthYear = prevMonthDate.getUTCFullYear();

            // Filter clients to match the "Active Structure" definition (Same as Coverage/Goals Table)
            let activeClients = allClientsData.filter(c => isActiveClient(c));

            // Filter by Supervisors if provided
            if (supervisorsList && supervisorsList.length > 0) {
                const supervisorsSet = new Set(supervisorsList);
                const rcasSet = new Set();
                supervisorsSet.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                activeClients = activeClients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            activeClients.forEach(client => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                // Temp accumulation for this client to ensure Positive Balance check
                const clientTotals = {}; // key -> { prevFat: 0, monthlyFat: Map<MonthKey, val> }

                if (clientHistoryIds) {
                    clientHistoryIds.forEach(id => {
                        const sale = optimizedData.historyById.get(id);
                        // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Summary Metrics
                        if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                        let key = null;
                        const codFor = String(sale.CODFOR);

                        if (codFor === '707') key = '707';
                        else if (codFor === '708') key = '708';
                        else if (codFor === '752') key = '752';
                        else if (codFor === '1119') {
                            const desc = normalize(sale.DESCRICAO || '');
                            if (desc.includes('TODDYNHO')) key = '1119_TODDYNHO';
                            else if (desc.includes('TODDY')) key = '1119_TODDY';
                            else if (desc.includes('QUAKER') || desc.includes('KEROCOCO')) key = '1119_QUAKER_KEROCOCO';
                        }

                        const keysToProcess = [];
                        if (key && metricsMap[key]) keysToProcess.push(key);

                        // Direct calculation for Groups to ensure correct Net Total logic (handling returns across brands)
                        if (['707', '708', '752'].includes(codFor)) keysToProcess.push('ELMA_ALL');
                        if (codFor === '1119') keysToProcess.push('FOODS_ALL');
                        if (['707', '708', '752', '1119'].includes(codFor)) keysToProcess.push('PEPSICO_ALL');

                        keysToProcess.forEach(procKey => {
                            const d = parseDate(sale.DTPED);
                            const isPrevMonth = d && d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear;

                            // 1. Revenue/Volume metrics (Types 1 & 9) - Global Sums
                            if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                metricsMap[procKey].fat += sale.VLVENDA;
                                metricsMap[procKey].vol += sale.TOTPESOLIQ;

                                if (isPrevMonth) {
                                    metricsMap[procKey].prevFat += sale.VLVENDA;
                                    metricsMap[procKey].prevVol += sale.TOTPESOLIQ;
                                }

                                // 2. Accumulate for Client Count Check (Balance per period)
                                // Standardized Logic: Track GLOBAL FAT sum regardless of date validity for positivation
                                if (!clientTotals[procKey]) clientTotals[procKey] = { prevFat: 0, monthlyFat: new Map(), globalFat: 0 };
                                clientTotals[procKey].globalFat += sale.VLVENDA;

                                if (d) {
                                    if (isPrevMonth) clientTotals[procKey].prevFat += sale.VLVENDA;

                                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                                    const currentMVal = clientTotals[procKey].monthlyFat.get(monthKey) || 0;
                                    clientTotals[procKey].monthlyFat.set(monthKey, currentMVal + sale.VLVENDA);
                                }
                            }
                        });
                    });
                }

                // Check thresholds for this client
                for (const key in clientTotals) {
                    const t = clientTotals[key];

                    // Calculate Total Quarter Fat for this client/key to determine Meta Pos
                    // MODIFIED: Use globalFat (Sum of ALL sales, including invalid dates) to match PEPSICO Logic
                    if (t.globalFat > 1) {
                        metricsMap[key].quarterlyPosClientsSet.add(codCli);
                    }

                    if (t.prevFat > 1) {
                        metricsMap[key].prevClientsSet.add(codCli);
                    }
                    t.monthlyFat.forEach((val, mKey) => {
                        if (val > 1) {
                            if (!metricsMap[key].monthlyClientsSets.has(mKey)) {
                                metricsMap[key].monthlyClientsSets.set(mKey, new Set());
                            }
                            metricsMap[key].monthlyClientsSets.get(mKey).add(codCli);
                        }
                    });
                }
            });

            // Calculate Averages and Finalize
            for (const key in metricsMap) {
                const m = metricsMap[key];

                m.avgFat = m.fat / QUARTERLY_DIVISOR;
                m.avgVol = m.vol / QUARTERLY_DIVISOR; // Kg
                m.prevVol = m.prevVol; // Kg

                m.prevClients = m.prevClientsSet.size;
                m.quarterlyPos = m.quarterlyPosClientsSet.size; // New Metric

                let sumClients = 0;
                m.monthlyClientsSets.forEach(set => sumClients += set.size);
                m.avgClients = sumClients / QUARTERLY_DIVISOR;
            }
            return metricsMap;
        }

        function updateGoalsSummaryView() {
            const container = document.getElementById('goals-summary-grid');
            if (!container) return;

            // Use the independent summary filter
            const displayMetrics = getMetricsForSupervisors(selectedGoalsSummarySupervisors);

            // Calculate Target Sums for Filtered Subset
            // 1. Identify clients matching the summary filter
            let filteredSummaryClients = allClientsData;

            // Apply "Active" Filter logic (Consistent with other Goal Views)
            filteredSummaryClients = filteredSummaryClients.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                if (isAmericanas) return true;
                // STRICT FILTER: Exclude RCA 53 (Balcão) and INATIVOS
                if (rca1 === '53') return false;
                if (rca1 === '') return false; // Exclude INATIVOS
                return true;
            });

            if (selectedGoalsSummarySupervisors.length > 0) {
                const supervisorsSet = new Set(selectedGoalsSummarySupervisors);
                const rcasSet = new Set();
                supervisorsSet.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                filteredSummaryClients = filteredSummaryClients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            // 2. Prepare Sets for fast lookup and Sum up goals
            const filteredSummaryClientCodes = new Set();
            const activeSellersInSummary = new Set();

            filteredSummaryClients.forEach(c => {
                filteredSummaryClientCodes.add(c['Código']);
                // Resolve Seller Name for Adjustment Filtering
                const rcaCode = String(c.rca1 || '').trim();
                if (rcaCode) {
                    const name = optimizedData.rcaNameByCode.get(rcaCode);
                    if (name) activeSellersInSummary.add(name);
                    else if (rcaCode === 'INATIVOS') activeSellersInSummary.add('INATIVOS');
                }
            });

            const summaryGoalsSums = {
                '707': { fat: 0, vol: 0 },
                '708': { fat: 0, vol: 0 },
                '752': { fat: 0, vol: 0 },
                '1119_TODDYNHO': { fat: 0, vol: 0 },
                '1119_TODDY': { fat: 0, vol: 0 },
                '1119_QUAKER_KEROCOCO': { fat: 0, vol: 0 }
            };

            // Calculate Base Total for Mix (Use ELMA_ALL metric with exclusion)
            const elmaTargetBase = getElmaTargetBase(displayMetrics, goalsPosAdjustments, activeSellersInSummary);

            filteredSummaryClients.forEach(c => {
                const codCli = c['Código'];
                if (globalClientGoals.has(codCli)) {
                    const cGoals = globalClientGoals.get(codCli);
                    cGoals.forEach((val, key) => {
                        if (summaryGoalsSums[key]) {
                            summaryGoalsSums[key].fat += val.fat;
                            summaryGoalsSums[key].vol += val.vol;
                        }
                    });
                }
            });

            const summaryItems = [
                { title: 'Extrusados', supplier: '707', brand: null, color: 'teal' },
                { title: 'Não Extrusados', supplier: '708', brand: null, color: 'blue' },
                { title: 'Torcida', supplier: '752', brand: null, color: 'purple' },
                { title: 'Toddynho', supplier: '1119', brand: 'TODDYNHO', color: 'orange' },
                { title: 'Toddy', supplier: '1119', brand: 'TODDY', color: 'amber' },
                { title: 'Quaker / Kerococo', supplier: '1119', brand: 'QUAKER_KEROCOCO', color: 'cyan' }
            ];

            let totalFat = 0;
            let totalVol = 0;
            const uniquePosClientsSet = new Set();

            const cardsHTML = summaryItems.map(item => {
                const key = item.supplier + (item.brand ? `_${item.brand}` : '');

                // Use calculated sums if filter is active, otherwise global targets?
                // Actually, if no filter is active, filteredSummaryClients = All Active, so the sum matches the global target.
                // So we can always use summaryGoalsSums.

                const target = summaryGoalsSums[key] || { fat: 0, vol: 0 };
                const metrics = displayMetrics[key] || { avgFat: 0, prevFat: 0 };

                let subCategoryAdjustment = 0;
                if (goalsPosAdjustments[key]) {
                    // goalsPosAdjustments keys are Seller Names, not Client Codes
                    goalsPosAdjustments[key].forEach((adjVal, sellerName) => {
                        if (activeSellersInSummary.has(sellerName)) {
                            subCategoryAdjustment += adjVal;
                        }
                    });
                }

                totalFat += target.fat;
                totalVol += target.vol;

                if (metrics.quarterlyPosClientsSet) {
                    metrics.quarterlyPosClientsSet.forEach(clientCode => uniquePosClientsSet.add(clientCode));
                }

                // Color mapping for classes
                const colorMap = {
                    teal: 'border-teal-500 text-teal-400 bg-teal-900/10',
                    blue: 'border-blue-500 text-blue-400 bg-blue-900/10',
                    purple: 'border-purple-500 text-purple-400 bg-purple-900/10',
                    orange: 'border-orange-500 text-orange-400 bg-orange-900/10',
                    amber: 'border-amber-500 text-amber-400 bg-amber-900/10',
                    cyan: 'border-cyan-500 text-cyan-400 bg-cyan-900/10'
                };

                const styleClass = colorMap[item.color] || colorMap.teal;
                const textColor = styleClass.split(' ')[1];

                return `
                    <div class="bg-[#1e2a5a] border-l-4 ${styleClass.split(' ')[0]} rounded-r-lg p-4 shadow-md transition hover:-translate-y-1">
                        <h3 class="font-bold text-lg text-white mb-3 border-b border-slate-700 pb-2">${item.title}</h3>
                        <div class="space-y-4">
                            <div>
                                <div class="flex justify-between items-baseline mb-1">
                                    <p class="text-xs text-slate-400 uppercase font-semibold">Meta Faturamento</p>
                                </div>
                                <p class="text-xl font-bold ${textColor} mb-2">
                                    ${target.fat.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                                </p>
                                <div class="flex justify-between text-[10px] text-slate-400 border-t border-slate-700/50 pt-1">
                                    <span>Trim: <span class="text-slate-300">${metrics.avgFat.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</span></span>
                                    <span>Ant: <span class="text-slate-300">${metrics.prevFat.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</span></span>
                                </div>
                            </div>

                            <div>
                                <div class="flex justify-between items-baseline mb-1">
                                    <p class="text-xs text-slate-400 uppercase font-semibold">Meta Volume (Kg)</p>
                                </div>
                                <p class="text-xl font-bold ${textColor} mb-2">
                                    ${target.vol.toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 })}
                                </p>
                                <div class="flex justify-between text-[10px] text-slate-400 border-t border-slate-700/50 pt-1">
                                    <span>Trim: <span class="text-slate-300">${metrics.avgVol.toLocaleString('pt-BR', { minimumFractionDigits: 3 })}</span></span>
                                    <span>Ant: <span class="text-slate-300">${metrics.prevVol.toLocaleString('pt-BR', { minimumFractionDigits: 3 })}</span></span>
                                </div>
                            </div>

                            <div>
                                <div class="flex justify-between items-baseline mb-1">
                                    <p class="text-xs text-slate-400 uppercase font-semibold">Meta Pos. (Clientes)</p>
                                </div>
                                <p class="text-xl font-bold ${textColor} mb-2">
                                    ${((metrics.quarterlyPos || 0) + subCategoryAdjustment).toLocaleString('pt-BR')}
                                </p>
                                <div class="flex justify-between text-[10px] text-slate-400 border-t border-slate-700/50 pt-1">
                                    <span>Ativos no Trimestre</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = cardsHTML;

            // Update Totals
            const totalFatEl = document.getElementById('summary-total-fat');
            const totalVolEl = document.getElementById('summary-total-vol');
            const totalPosEl = document.getElementById('summary-total-pos');
            const mixSaltyEl = document.getElementById('summary-mix-salty');
            const mixFoodsEl = document.getElementById('summary-mix-foods');

            if(totalFatEl) totalFatEl.textContent = totalFat.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            if(totalVolEl) totalVolEl.textContent = totalVol.toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });

            // Calculate Base Total (Use PEPSICO_ALL metric instead of Union)
            // basePosCount is already defined at the top of the function
            const basePosCount = displayMetrics['PEPSICO_ALL'].quarterlyPos;

            let totalAdjustment = 0;
            // Only PEPSICO adjustments affect the Global/Summary Total Pos
            if (goalsPosAdjustments['PEPSICO_ALL']) {
                goalsPosAdjustments['PEPSICO_ALL'].forEach((val, sellerName) => {
                    // Only include adjustment if seller is active in current summary view
                    if (activeSellersInSummary.has(sellerName)) {
                        totalAdjustment += val;
                    }
                });
            }

            const adjustedTotalPos = basePosCount + totalAdjustment;

            if(totalPosEl) totalPosEl.textContent = adjustedTotalPos.toLocaleString('pt-BR');

            // Calculate base for Mix Goals (Exclude Americanas / Seller 1001)
            let naturalMixBaseCount = 0;
            uniquePosClientsSet.forEach(clientCode => {
                const client = clientMapForKPIs.get(String(clientCode));
                if (client) {
                     const rca1 = String(client.rca1 || '').trim();
                     if (rca1 !== '1001') {
                         naturalMixBaseCount++;
                     }
                }
            });

            // MIX KPIs - Based on ELMA Target (50% Salty / 30% Foods)
            const naturalSaltyTarget = Math.round(elmaTargetBase * 0.50);

            let mixSaltyAdjustment = 0;
            if (goalsMixSaltyAdjustments['PEPSICO_ALL']) {
                 goalsMixSaltyAdjustments['PEPSICO_ALL'].forEach((val, sellerName) => {
                     // Check if seller is in the filtered summary view
                     if (activeSellersInSummary.has(sellerName)) mixSaltyAdjustment += val;
                 });
            }
            if(mixSaltyEl) mixSaltyEl.textContent = (naturalSaltyTarget + mixSaltyAdjustment).toLocaleString('pt-BR');

            // Mix Foods - Based on ELMA Target (30%)
            const naturalFoodsTarget = Math.round(elmaTargetBase * 0.30);
            let mixFoodsAdjustment = 0;
            if (goalsMixFoodsAdjustments['PEPSICO_ALL']) {
                 goalsMixFoodsAdjustments['PEPSICO_ALL'].forEach((val, sellerName) => {
                     if (activeSellersInSummary.has(sellerName)) mixFoodsAdjustment += val;
                 });
            }
            if(mixFoodsEl) mixFoodsEl.textContent = (naturalFoodsTarget + mixFoodsAdjustment).toLocaleString('pt-BR');
        }

        function getElmaTargetBase(displayMetrics, goalsPosAdjustments, activeSellersSet) {
            // MATCH LOGIC WITH "RELATÓRIO" (SV): Base is "Total ELMA" (707, 708, 752)
            // Logic derived from `updateGoalsSvView`:
            // - The Grand Total for Mix Salty/Foods EXCLUDES Americanas (Seller 1001) from the base.
            // - It INCLUDES normal clients.

            // 1. Iterate ALL valid clients (Active Structure)
            // 2. EXCLUDE Americanas (RCA 1001) for this specific KPI base (matches SV footer logic)
            // 3. Exclude Balcão (53) and Inativos
            // 4. Check if Client has > 1 Total Sales in History (Elma: 707, 708, 752)
            // 5. Match Active Sellers

            let naturalCount = 0;

            // Iterate all clients (global allClientsData)
            // Use standard loop for performance
            for (let i = 0; i < allClientsData.length; i++) {
                const client = allClientsData instanceof ColumnarDataset ? allClientsData.get(i) : allClientsData[i];
                const codCli = String(client['Código'] || client['codigo_cliente']);

                // 1. Exclusions (Structure)
                const rca1 = String(client.rca1 || '').trim();
                const isAmericanas = (client.razaoSocial || '').toUpperCase().includes('AMERICANAS');

                // Exclude Americanas (Specific Rule for Mix Base)
                if (rca1 === '1001' || isAmericanas) continue;

                // Exclude Balcão (53) and Inativos
                if (rca1 === '53' || rca1 === '') continue;

                // 2. Active Seller Check
                let belongsToActiveSeller = true;
                if (activeSellersSet && activeSellersSet.size > 0) {
                    let sellerName = 'N/A';
                    // In SV, we map rcas[0] to Name.
                    const rcaCode = (client.rcas && client.rcas.length > 0) ? client.rcas[0] : '';
                    if (rcaCode) {
                         sellerName = optimizedData.rcaNameByCode.get(rcaCode) || rcaCode;
                    } else {
                        sellerName = 'INATIVOS';
                    }

                    if (!activeSellersSet.has(sellerName)) belongsToActiveSeller = false;
                }

                if (!belongsToActiveSeller) continue;

                // 3. Check History (Positive ELMA: 707, 708, 752)
                const hIds = optimizedData.indices.history.byClient.get(codCli);
                let totalFat = 0;
                if (hIds) {
                    // hIds is Set<string> (id)
                    for (const id of hIds) {
                        const s = optimizedData.historyById.get(id);
                        const codFor = String(s.CODFOR);
                         if (['707', '708', '752'].includes(codFor)) {
                            if (s.TIPOVENDA === '1' || s.TIPOVENDA === '9') totalFat += s.VLVENDA;
                        }
                    }
                }

                if (totalFat > 1) {
                    naturalCount++;
                }
            }

            // 2. Adjustments (Meta Pos) - Preserve Logic
            let adjustment = 0;
            const elmaAdj = goalsPosAdjustments['ELMA_ALL'];
            if (elmaAdj) {
                elmaAdj.forEach((val, sellerName) => {
                    // Check if seller is in current view (activeSellersSet)
                    if (!activeSellersSet || activeSellersSet.has(sellerName)) {
                        adjustment += val;
                    }
                });
            }

            return naturalCount + adjustment;
        }

                function calculateDistributedGoals(filteredClients, currentGoalsSupplier, currentGoalsBrand, goalFat, goalVol) {
            const cacheKey = currentGoalsSupplier + (currentGoalsBrand ? `_${currentGoalsBrand}` : '');

            if (quarterMonths.length === 0) identifyQuarterMonths();

            // Determine dates for Previous Month calc
            const currentDate = lastSaleDate;
            const prevMonthDate = new Date(Date.UTC(currentDate.getUTCFullYear(), currentDate.getUTCMonth() - 1, 1));
            const prevMonthIndex = prevMonthDate.getUTCMonth();
            const prevMonthYear = prevMonthDate.getUTCFullYear();

            // --- CÁLCULO DOS TOTAIS GLOBAIS (EMPRESA) PARA O FORNECEDOR/MARCA ATUAL ---
            let globalTotalAvgFat = 0;
            let globalTotalAvgVol = 0;

            const shouldIncludeSale = (sale, supplier, brand) => {
                const codFor = String(sale.CODFOR);
                if (supplier === 'PEPSICO_ALL') {
                    // Includes everything
                    if (!['707', '708', '752', '1119'].includes(codFor)) return false;
                } else if (supplier === 'ELMA_ALL') {
                    if (!['707', '708', '752'].includes(codFor)) return false;
                } else if (supplier === 'FOODS_ALL') {
                    // Include all brands of 1119 that are in sub-tabs
                    if (codFor !== '1119') return false;
                    // No brand filtering here, assuming 1119 contains mostly Foods
                } else {
                    if (codFor !== supplier) return false;
                    if (brand) {
                        const desc = normalize(sale.DESCRICAO || '');
                        if (brand === 'TODDYNHO') {
                            if (!desc.includes('TODDYNHO')) return false;
                        } else if (brand === 'TODDY') {
                            if (!desc.includes('TODDY') || desc.includes('TODDYNHO')) return false;
                        } else if (brand === 'QUAKER_KEROCOCO') {
                            if (!desc.includes('QUAKER') && !desc.includes('KEROCOCO')) return false;
                        }
                    }
                }
                return true;
            };

            if (globalGoalsTotalsCache[cacheKey]) {
                globalTotalAvgFat = globalGoalsTotalsCache[cacheKey].fat;
                globalTotalAvgVol = globalGoalsTotalsCache[cacheKey].vol;
            } else {
                const allActiveClients = allClientsData.filter(c => {
                    const rca1 = String(c.rca1 || '').trim();
                    const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                    if (isAmericanas) return true;
                // STRICT FILTER: Exclude RCA 53 (Balcão) and INATIVOS
                    if (rca1 === '53') return false;
                if (rca1 === '') return false; // Exclude INATIVOS
                    return true;
                });

                allActiveClients.forEach(client => {
                    const codCli = String(client['Código'] || client['codigo_cliente']);
                    const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);
                    if (clientHistoryIds) {
                        let sumFat = 0;
                        let sumVol = 0;
                        clientHistoryIds.forEach(id => {
                            const sale = optimizedData.historyById.get(id);
                            // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Global Portfolio Totals
                            if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                            if (shouldIncludeSale(sale, currentGoalsSupplier, currentGoalsBrand)) {
                                if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                    sumFat += sale.VLVENDA;
                                    sumVol += sale.TOTPESOLIQ;
                                }
                            }
                        });

                        // NEW LOGIC: Simple Average (Sum / 3) regardless of active months
                        globalTotalAvgFat += (sumFat / QUARTERLY_DIVISOR);
                        globalTotalAvgVol += (sumVol / QUARTERLY_DIVISOR); // Kg (No / 1000)
                    }
                });

                globalGoalsTotalsCache[cacheKey] = { fat: globalTotalAvgFat, vol: globalTotalAvgVol };
            }

            const clientMetrics = [];

            filteredClients.forEach(client => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                let sumFat = 0;
                let sumVol = 0;
                let prevFat = 0;
                let prevVol = 0;
                const monthlyActivity = new Map(); // MonthKey -> Fat

                // Initialize monthly values for breakdown
                const monthlyValues = {};
                quarterMonths.forEach(m => monthlyValues[m.key] = 0);

                if (clientHistoryIds) {
                    clientHistoryIds.forEach(id => {
                        const sale = optimizedData.historyById.get(id);
                        // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Portfolio Average
                        if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                        if (shouldIncludeSale(sale, currentGoalsSupplier, currentGoalsBrand)) {
                            if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                sumFat += sale.VLVENDA;
                                sumVol += sale.TOTPESOLIQ;

                                const d = parseDate(sale.DTPED);
                                if (d) {
                                    // Previous Month Calc
                                    if (d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear) {
                                        prevFat += sale.VLVENDA;
                                        prevVol += sale.TOTPESOLIQ;
                                    }

                                    // Activity per Month Calc
                                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                                    monthlyActivity.set(monthKey, (monthlyActivity.get(monthKey) || 0) + sale.VLVENDA);

                                    if (monthlyValues.hasOwnProperty(monthKey)) {
                                        monthlyValues[monthKey] += sale.VLVENDA;
                                    }
                                }
                            }
                        }
                    });
                }

                // NEW LOGIC: Simple Average (Sum / 3) regardless of active months
                const avgFat = sumFat / QUARTERLY_DIVISOR;
                const avgVol = sumVol / QUARTERLY_DIVISOR; // Kg (No / 1000)

                let activeMonthsCount = 0;
                monthlyActivity.forEach(val => { if(val > 1) activeMonthsCount++; });

                const isActivePrevMonth = prevFat > 1 ? 1 : 0;

                let sellerName = 'N/A';
                const rcaCode = client.rcas[0];
                if (rcaCode) sellerName = optimizedData.rcaNameByCode.get(rcaCode) || rcaCode;
                else if (client.rcas.length === 0 || client.rcas[0] === '') sellerName = 'INATIVOS';

                // Retrieve Stored Goal
                let metaFat = 0;
                let metaVol = 0;

                if (currentGoalsSupplier === 'ELMA_ALL' || currentGoalsSupplier === 'FOODS_ALL' || currentGoalsSupplier === 'PEPSICO_ALL') {
                    if (globalClientGoals.has(codCli)) {
                        const cGoals = globalClientGoals.get(codCli);
                        let keysToSum = [];
                        if (currentGoalsSupplier === 'ELMA_ALL') keysToSum = ['707', '708', '752'];
                        else if (currentGoalsSupplier === 'FOODS_ALL') keysToSum = ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];
                        else if (currentGoalsSupplier === 'PEPSICO_ALL') keysToSum = ['707', '708', '752', '1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];

                        keysToSum.forEach(k => {
                            if (cGoals.has(k)) {
                                const g = cGoals.get(k);
                                metaFat += g.fat;
                                metaVol += g.vol;
                            }
                        });
                    }
                } else {
                    if (globalClientGoals.has(codCli)) {
                        const cGoals = globalClientGoals.get(codCli);
                        if (cGoals.has(cacheKey)) {
                            const g = cGoals.get(cacheKey);
                            metaFat = g.fat;
                            metaVol = g.vol;
                        }
                    }
                }

                const metaPos = (sumFat > 1 && avgFat > 0) ? 1 : 0; // Positivado se venda > 1 (threshold padrão)

                clientMetrics.push({
                    cod: codCli,
                    name: client.fantasia || client.razaoSocial,
                    seller: sellerName,
                    avgFat,
                    avgVol, // Now Kg
                    prevFat,
                    prevVol: prevVol, // Now Kg (removed / 1000)
                    activeMonthsCount,
                    isActivePrevMonth,
                    shareFat: (globalTotalAvgFat > 0 && avgFat > 0) ? (avgFat / globalTotalAvgFat) : 0,
                    shareVol: (globalTotalAvgVol > 0 && avgVol > 0) ? (avgVol / globalTotalAvgVol) : 0,
                    metaFat: metaFat,
                    metaVol: metaVol,
                    metaPos: metaPos,
                    monthlyBreakdown: monthlyValues
                });
            });

            // Calculate auto distribution if goal is set but individual goals are zero (first run)
            const totalShareFat = clientMetrics.reduce((sum, c) => sum + c.shareFat, 0);
            const totalShareVol = clientMetrics.reduce((sum, c) => sum + c.shareVol, 0);

            // If we have input goals, we can distribute them proportionally (Visual only, not saved unless clicked)
            // But here we just return the metrics. The view uses these metrics.

            return { clientMetrics, globalTotalAvgFat, globalTotalAvgVol };
        }

        function recalculateTotalGoals() {
            // Reset goalsTargets sums
            for (const key in goalsTargets) {
                goalsTargets[key] = { fat: 0, vol: 0 };
            }

            globalClientGoals.forEach((goalsMap, codCli) => {
                goalsMap.forEach((val, key) => {
                    if (goalsTargets[key]) {
                        goalsTargets[key].fat += val.fat;
                        goalsTargets[key].vol += val.vol;
                    }
                });
            });
        }

        function distributeGoals(type) {
            const inputId = type === 'fat' ? 'goal-global-fat' : 'goal-global-vol';
            const inputValue = parseInputMoney(inputId);

            const filteredClients = getGoalsFilteredData();
            if (filteredClients.length === 0) return;

            let keysToProcess = [];
            if (currentGoalsSupplier === 'PEPSICO_ALL') {
                keysToProcess = ['707', '708', '752', '1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];
            } else if (currentGoalsSupplier === 'ELMA_ALL') {
                keysToProcess = ['707', '708', '752'];
            } else if (currentGoalsSupplier === 'FOODS_ALL') {
                keysToProcess = ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];
            } else {
                const cacheKey = currentGoalsSupplier + (currentGoalsBrand ? `_${currentGoalsBrand}` : '');
                keysToProcess = [cacheKey];
            }

            // 1. Calculate Total Denominator (Sum of Averages of all target keys for all filtered clients)
            let totalDenominator = 0;
            const distributionMap = new Map(); // Map<ClientCod, Map<Key, AvgValue>>

            filteredClients.forEach(client => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                if (!distributionMap.has(codCli)) distributionMap.set(codCli, new Map());
                const clientMap = distributionMap.get(codCli);

                keysToProcess.forEach(targetKey => {
                    let sumVal = 0;
                    if (clientHistoryIds) {
                        clientHistoryIds.forEach(id => {
                            const sale = optimizedData.historyById.get(id);

                            // Check if sale belongs to targetKey
                            let saleKey = String(sale.CODFOR);
                            const codFor = String(sale.CODFOR);

                            // Special handling for broken down categories (FOODS)
                            if (codFor === '1119') {
                                const desc = normalize(sale.DESCRICAO || '');
                                if (desc.includes('TODDYNHO')) saleKey = '1119_TODDYNHO';
                                else if (desc.includes('TODDY')) saleKey = '1119_TODDY';
                                else if (desc.includes('QUAKER') || desc.includes('KEROCOCO')) saleKey = '1119_QUAKER_KEROCOCO';
                                else if (targetKey.startsWith('1119_')) saleKey = null; // If targeting a sub-brand but this product doesn't match, exclude it
                            }

                            if (saleKey === targetKey) {
                                if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                    if (type === 'fat') sumVal += sale.VLVENDA;
                                    else sumVal += sale.TOTPESOLIQ;
                                }
                            }
                        });
                    }

                    // Apply divisor
                    let avg = sumVal / QUARTERLY_DIVISOR;
                    if (type === 'vol') avg = avg / 1000; // Tons

                    clientMap.set(targetKey, avg);
                    totalDenominator += avg;
                });
            });

            // 2. Distribute
            filteredClients.forEach(client => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientMap = distributionMap.get(codCli);

                if (!globalClientGoals.has(codCli)) globalClientGoals.set(codCli, new Map());
                const cGoals = globalClientGoals.get(codCli);

                keysToProcess.forEach(key => {
                    const avg = clientMap.get(key) || 0;
                    let share = totalDenominator > 0 ? (avg / totalDenominator) : 0;

                    if (totalDenominator === 0) {
                         const totalItems = filteredClients.length * keysToProcess.length;
                         if (totalItems > 0) share = 1 / totalItems;
                    }

                    const newGoal = share * inputValue;

                    if (!cGoals.has(key)) cGoals.set(key, { fat: 0, vol: 0 });
                    const g = cGoals.get(key);

                    if (type === 'fat') g.fat = newGoal;
                    else g.vol = newGoal;
                });
            });

            recalculateTotalGoals();
            updateGoalsView();
        }

        function showConfirmationModal(message, onConfirm) {
            const modal = document.getElementById('confirmation-modal');
            const msgEl = document.getElementById('confirmation-message');
            const confirmBtn = document.getElementById('confirmation-confirm-btn');
            const cancelBtn = document.getElementById('confirmation-cancel-btn');

            msgEl.textContent = message;
            modal.classList.remove('hidden');

            // Clean up old listeners to avoid duplicates
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            newConfirmBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
                onConfirm();
            });

            newCancelBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
            });
        }

        function getFilterDescription() {
            if (selectedGoalsGvSupervisors.length > 0) {
                return selectedGoalsGvSupervisors.length === 1 ? `Supervisor "${selectedGoalsGvSupervisors[0]}"` : "Supervisores selecionados";
            }
            if (selectedGoalsGvSellers.length > 0) {
                return selectedGoalsGvSellers.length === 1 ? `Vendedor "${getFirstName(selectedGoalsGvSellers[0])}"` : "Vendedores selecionados";
            }
            if (goalsGvCodcliFilter.value) {
                return `Cliente "${goalsGvCodcliFilter.value}"`;
            }

            // Default to Tab Name
            if (currentGoalsSupplier === '707') return 'EXTRUSADOS';
            if (currentGoalsSupplier === '708') return 'NÃO EXTRUSADOS';
            if (currentGoalsSupplier === '752') return 'TORCIDA';
            if (currentGoalsBrand) return currentGoalsBrand;

            return 'filtro atual';
        }

        function saveMixAdjustment(type, value, sellerName) {
            // Find natural base for this seller based on ELMA metrics (excluding Americanas)
            const sellerCode = optimizedData.rcaCodeByName.get(sellerName);

            // Re-use logic for Active Clients counting
            const sellerClients = allClientsData.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                if (!sellerCode) return false;

                // Is client active check (Same as others)
                // Exclude Americanas explicitly from this calculation as per requirement
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                if (isAmericanas || (rca1 === '53' || rca1 === '053' || rca1 === '' || rca1 === 'INATIVOS')) return false;

                // Does client belong to seller? (Current Hierarchy)
                return c.rcas.includes(sellerCode);
            });

            let naturalCount = 0;
            // Count "Meta Pos" (Revenue > 1 in ELMA_ALL: 707, 708, 752) for these clients
            sellerClients.forEach(c => {
                const codCli = c['Código'];
                const hIds = optimizedData.indices.history.byClient.get(codCli);
                let sumFat = 0;
                if (hIds) {
                    hIds.forEach(id => {
                        const s = optimizedData.historyById.get(id);
                        if (['707', '708', '752'].includes(String(s.CODFOR))) {
                            if (s.TIPOVENDA === '1' || s.TIPOVENDA === '9') sumFat += s.VLVENDA;
                        }
                    });
                }
                if (sumFat > 1) naturalCount++;
            });

            // Check if seller has specific adjustment for ELMA_ALL (Meta Pos)
            let adjustmentPos = 0;
            if (goalsPosAdjustments['ELMA_ALL'] && goalsPosAdjustments['ELMA_ALL'].has(sellerName)) {
                adjustmentPos = goalsPosAdjustments['ELMA_ALL'].get(sellerName);
            }

            // Base = Natural Elma Count + Elma Adjustment
            const totalElmaBase = naturalCount + adjustmentPos;

            // Apply 50% / 30% rule
            const base = type === 'salty' ? Math.round(totalElmaBase * 0.50) : Math.round(totalElmaBase * 0.30);
            const adjustment = value - base;

            // ALWAYS STORE IN PEPSICO_ALL (Unify Inputs)
            if (type === 'salty') {
                if (!goalsMixSaltyAdjustments['PEPSICO_ALL']) goalsMixSaltyAdjustments['PEPSICO_ALL'] = new Map();
                goalsMixSaltyAdjustments['PEPSICO_ALL'].set(sellerName, adjustment);
            } else {
                if (!goalsMixFoodsAdjustments['PEPSICO_ALL']) goalsMixFoodsAdjustments['PEPSICO_ALL'] = new Map();
                goalsMixFoodsAdjustments['PEPSICO_ALL'].set(sellerName, adjustment);
            }

            updateGoalsView();
        }


        function exportGoalsCurrentTabXLSX() {
            const data = goalsTableState.filteredData;
            if (!data || data.length === 0) {
                alert('Sem dados para exportar.');
                return;
            }

            const wb = XLSX.utils.book_new();

            // 1. Headers
            const monthLabels = quarterMonths.map(m => m.label);
            const flatHeaders = [
                'CÓD', 'CLIENTE', 'VENDEDOR',
                ...monthLabels.map(m => `${m} (FAT)`),
                'MÉDIA FAT', '% SHARE FAT', 'META FAT',
                'MÉDIA VOL (KG)', '% SHARE VOL', 'META VOL (KG)', 'META POS'
            ];

            const ws_data_flat = [flatHeaders];
             data.forEach(item => {
                const row = [
                    parseInt(item.cod),
                    item.name,
                    getFirstName(item.seller),
                    ...quarterMonths.map(m => item.monthlyValues[m.key] || 0),
                    item.avgFat,
                    item.shareFat,
                    item.metaFat,
                    item.avgVol,
                    item.shareVol,
                    item.metaVol,
                    item.metaPos
                ];
                ws_data_flat.push(row);
            });

            const ws_flat = XLSX.utils.aoa_to_sheet(ws_data_flat);

             // Style Header
            if (ws_flat['!ref']) {
                const range = XLSX.utils.decode_range(ws_flat['!ref']);
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const addr = XLSX.utils.encode_cell({ r: 0, c: C });
                    if (!ws_flat[addr]) continue;
                    if (!ws_flat[addr].s) ws_flat[addr].s = {};
                    ws_flat[addr].s.fill = { fgColor: { rgb: "1E293B" } };
                    ws_flat[addr].s.font = { color: { rgb: "FFFFFF" }, bold: true };
                    ws_flat[addr].s.alignment = { horizontal: "center" };
                }

                // Number formats
                for (let R = 1; R <= range.e.r; ++R) {
                     // Month Cols start at 3
                     const monthStart = 3;
                     const monthEnd = 3 + quarterMonths.length - 1;

                     for (let C = monthStart; C <= range.e.c; ++C) {
                          const addr = XLSX.utils.encode_cell({ r: R, c: C });
                          if (!ws_flat[addr]) continue;
                          if (!ws_flat[addr].s) ws_flat[addr].s = {};
                          ws_flat[addr].t = 'n';

                          // Percentages (Indices relative to monthEnd)
                          // Header: [COD, CLI, VEND, M1, M2, M3, AVG, SHARE, META, AVG_V, SHARE, META_V, POS]
                          // M3 is monthEnd.
                          // AVG is monthEnd+1
                          // SHARE is monthEnd+2
                          // META is monthEnd+3
                          // AVG_V is monthEnd+4
                          // SHARE_V is monthEnd+5
                          // META_V is monthEnd+6
                          // POS is monthEnd+7

                          if (C === monthEnd + 2 || C === monthEnd + 5) {
                              ws_flat[addr].z = '0.00%';
                          }
                          // Volumes (TON)
                          else if (C === monthEnd + 4 || C === monthEnd + 6) {
                              ws_flat[addr].z = '#,##0.000';
                          }
                          // Currency/Values
                          else if (C <= monthEnd + 3) {
                              ws_flat[addr].z = '#,##0.00';
                          }
                     }
                }

                ws_flat['!cols'] = [
                    { wch: 8 }, { wch: 35 }, { wch: 15 },
                    ...quarterMonths.map(_ => ({ wch: 15 })),
                    { wch: 15 }, { wch: 10 }, { wch: 15 },
                    { wch: 15 }, { wch: 10 }, { wch: 15 }, { wch: 8 }
                ];
            }

            XLSX.utils.book_append_sheet(wb, ws_flat, "Metas GV");
            XLSX.writeFile(wb, `Metas_GV_${currentGoalsSupplier}_${new Date().toISOString().slice(0,10)}.xlsx`);
        }

        function updateGoalsView() {
            goalsRenderId++;
            const currentRenderId = goalsRenderId;

            // Check if we are in Summary Mode
            if (document.getElementById('goals-summary-content') && !document.getElementById('goals-summary-content').classList.contains('hidden')) {
                updateGoalsSummaryView();
                return;
            }

            if (quarterMonths.length === 0) identifyQuarterMonths();

            // Calculate Metrics for Current View (Supervisor Filter)
            const displayMetrics = getMetricsForSupervisors(selectedGoalsGvSupervisors);

            // Update Header (Dynamic) - Same as before
            const thead = document.querySelector('#goals-table-container table thead');
            if (thead) {
                const monthHeaders = quarterMonths.map(m => `<th class="px-2 py-2 text-right w-20 bg-blue-900/10 text-blue-300 border-r border-b border-slate-700/50 text-[10px]">${m.label}</th>`).join('');
                const monthsCount = quarterMonths.length;
                thead.innerHTML = `<tr><th rowspan="2" class="px-2 py-2 text-center w-16 border-r border-b border-slate-700">CÓD</th><th rowspan="2" class="px-3 py-2 text-left w-48 border-r border-b border-slate-700">CLIENTE</th><th rowspan="2" class="px-3 py-2 text-left w-24 border-r border-b border-slate-700">VENDEDOR</th><th colspan="${3 + monthsCount}" class="px-2 py-1 text-center bg-blue-900/30 text-blue-400 border-r border-slate-700 border-b-0">FATURAMENTO (R$)</th><th colspan="3" class="px-2 py-1 text-center bg-orange-900/30 text-orange-400 border-r border-slate-700 border-b-0">VOLUME (KG)</th><th rowspan="2" class="px-2 py-2 text-center w-16 bg-purple-900/20 text-purple-300 font-bold border-b border-slate-700">META POS.</th></tr><tr>${monthHeaders}<th class="px-2 py-2 text-right w-24 bg-blue-900/20 text-blue-300 border-r border-b border-slate-700/50 text-[10px]">MÉDIA</th><th class="px-2 py-2 text-center w-16 bg-blue-900/20 text-blue-300 border-r border-b border-slate-700/50 text-[10px]">% SHARE</th><th class="px-2 py-2 text-right w-24 bg-blue-900/20 text-blue-100 font-bold border-r border-b border-slate-700 text-[10px]">META AUTO</th><th class="px-2 py-2 text-right w-24 bg-orange-900/20 text-orange-300 border-r border-b border-slate-700/50 text-[10px]">MÉDIA KG</th><th class="px-2 py-2 text-center w-16 bg-orange-900/20 text-orange-300 border-r border-b border-slate-700/50 text-[10px]">% SHARE</th><th class="px-2 py-2 text-right w-24 bg-orange-900/20 text-orange-100 font-bold border-r border-b border-slate-700 text-[10px]">META KG</th></tr>`;
            }

            const filteredClients = getGoalsFilteredData();
            goalsGvTableBody.innerHTML = '<tr><td colspan="15" class="text-center p-8"><svg class="animate-spin h-8 w-8 text-teal-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></td></tr>';

            // Cache Key for Global Totals
            const cacheKey = currentGoalsSupplier + (currentGoalsBrand ? `_${currentGoalsBrand}` : '');

            if (!globalGoalsTotalsCache[cacheKey]) {
                 calculateDistributedGoals([], currentGoalsSupplier, currentGoalsBrand, 0, 0);
            }

            const currentDate = lastSaleDate;
            const prevMonthDate = new Date(Date.UTC(currentDate.getUTCFullYear(), currentDate.getUTCMonth() - 1, 1));
            const prevMonthIndex = prevMonthDate.getUTCMonth();
            const prevMonthYear = prevMonthDate.getUTCFullYear();

            // Helper for inclusion check
            const shouldIncludeSale = (sale, supplier, brand) => {
                const codFor = String(sale.CODFOR);
                if (supplier === 'PEPSICO_ALL') { if (!['707', '708', '752', '1119'].includes(codFor)) return false; }
                else if (supplier === 'ELMA_ALL') { if (!['707', '708', '752'].includes(codFor)) return false; }
                else if (supplier === 'FOODS_ALL') { if (codFor !== '1119') return false; }
                else {
                    if (codFor !== supplier) return false;
                    if (brand) {
                        const desc = normalize(sale.DESCRICAO || '');
                        if (brand === 'TODDYNHO') { if (!desc.includes('TODDYNHO')) return false; }
                        else if (brand === 'TODDY') { if (!desc.includes('TODDY') || desc.includes('TODDYNHO')) return false; }
                        else if (brand === 'QUAKER_KEROCOCO') { if (!desc.includes('QUAKER') && !desc.includes('KEROCOCO')) return false; }
                    }
                }
                return true;
            };

            const globalTotalAvgFat = globalGoalsTotalsCache[cacheKey].fat;
            const globalTotalAvgVol = globalGoalsTotalsCache[cacheKey].vol;

            const clientMetrics = [];
            let sumFat = 0; let sumVol = 0;
            let totalAvgFat = 0; let totalPrevFat = 0; let totalAvgVol = 0; let totalPrevVol = 0; let sumActiveMonths = 0; let totalPrevClients = 0;

            runAsyncChunked(filteredClients, (client) => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                let cSumFat = 0; let cSumVol = 0; let cPrevFat = 0; let cPrevVol = 0;
                const monthlyActivity = new Map();
                const monthlyValues = {};
                quarterMonths.forEach(m => monthlyValues[m.key] = 0);

                if (clientHistoryIds) {
                    clientHistoryIds.forEach(id => {
                        const sale = optimizedData.historyById.get(id);
                        // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Portfolio Average
                        if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                        if (shouldIncludeSale(sale, currentGoalsSupplier, currentGoalsBrand)) {
                            if (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') {
                                cSumFat += sale.VLVENDA;
                                cSumVol += sale.TOTPESOLIQ;
                                const d = parseDate(sale.DTPED);
                                if (d) {
                                    if (d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear) {
                                        cPrevFat += sale.VLVENDA;
                                        cPrevVol += sale.TOTPESOLIQ;
                                    }
                                    const monthKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                                    monthlyActivity.set(monthKey, (monthlyActivity.get(monthKey) || 0) + sale.VLVENDA);
                                    if (monthlyValues.hasOwnProperty(monthKey)) monthlyValues[monthKey] += sale.VLVENDA;
                                }
                            }
                        }
                    });
                }

                let activeMonthsCount = 0;
                monthlyActivity.forEach(val => { if(val > 1) activeMonthsCount++; });
                const divisor = QUARTERLY_DIVISOR;
                const avgFat = cSumFat / divisor;
                const avgVol = cSumVol / divisor;
                const isActivePrevMonth = cPrevFat > 1 ? 1 : 0;

                let sellerName = 'N/A';
                const rcaCode = client.rcas[0];
                if (rcaCode) sellerName = optimizedData.rcaNameByCode.get(rcaCode) || rcaCode;

                // Retrieve Stored Goal
                let metaFat = 0; let metaVol = 0;
                if (currentGoalsSupplier === 'ELMA_ALL' || currentGoalsSupplier === 'FOODS_ALL' || currentGoalsSupplier === 'PEPSICO_ALL') {
                    if (globalClientGoals.has(codCli)) {
                        const cGoals = globalClientGoals.get(codCli);
                        let keysToSum = [];
                        if (currentGoalsSupplier === 'ELMA_ALL') keysToSum = ['707', '708', '752'];
                        else if (currentGoalsSupplier === 'FOODS_ALL') keysToSum = ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];
                        else if (currentGoalsSupplier === 'PEPSICO_ALL') keysToSum = ['707', '708', '752', '1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];

                        keysToSum.forEach(k => { if (cGoals.has(k)) { const g = cGoals.get(k); metaFat += g.fat; metaVol += g.vol; } });
                    }
                } else {
                    if (globalClientGoals.has(codCli)) {
                        const cGoals = globalClientGoals.get(codCli);
                        if (cGoals.has(cacheKey)) { const g = cGoals.get(cacheKey); metaFat = g.fat; metaVol = g.vol; }
                    }
                }

                const metaPos = cSumFat > 1 ? 1 : 0;

                const metric = {
                    cod: codCli, name: client.nomeCliente || client.fantasia || client.razaoSocial || 'Cliente Sem Nome', seller: sellerName,
                    avgFat, avgVol, prevFat: cPrevFat, prevVol: cPrevVol,
                    activeMonthsCount, isActivePrevMonth,
                    shareFat: (globalTotalAvgFat > 0 && avgFat > 0) ? (avgFat / globalTotalAvgFat) : 0,
                    shareVol: (globalTotalAvgVol > 0 && avgVol > 0) ? (avgVol / globalTotalAvgVol) : 0,
                    metaFat, metaVol, metaPos, monthlyValues
                };
                clientMetrics.push(metric);

                // Accumulate totals
                sumFat += metaFat; sumVol += metaVol;
                totalAvgFat += avgFat; totalPrevFat += cPrevFat;
                totalAvgVol += avgVol; totalPrevVol += cPrevVol;
                sumActiveMonths += activeMonthsCount; totalPrevClients += isActivePrevMonth;

            }, () => {
                if (currentRenderId !== goalsRenderId) return;

                // Finalize Render
                const totalAvgClients = sumActiveMonths / QUARTERLY_DIVISOR;

                const fatInput = document.getElementById('goal-global-fat');
                const volInput = document.getElementById('goal-global-vol');
                const btnDistributeFat = document.getElementById('btn-distribute-fat');
                const btnDistributeVol = document.getElementById('btn-distribute-vol');
                const isAggregatedTab = currentGoalsSupplier === 'ELMA_ALL' || currentGoalsSupplier === 'FOODS_ALL' || currentGoalsSupplier === 'PEPSICO_ALL';

                if (fatInput) {
                    if (document.activeElement !== fatInput) {
                        const displayFat = (sumFat === 0 && totalPrevFat > 0) ? totalPrevFat : sumFat;
                        fatInput.value = displayFat.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                    }
                    fatInput.readOnly = false; fatInput.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                if (volInput) {
                    if (document.activeElement !== volInput) {
                        const displayVol = (sumVol === 0 && totalPrevVol > 0) ? totalPrevVol : sumVol;
                        volInput.value = displayVol.toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });
                    }
                    volInput.readOnly = false; volInput.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                if (btnDistributeFat) btnDistributeFat.style.display = '';
                if (btnDistributeVol) btnDistributeVol.style.display = '';

                // KPIs
                const refAvgFat = document.getElementById('ref-avg-fat'); if(refAvgFat) refAvgFat.textContent = totalAvgFat.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
                const refPrevFat = document.getElementById('ref-prev-fat'); if(refPrevFat) refPrevFat.textContent = totalPrevFat.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
                const refAvgVol = document.getElementById('ref-avg-vol'); if(refAvgVol) refAvgVol.textContent = totalAvgVol.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' Kg';
                const refPrevVol = document.getElementById('ref-prev-vol'); if(refPrevVol) refPrevVol.textContent = totalPrevVol.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' Kg';
                const refAvgClients = document.getElementById('ref-avg-clients'); if(refAvgClients) refAvgClients.textContent = totalAvgClients.toLocaleString('pt-BR', { maximumFractionDigits: 1 });
                const refPrevClients = document.getElementById('ref-prev-clients'); if(refPrevClients) refPrevClients.textContent = totalPrevClients.toLocaleString('pt-BR');

                clientMetrics.sort((a, b) => b.metaFat - a.metaFat);

                const goalMixInput = document.getElementById('goal-global-mix');
                const btnDistributeMix = document.getElementById('btn-distribute-mix');
                const naturalTotalPos = clientMetrics.reduce((sum, item) => sum + item.metaPos, 0);
                const isSingleSeller = selectedGoalsGvSellers.length === 1;

                if (goalMixInput) {
                    const newMixInput = goalMixInput.cloneNode(true);
                    goalMixInput.parentNode.replaceChild(newMixInput, goalMixInput);

                    // Calculate Total Adjustment for Current View Context
                    let contextAdjustment = 0;
                    const adjustmentMap = goalsPosAdjustments[currentGoalsSupplier];

                    if (adjustmentMap) {
                        if (isSingleSeller) {
                            // Specific Seller Context
                            contextAdjustment = adjustmentMap.get(selectedGoalsGvSellers[0]) || 0;
                        } else {
                            const visibleSellers = new Set(clientMetrics.map(c => c.seller));
                            adjustmentMap.forEach((val, seller) => {
                                if (visibleSellers.has(seller)) {
                                    contextAdjustment += val;
                                }
                            });
                        }
                    }

                    const displayPos = naturalTotalPos + contextAdjustment;
                    newMixInput.value = displayPos.toLocaleString('pt-BR');

                    if (isSingleSeller) {
                        newMixInput.readOnly = false;
                        newMixInput.classList.remove('opacity-50', 'cursor-not-allowed');

                        if(btnDistributeMix) {
                            const newBtnDistributeMix = btnDistributeMix.cloneNode(true);
                            btnDistributeMix.parentNode.replaceChild(newBtnDistributeMix, btnDistributeMix);
                            newBtnDistributeMix.style.display = '';

                            newBtnDistributeMix.onclick = () => {
                            const valStr = newMixInput.value;
                            const val = parseFloat(valStr.replace(/\./g, '').replace(',', '.')) || 0;
                            const filterDesc = getFilterDescription();
                            // Validation: Check against PEPSICO Limit
                            const sellerName = selectedGoalsGvSellers[0];
                            let pepsicoNaturalPos = 0;
                            // Calculate Natural PEPSICO Positivação for this seller
                            const len = allClientsData.length;
                            for(let i=0; i<len; i++) {
                                const c = allClientsData instanceof ColumnarDataset ? allClientsData.get(i) : allClientsData[i];

                            const rca = c.rcas[0];
                            const sName = optimizedData.rcaNameByCode.get(rca) || rca;
                            if (sName === sellerName) {
                            const historyIds = optimizedData.indices.history.byClient.get(c['Código']);
                            if (historyIds) {
                            for (let id of historyIds) {
                            const sale = optimizedData.historyById.get(id);
                            if ((sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9') &&
                            ['707','708','752','1119'].includes(String(sale.CODFOR))) {
                            pepsicoNaturalPos++;
                            break;
                            }
                            }
                            }
                            }

                            }
                const pepsicoAdj = goalsPosAdjustments['PEPSICO_ALL'].get(sellerName) || 0;
                            const pepsicoLimit = pepsicoNaturalPos + pepsicoAdj;
                            if (currentGoalsSupplier !== 'PEPSICO_ALL' && val > pepsicoLimit) {
                            alert(`O valor não pode ultrapassar a Meta de Positivação PEPSICO definida (${pepsicoLimit.toLocaleString('pt-BR')}).\n(Natural: ${pepsicoNaturalPos}, Ajuste PEPSICO: ${pepsicoAdj})`);
                            return;
                            }
                            showConfirmationModal(`Confirmar ajuste de Meta Positivação para ${valStr} (Cliente: ${filterDesc})?`, () => {
                            const newAdjustment = val - naturalTotalPos;
                            if (adjustmentMap) {
                            adjustmentMap.set(selectedGoalsGvSellers[0], newAdjustment);
                            updateGoalsView();
                            }
                            });
                            };
                        }
                    } else {
                        newMixInput.readOnly = true;
                        newMixInput.classList.add('opacity-50', 'cursor-not-allowed');
                        if(btnDistributeMix) btnDistributeMix.style.display = 'none';
                    }
                }

                // --- MIX SALTY & FOODS CARDS LOGIC (PEPSICO ONLY) ---
                const cardMixSalty = document.getElementById('card-mix-salty');
                const cardMixFoods = document.getElementById('card-mix-foods');

                if (currentGoalsSupplier === 'PEPSICO_ALL' || currentGoalsSupplier === 'ELMA_ALL' || currentGoalsSupplier === 'FOODS_ALL') {
                    if(cardMixSalty) cardMixSalty.classList.remove('hidden');
                    if(cardMixFoods) cardMixFoods.classList.remove('hidden');

                    // Logic to populate values and handle edit
                    let naturalMixBase = 0;
                    clientMetrics.forEach(c => {
                        // Check if not seller 1001 (Americanas)
                        const sellerCode = optimizedData.rcaCodeByName.get(c.seller) || '';
                        if (sellerCode !== '1001') {
                            if (c.metaPos > 0) naturalMixBase++; // Count positivations in PEPSICO_ALL (Total Pos)
                        }
                    });

                    const naturalSaltyTarget = Math.round(naturalMixBase * 0.50);
                    const naturalFoodsTarget = Math.round(naturalMixBase * 0.30);

                    const handleMixCard = (type, naturalTarget, adjustmentsMap, inputId, btnId) => {
                        let adj = 0;
                        if (isSingleSeller) {
                            adj = adjustmentsMap.get(selectedGoalsGvSellers[0]) || 0;
                        } else {
                            const visibleSellers = new Set(clientMetrics.map(c => c.seller));
                            adjustmentsMap.forEach((val, seller) => {
                                if (visibleSellers.has(seller)) adj += val;
                            });
                        }

                        const displayVal = naturalTarget + adj;
                        const input = document.getElementById(inputId);
                        const btn = document.getElementById(btnId);

                        if(input) {
                            input.value = displayVal.toLocaleString('pt-BR');

                            if (isSingleSeller) {
                                input.readOnly = false;
                                input.classList.remove('opacity-50', 'cursor-not-allowed');
                                if(btn) btn.style.display = '';
                            } else {
                                input.readOnly = true;
                                input.classList.add('opacity-50', 'cursor-not-allowed');
                                if(btn) btn.style.display = 'none';
                            }
                        }
                    };

                    // FORCE READ FROM PEPSICO_ALL KEY for Mix Cards
                    // Calculate Natural Base using ELMA metrics (excluding Americanas) for consistency

                    // Determine visible sellers set for filtering adjustments in helper
                    let visibleSellersSet = new Set(clientMetrics.map(c => c.seller));

                    // Bugfix: If table is empty (e.g. no active clients) but we have a specific seller filter,
                    // use the filter to prevent getElmaTargetBase from returning global counts (empty set bypass).
                    if (visibleSellersSet.size === 0 && selectedGoalsGvSellers.length > 0) {
                         visibleSellersSet = new Set(selectedGoalsGvSellers);
                    }

                    const elmaTargetBase = getElmaTargetBase(displayMetrics, goalsPosAdjustments, visibleSellersSet);

                    // Card Natural Targets (Based on ELMA: 50% Salty / 30% Foods)
                    const globalNaturalSalty = Math.round(elmaTargetBase * 0.50);
                    const globalNaturalFoods = Math.round(elmaTargetBase * 0.30);

                    if (goalsMixSaltyAdjustments['PEPSICO_ALL']) {
                        handleMixCard('Salty', globalNaturalSalty, goalsMixSaltyAdjustments['PEPSICO_ALL'], 'goal-global-mix-salty', 'btn-distribute-mix-salty');
                    }
                    if (goalsMixFoodsAdjustments['PEPSICO_ALL']) {
                        handleMixCard('Foods', globalNaturalFoods, goalsMixFoodsAdjustments['PEPSICO_ALL'], 'goal-global-mix-foods', 'btn-distribute-mix-foods');
                    }

                } else {
                    if(cardMixSalty) cardMixSalty.classList.add('hidden');
                    if(cardMixFoods) cardMixFoods.classList.add('hidden');
                }

                goalsTableState.filteredData = clientMetrics;
                goalsTableState.totalPages = Math.ceil(clientMetrics.length / goalsTableState.itemsPerPage);
                if (goalsTableState.currentPage > goalsTableState.totalPages && goalsTableState.totalPages > 0) goalsTableState.currentPage = goalsTableState.totalPages;
                else if (goalsTableState.totalPages === 0) goalsTableState.currentPage = 1;

                const startIndex = (goalsTableState.currentPage - 1) * goalsTableState.itemsPerPage;
                const endIndex = startIndex + goalsTableState.itemsPerPage;
                const pageData = clientMetrics.slice(startIndex, endIndex);
                const paginationControls = document.getElementById('goals-pagination-controls');
                const pageInfo = document.getElementById('goals-page-info-text');
                const prevBtn = document.getElementById('goals-prev-page-btn');
                const nextBtn = document.getElementById('goals-next-page-btn');

                if (clientMetrics.length === 0) {
                    goalsGvTableBody.innerHTML = `<tr><td colspan="${12 + quarterMonths.length}" class="text-center p-4 text-slate-500">Nenhum cliente encontrado nos filtros para este fornecedor.</td></tr>`;
                    if (paginationControls) paginationControls.classList.add('hidden');
                } else {
                    const rows = pageData.map(item => {
                        const monthCells = quarterMonths.map(m => `<td class="px-2 py-2 text-right text-slate-400 border-r border-slate-800/50 text-[10px] bg-blue-900/5">${(item.monthlyValues[m.key] || 0).toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`).join('');
                        return `<tr class="hover:bg-slate-800 group transition-colors border-b border-slate-800"><td class="px-2 py-2 text-center border-r border-slate-800 bg-[#151c36] text-xs text-slate-300">${item.cod}</td><td class="px-2 py-2 text-left border-r border-slate-800 bg-[#151c36] text-xs font-bold text-white truncate max-w-[200px]" title="${item.name}">${(item.name || '').substring(0, 30)}</td><td class="px-2 py-2 text-left border-r border-slate-800 bg-[#151c36] text-[10px] text-slate-400 uppercase">${getFirstName(item.seller)}</td>${monthCells}<td class="px-2 py-2 text-right text-slate-300 font-medium bg-blue-900/10 border-r border-slate-800/50 text-xs">${item.avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-2 py-2 text-center text-blue-400 text-xs bg-blue-900/10 border-r border-slate-800/50">${(item.shareFat * 100).toFixed(2)}%</td><td class="px-2 py-2 text-right font-bold text-blue-200 bg-blue-900/20 border-r border-slate-800 text-xs">${item.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-2 py-2 text-right text-slate-300 font-medium bg-orange-900/10 border-r border-slate-800/50 text-xs">${item.avgVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-2 py-2 text-center text-orange-400 text-xs bg-orange-900/10 border-r border-slate-800/50">${(item.shareVol * 100).toFixed(2)}%</td><td class="px-2 py-2 text-right font-bold text-orange-200 bg-orange-900/20 border-r border-slate-800 text-xs">${item.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-2 py-2 text-center font-bold text-purple-300 bg-purple-900/10 text-xs">${item.metaPos}</td></tr>`;
                    }).join('');
                    goalsGvTableBody.innerHTML = rows;
                    if (paginationControls) {
                        paginationControls.classList.remove('hidden');

                        let exportBtn = document.getElementById('btn-export-goals-gv');
                        if (!exportBtn) {
                             const btnContainer = document.createElement('div');
                             btnContainer.className = "flex items-center ml-4";
                             btnContainer.innerHTML = `<button id="btn-export-goals-gv" class="flex items-center space-x-1 text-xs font-bold text-green-400 hover:text-green-300 border border-green-500/30 hover:border-green-500/50 bg-green-500/10 hover:bg-green-500/20 px-3 py-1.5 rounded transition-colors" title="Exportar tabela completa (XLSX)">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                    <span>XLSX</span>
                                </button>`;
                             pageInfo.parentNode.insertBefore(btnContainer, pageInfo.nextSibling);
                             document.getElementById('btn-export-goals-gv').addEventListener('click', exportGoalsCurrentTabXLSX);
                        }

                        pageInfo.textContent = `Página ${goalsTableState.currentPage} de ${goalsTableState.totalPages} (Total: ${clientMetrics.length})`;
                        prevBtn.disabled = goalsTableState.currentPage === 1;
                        nextBtn.disabled = goalsTableState.currentPage === goalsTableState.totalPages;
                    }
                }
            }, () => currentRenderId !== goalsRenderId);
        }

        function getGoalsSvFilteredData() {
            const supervisorsSet = new Set(selectedGoalsSvSupervisors);

            let clients = allClientsData;

            clients = clients.filter(c => {
                const rca1 = String(c.rca1 || '').trim();
                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                if (isAmericanas) return true;
                // STRICT FILTER: Exclude RCA 53 (Balcão) and INATIVOS
                if (rca1 === '53') return false;
                if (rca1 === '') return false; // Exclude INATIVOS
                return true;
            });

            if (supervisorsSet.size > 0) {
                const rcasSet = new Set();
                supervisorsSet.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasSet.add(rca));
                });
                clients = clients.filter(c => c.rcas.some(r => rcasSet.has(r)));
            }

            return clients;
        }

        function recalculateGoalsSvTotals(input) {
            const { supId, colId, field, sellerId } = input.dataset;

            // Helper to parse input value
            const parseVal = (str) => {
                let val = parseFloat(str.replace(/\./g, '').replace(',', '.'));
                return isNaN(val) ? 0 : val;
            };

            // Helper to calculate and update column totals (Supervisor and Grand)
            const updateColumnTotals = (cId, fld) => {
                // 1. Supervisor Total
                // For 'geral', the values are in spans (text), for others inputs.
                let supSum = 0;
                if (cId === 'geral') {
                    const supCells = document.querySelectorAll(`.goals-sv-text[data-sup-id="${supId}"][data-col-id="${cId}"][data-field="${fld}"]`);
                    supCells.forEach(el => supSum += parseVal(el.textContent));
                } else {
                    const supInputs = document.querySelectorAll(`.goals-sv-input[data-sup-id="${supId}"][data-col-id="${cId}"][data-field="${fld}"]`);
                    supInputs.forEach(inp => supSum += parseVal(inp.value));
                }

                const supTotalEl = document.getElementById(`total-sup-${supId}-${cId}-${fld}`);
                if (supTotalEl) {
                    if (fld === 'fat') supTotalEl.textContent = supSum.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                    else if (fld === 'vol' || fld === 'ton') supTotalEl.textContent = supSum.toLocaleString('pt-BR', {minimumFractionDigits: 3, maximumFractionDigits: 3});
                    else supTotalEl.textContent = supSum;
                }

                // 2. Grand Total
                let grandSum = 0;
                if (cId === 'geral') {
                    const allCells = document.querySelectorAll(`.goals-sv-text[data-col-id="${cId}"][data-field="${fld}"]`);
                    allCells.forEach(el => grandSum += parseVal(el.textContent));
                } else {
                    const allInputs = document.querySelectorAll(`.goals-sv-input[data-col-id="${cId}"][data-field="${fld}"]`);
                    allInputs.forEach(inp => grandSum += parseVal(inp.value));
                }

                const grandTotalEl = document.getElementById(`total-grand-${cId}-${fld}`);
                if (grandTotalEl) {
                    if (fld === 'fat') grandTotalEl.textContent = grandSum.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                    else if (fld === 'vol' || fld === 'ton') grandTotalEl.textContent = grandSum.toLocaleString('pt-BR', {minimumFractionDigits: 3, maximumFractionDigits: 3});
                    else grandTotalEl.textContent = grandSum;
                }
            };

            // A. Update Current Column Totals
            updateColumnTotals(colId, field);

            // B. Row Aggregation Logic (Update Total Elma/Foods and Geral)
            const elmaIds = ['707', '708', '752'];
            const foodsIds = ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'];

            let groupTotalId = null;
            let components = [];

            if (elmaIds.includes(colId)) {
                groupTotalId = 'total_elma';
                components = elmaIds;
            } else if (foodsIds.includes(colId)) {
                groupTotalId = 'total_foods';
                components = foodsIds;
            }

            // Only aggregate if we are editing a base column (not changing mix or tonnage directly if those were editable)
            if (groupTotalId) {
                // 1. Recalculate Group Total (Row)
                let groupSum = 0;
                components.forEach(cId => {
                    const el = document.querySelector(`.goals-sv-input[data-seller-id="${sellerId}"][data-col-id="${cId}"][data-field="${field}"]`);
                    if (el) groupSum += parseVal(el.value);
                });

                // Update Group Total Input (Read-only)
                const groupInput = document.querySelector(`.goals-sv-input[data-seller-id="${sellerId}"][data-col-id="${groupTotalId}"][data-field="${field}"]`);
                if (groupInput) {
                    if (field === 'fat') groupInput.value = groupSum.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                    else if (field === 'vol') groupInput.value = groupSum.toLocaleString('pt-BR', {minimumFractionDigits: 3, maximumFractionDigits: 3});
                    else groupInput.value = groupSum; // Pos

                    // Update Column Totals for the Group Column
                    updateColumnTotals(groupTotalId, field);

                    // Special Logic: If updating TOTAL ELMA POS, update PEDEV
                    if (groupTotalId === 'total_elma' && field === 'pos') {
                        const pedevVal = Math.round(groupSum * 0.9);
                        const pedevCell = document.getElementById(`pedev-${sellerId}-pos`);
                        if (pedevCell) {
                            pedevCell.textContent = pedevVal;
                            updateColumnTotals('pedev', 'pos');
                        }
                    }
                }
            }

            // 2. Recalculate GERAL Total (Row) - Only for Fat and Vol/Ton
            // Geral Pos is static (Active Clients), so we don't update it on input change
            if (field === 'fat' || field === 'vol') {
                const elmaInput = document.querySelector(`.goals-sv-input[data-seller-id="${sellerId}"][data-col-id="total_elma"][data-field="${field}"]`);
                const foodsInput = document.querySelector(`.goals-sv-input[data-seller-id="${sellerId}"][data-col-id="total_foods"][data-field="${field}"]`);

                let elmaVal = elmaInput ? parseVal(elmaInput.value) : 0;
                let foodsVal = foodsInput ? parseVal(foodsInput.value) : 0;
                let geralSum = elmaVal + foodsVal;

                // Map field 'vol' to 'ton' for Geral if needed, or keep consistent
                // In column definitions: 'tonelada_elma' is type 'tonnage' (field 'vol'). 'geral' is type 'geral'.
                // Geral uses field 'fat' and 'ton'.
                const geralField = field === 'vol' ? 'ton' : field;

                const geralCell = document.getElementById(`geral-${sellerId}-${geralField}`);
                if (geralCell) {
                    if (geralField === 'fat') geralCell.textContent = geralSum.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                    else geralCell.textContent = geralSum.toLocaleString('pt-BR', {minimumFractionDigits: 3, maximumFractionDigits: 3});

                    // Update Column Totals for Geral
                    updateColumnTotals('geral', geralField);
                }
            }
        }

        function updateGoalsSvView() {
            goalsSvRenderId++;
            const currentRenderId = goalsSvRenderId;

            if (quarterMonths.length === 0) identifyQuarterMonths();
            const filteredClients = getGoalsSvFilteredData();

            // Define Column Blocks (Metrics Config)
            const svColumns = [
                { id: 'total_elma', label: 'TOTAL ELMA', type: 'standard', isAgg: true, colorClass: 'text-teal-400', components: ['707', '708', '752'] },
                { id: '707', label: 'EXTRUSADOS', type: 'standard', supplier: '707', brand: null, colorClass: 'text-slate-300' },
                { id: '708', label: 'NÃO EXTRUSADOS', type: 'standard', supplier: '708', brand: null, colorClass: 'text-slate-300' },
                { id: '752', label: 'TORCIDA', type: 'standard', supplier: '752', brand: null, colorClass: 'text-slate-300' },
                { id: 'tonelada_elma', label: 'KG ELMA', type: 'tonnage', isAgg: true, colorClass: 'text-orange-400', components: ['707', '708', '752'] },
                { id: 'mix_salty', label: 'MIX SALTY', type: 'mix', isAgg: true, colorClass: 'text-teal-400', components: [] },
                { id: 'total_foods', label: 'TOTAL FOODS', type: 'standard', isAgg: true, colorClass: 'text-yellow-400', components: ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'] },
                { id: '1119_TODDYNHO', label: 'TODDYNHO', type: 'standard', supplier: '1119', brand: 'TODDYNHO', colorClass: 'text-slate-300' },
                { id: '1119_TODDY', label: 'TODDY', type: 'standard', supplier: '1119', brand: 'TODDY', colorClass: 'text-slate-300' },
                { id: '1119_QUAKER_KEROCOCO', label: 'QUAKER / KEROCOCO', type: 'standard', supplier: '1119', brand: 'QUAKER_KEROCOCO', colorClass: 'text-slate-300' },
                { id: 'tonelada_foods', label: 'KG FOODS', type: 'tonnage', isAgg: true, colorClass: 'text-orange-400', components: ['1119_TODDYNHO', '1119_TODDY', '1119_QUAKER_KEROCOCO'] },
                { id: 'mix_foods', label: 'MIX FOODS', type: 'mix', isAgg: true, colorClass: 'text-yellow-400', components: [] },
                { id: 'geral', label: 'GERAL', type: 'geral', isAgg: true, colorClass: 'text-white', components: ['total_elma', 'total_foods'] },
                { id: 'pedev', label: 'AUDITORIA PEDEV', type: 'pedev', isAgg: true, colorClass: 'text-pink-400', components: ['total_elma'] }
            ];

            const baseCategories = svColumns.filter(c => c.type === 'standard' && !c.isAgg);
            const mainTable = document.getElementById('goals-sv-main-table');
            if (mainTable) mainTable.innerHTML = '<tbody><tr><td class="text-center p-8"><svg class="animate-spin h-8 w-8 text-teal-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></td></tr></tbody>';

            // Ensure Global Totals are cached (Sync operation, but fast enough for initialization)
            baseCategories.forEach(cat => {
                const cacheKey = cat.supplier + (cat.brand ? `_${cat.brand}` : '');
                if (!globalGoalsTotalsCache[cacheKey]) calculateDistributedGoals([], cat.supplier, cat.brand, 0, 0);
            });

            // Prepare Aggregation Structures
            const sellerMap = new Map();
            const initSeller = (sellerName) => {
                if (!sellerMap.has(sellerName)) {
                    let sellerCode = optimizedData.rcaCodeByName.get(sellerName) || '';
                    let supervisorName = 'N/A';
                    if (sellerCode) {
                        for (const [sup, rcas] of optimizedData.rcasBySupervisor) {
                            if (rcas.includes(sellerCode)) { supervisorName = sup; break; }
                        }
                    }
                    sellerMap.set(sellerName, { name: sellerName, code: sellerCode, supervisor: supervisorName, data: {}, metaPosTotal: 0, elmaPos: 0, foodsPos: 0 });
                }
                return sellerMap.get(sellerName);
            };

            const currentDate = lastSaleDate;
            const prevMonthDate = new Date(Date.UTC(currentDate.getUTCFullYear(), currentDate.getUTCMonth() - 1, 1));
            const prevMonthIndex = prevMonthDate.getUTCMonth();
            const prevMonthYear = prevMonthDate.getUTCFullYear();

            // Optimization: Normalize functions outside loop
            const norm = (str) => str ? str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase() : '';

            // ASYNC LOOP
            runAsyncChunked(filteredClients, (client) => {
                const codCli = String(client['Código'] || client['codigo_cliente']);
                const clientHistoryIds = optimizedData.indices.history.byClient.get(codCli);

                let sellerName = 'N/A';
                const rcaCode = client.rcas[0];
                if (rcaCode) sellerName = optimizedData.rcaNameByCode.get(rcaCode) || rcaCode;
                else if (client.rcas.length === 0 || client.rcas[0] === '') sellerName = 'INATIVOS';
                const sellerObj = initSeller(sellerName);

                // Initialize client totals for each category
                const clientCatTotals = {};
                baseCategories.forEach(c => clientCatTotals[c.id] = { fat: 0, vol: 0, pos: 0, prevFat: 0, monthly: {} });

                // Single Pass over History for this Client
                if (clientHistoryIds) {
                    clientHistoryIds.forEach(id => {
                        const sale = optimizedData.historyById.get(id);
                        // EXCEPTION: Exclude Balcão (53) sales for Client 9569 from Portfolio Analysis
                        if (String(codCli).trim() === '9569' && (String(sale.CODUSUR).trim() === '53' || String(sale.CODUSUR).trim() === '053')) return;

                        const isRev = (sale.TIPOVENDA === '1' || sale.TIPOVENDA === '9');
                        if (!isRev) return;

                        const codFor = String(sale.CODFOR);
                        let matchedCats = [];

                        // Determine which categories this sale belongs to
                        if (codFor === '707') matchedCats.push('707');
                        else if (codFor === '708') matchedCats.push('708');
                        else if (codFor === '752') matchedCats.push('752');
                        else if (codFor === '1119') {
                            const desc = norm(sale.DESCRICAO || '');
                            if (desc.includes('TODDYNHO')) matchedCats.push('1119_TODDYNHO');
                            else if (desc.includes('TODDY')) matchedCats.push('1119_TODDY');
                            else if (desc.includes('QUAKER') || desc.includes('KEROCOCO')) matchedCats.push('1119_QUAKER_KEROCOCO');
                        }

                        if (matchedCats.length > 0) {
                            const d = parseDate(sale.DTPED);
                            const isPrev = d && d.getUTCMonth() === prevMonthIndex && d.getUTCFullYear() === prevMonthYear;
                            const monthKey = d ? `${d.getUTCFullYear()}-${d.getUTCMonth()}` : null;

                            matchedCats.forEach(catId => {
                                const t = clientCatTotals[catId];
                                t.fat += sale.VLVENDA;
                                t.vol += sale.TOTPESOLIQ;
                                if (isPrev) t.prevFat += sale.VLVENDA;
                                if (monthKey) t.monthly[monthKey] = (t.monthly[monthKey] || 0) + sale.VLVENDA;
                            });
                        }
                    });
                }

                // Aggregate to Seller
                baseCategories.forEach(cat => {
                    const t = clientCatTotals[cat.id];
                    if (!sellerObj.data[cat.id]) sellerObj.data[cat.id] = { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgFat: 0, monthlyValues: {} };
                    const sData = sellerObj.data[cat.id];

                    const avgFat = t.fat / QUARTERLY_DIVISOR;
                    const avgVol = t.vol / QUARTERLY_DIVISOR;
                    const metaPos = t.fat > 1 ? 1 : 0;

                    // Fetch Stored Goal
                    let metaFat = 0; let metaVol = 0;
                    if (globalClientGoals.has(codCli)) {
                        const cacheKey = cat.supplier + (cat.brand ? `_${cat.brand}` : '');
                        const cGoals = globalClientGoals.get(codCli);
                        if (cGoals.has(cacheKey)) { const g = cGoals.get(cacheKey); metaFat = g.fat; metaVol = g.vol; }
                    }

                    sData.metaFat += metaFat;
                    sData.metaVol += metaVol;
                    sData.metaPos += metaPos;
                    sData.avgVol += avgVol;
                    sData.avgFat += avgFat;

                    // Monthly Breakdown
                    quarterMonths.forEach(m => {
                        if (!sData.monthlyValues[m.key]) sData.monthlyValues[m.key] = 0;
                        sData.monthlyValues[m.key] += (t.monthly[m.key] || 0);
                    });
                });

                // Calculate Aggregate Positivation for Client (Unique Client Count)
                let clientElmaFat = (clientCatTotals['707']?.fat || 0) + (clientCatTotals['708']?.fat || 0) + (clientCatTotals['752']?.fat || 0);
                if (clientElmaFat > 1) sellerObj.elmaPos++;

                let clientFoodsFat = (clientCatTotals['1119_TODDYNHO']?.fat || 0) + (clientCatTotals['1119_TODDY']?.fat || 0) + (clientCatTotals['1119_QUAKER_KEROCOCO']?.fat || 0);
                if (clientFoodsFat > 1) sellerObj.foodsPos++;

            }, () => {
                if (currentRenderId !== goalsSvRenderId) return;

                // --- FINALIZE AGGREGATION & RENDER ---

                // 1. Calculate Aggregates (Mix, Geral, etc.)
                sellerMap.forEach(sellerObj => {
                    // Component Aggregates
                    svColumns.filter(c => c.isAgg && c.type !== 'mix' && c.type !== 'geral' && c.type !== 'pedev').forEach(aggCol => {
                        let sumFat = 0, sumVol = 0, sumPos = 0, sumAvgVol = 0, sumAvgFat = 0;
                        const monthlySum = {}; quarterMonths.forEach(m => monthlySum[m.key] = 0);
                        aggCol.components.forEach(compId => {
                            if (sellerObj.data[compId]) {
                                sumFat += sellerObj.data[compId].metaFat; sumVol += sellerObj.data[compId].metaVol;
                                sumPos += sellerObj.data[compId].metaPos; sumAvgVol += sellerObj.data[compId].avgVol;
                                sumAvgFat += sellerObj.data[compId].avgFat || 0;
                                quarterMonths.forEach(m => monthlySum[m.key] += (sellerObj.data[compId].monthlyValues[m.key] || 0));
                            }
                        });

                        // Use calculated unique client count for Total Elma/Foods
                        if (aggCol.id === 'total_elma') sumPos = sellerObj.elmaPos || 0;
                        else if (aggCol.id === 'total_foods') sumPos = sellerObj.foodsPos || 0;

                        sellerObj.data[aggCol.id] = { metaFat: sumFat, metaVol: sumVol, metaPos: sumPos, avgVol: sumAvgVol, avgFat: sumAvgFat, monthlyValues: monthlySum };
                    });

                    // Mix Metrics
                    const historyIds = optimizedData.indices.history.byRca.get(sellerObj.name) || [];
                    let activeClientsCount = 0;

                    // Logic for Active Clients (Positivados Geral > 1)
                    // We need to check if ANY sale > 1 for this client in history
                    // Optimized: Reuse indices
                    // We iterate filteredClients to find active ones for this seller?
                    // No, "Meta Pos Total" is defined as unique active clients for the seller in the filtered list.
                    // We can re-iterate filteredClients? No, slow.
                    // We can aggregate during the main loop.
                    // Let's do it simply:
                    const sellerClients = filteredClients.filter(c => {
                        const code = c.rcas[0];
                        const name = optimizedData.rcaNameByCode.get(code) || code;
                        return name === sellerObj.name;
                    });
                    sellerClients.forEach(c => {
                        // Check if active (Total Fat > 1 in history)
                        const hIds = optimizedData.indices.history.byClient.get(c['Código']);
                        let totalFat = 0;
                        if(hIds) {
                            for (const id of hIds) {
                                const s = optimizedData.historyById.get(id);
                                const codFor = String(s.CODFOR);
                                if (['707', '708', '752', '1119'].includes(codFor)) {
                                    if (s.TIPOVENDA === '1' || s.TIPOVENDA === '9') totalFat += s.VLVENDA;
                                }
                            }
                        }
                        if (totalFat > 1) activeClientsCount++;
                    });

                    // Mix Calc (re-implement or optimize?)
                    // Mix calculation requires detailed product analysis per client.
                    // For speed, let's assume we can do it sync here for 1 seller's history (smaller dataset).
                    const monthlyData = new Map();
                    historyIds.forEach(id => {
                        const sale = optimizedData.historyById.get(id);
                        if (sale.TIPOVENDA !== '1' && sale.TIPOVENDA !== '9') return; // Strict Type Check
                        const d = parseDate(sale.DTPED);
                        if (!d) return;
                        const mKey = `${d.getUTCFullYear()}-${d.getUTCMonth()}`;
                        if (!monthlyData.has(mKey)) monthlyData.set(mKey, new Map());
                        const cMap = monthlyData.get(mKey);
                        if (!cMap.has(sale.CODCLI)) cMap.set(sale.CODCLI, { salty: new Set(), foods: new Set() });
                        const cData = cMap.get(sale.CODCLI);
                        if (sale.VLVENDA > 1) {
                            const desc = norm(sale.DESCRICAO);
                            MIX_SALTY_CATEGORIES.forEach(cat => { if (desc.includes(cat)) cData.salty.add(cat); });
                            MIX_FOODS_CATEGORIES.forEach(cat => { if (desc.includes(cat)) cData.foods.add(cat); });
                        }
                    });
                    let sumSalty = 0; let sumFoods = 0;
                    const months = Array.from(monthlyData.keys()).sort().slice(-3);
                    const divisor = months.length > 0 ? months.length : 1;
                    months.forEach(m => {
                        const cMap = monthlyData.get(m);
                        let mSalty = 0; let mFoods = 0;
                        cMap.forEach(d => {
                            if (d.salty.size >= MIX_SALTY_CATEGORIES.length) mSalty++;
                            if (d.foods.size >= MIX_FOODS_CATEGORIES.length) mFoods++;
                        });
                        sumSalty += mSalty; sumFoods += mFoods;
                    });

                    // Calculate Mix Targets using ELMA Base (Natural + Adjustment) to match GV 'RESUMO' Logic
                    // Base logic: Active Elma Clients (elmaPos) + ELMA Adjustments
                    const elmaAdjForMix = goalsPosAdjustments['ELMA_ALL'] ? (goalsPosAdjustments['ELMA_ALL'].get(sellerObj.name) || 0) : 0;
                    const elmaBaseForMix = (sellerObj.elmaPos || 0) + elmaAdjForMix;

                    let mixSaltyMeta = Math.round(elmaBaseForMix * 0.50);
                    let mixFoodsMeta = Math.round(elmaBaseForMix * 0.30);

                    if (sellerObj.code === '1001') { mixSaltyMeta = 0; mixFoodsMeta = 0; }

                    sellerObj.data['mix_salty'] = { avgMix: sumSalty / divisor, metaMix: mixSaltyMeta };
                    sellerObj.data['mix_foods'] = { avgMix: sumFoods / divisor, metaMix: mixFoodsMeta };

                    // Geral & Pedev
                    const totalElma = sellerObj.data['total_elma'];
                    const totalFoods = sellerObj.data['total_foods'];

                    // Note: 'activeClientsCount' here is the Pepsico Natural Active Count.
                    // The 'geral' column will receive the 'PEPSICO_ALL' adjustment in the loop below.

                    sellerObj.data['geral'] = {
                        avgFat: (totalElma.avgFat || 0) + (totalFoods.avgFat || 0),
                        metaFat: totalElma.metaFat + totalFoods.metaFat,
                        metaVol: totalElma.metaVol + totalFoods.metaVol,
                        metaPos: activeClientsCount
                    };
                    // Pedev uses Total Elma (Natural). We'll update it after adjustment loop to be safe.
                    sellerObj.data['pedev'] = { metaPos: Math.round(totalElma.metaPos * 0.9) };
                });

                // Group Supervisors

                // --- APPLY ADJUSTMENTS TO SELLERS ---
                sellerMap.forEach(seller => {
                    const sellerName = seller.name;

                    // 1. Positivation Adjustments
                    // Map Column ID -> Adjustment Key
                    // IDs: 'total_elma'->'ELMA_ALL', 'total_foods'->'FOODS_ALL', 'geral'->'PEPSICO_ALL'
                    //      '707'->'707', etc.

                    const posKeys = {
                        'total_elma': 'ELMA_ALL',
                        'total_foods': 'FOODS_ALL',
                        'geral': 'PEPSICO_ALL', // GERAL uses PEPSICO_ALL for Positivação
                        '707': '707', '708': '708', '752': '752',
                        '1119_TODDYNHO': '1119_TODDY', // Wait, map keys?
                        '1119_TODDY': '1119_TODDY', // Check keys in globalGoalsMetrics
                        '1119_QUAKER_KEROCOCO': '1119_QUAKER_KEROCOCO'
                    };

                    // Specific Fix for Toddynho Key mismatch if any (1119_TODDYNHO vs 1119_TODDYNHO)
                    // My previous code used '1119_TODDYNHO'.
                    posKeys['1119_TODDYNHO'] = '1119_TODDYNHO';

                    for (const [colId, data] of Object.entries(seller.data)) {
                        // Apply Pos Adjustment
                        const adjKey = posKeys[colId] || colId; // Fallback to ID
                        if (goalsPosAdjustments[adjKey]) {
                            const adj = goalsPosAdjustments[adjKey].get(sellerName) || 0;
                            // Update Meta Pos: Natural (Summed from clients) + Adjustment
                            // Note: 'data.metaPos' currently holds Natural Count from client loop.
                            data.metaPos = data.metaPos + adj;
                        }

                        // Apply Mix Adjustment (Only for Mix Cols)
                        if (colId === 'mix_salty') {
                            const adj = goalsMixSaltyAdjustments['PEPSICO_ALL']?.get(sellerName) || 0;
                            // metaMix was calculated as Math.round(active * 0.5).
                            data.metaMix = data.metaMix + adj;
                        }
                        if (colId === 'mix_foods') {
                            const adj = goalsMixFoodsAdjustments['PEPSICO_ALL']?.get(sellerName) || 0;
                            data.metaMix = data.metaMix + adj;
                        }

                        // Apply Pedev Adjustment? (Calculated as 90% of Total Elma)
                        // This is calculated LATER in the supervisor loop?
                        // "sellerObj.data['pedev'] = { metaPos: Math.round(totalElma.metaPos * 0.9) };"
                        // This line exists inside the client loop (aggregating).
                        // Since we just updated total_elma.metaPos, we should re-calculate pedev here.
                    }

                    // Re-calculate PEDEV based on updated TOTAL ELMA
                    if (seller.data['total_elma'] && seller.data['pedev']) {
                         seller.data['pedev'].metaPos = Math.round(seller.data['total_elma'].metaPos * 0.9);
                    }

                    // Re-calculate GERAL based on updated components?
                    // GERAL components: total_elma, total_foods.
                    // "sellerObj.data['geral'] = { ... metaPos: activeClientsCount }"
                    // The 'activeClientsCount' in the loop was based on (Total Fat > 1).
                    // This is 'PEPSICO NATURAL'.
                    // So 'geral' key maps to PEPSICO_ALL adjustment.
                    // Handled above via posKeys['geral'] = 'PEPSICO_ALL'.
                });

const supervisorGroups = new Map();
                sellerMap.forEach(seller => {
                    const supName = seller.supervisor;
                    if (!supervisorGroups.has(supName)) supervisorGroups.set(supName, { name: supName, id: supName.replace(/[^a-zA-Z0-9]/g, '_'), code: optimizedData.supervisorCodeByName.get(supName) || '', sellers: [], totals: {} });
                    supervisorGroups.get(supName).sellers.push(seller);
                });

                // Aggregate Totals
                supervisorGroups.forEach(group => {
                    svColumns.forEach(col => {
                        if (!group.totals[col.id]) group.totals[col.id] = { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgMix: 0, metaMix: 0, avgFat: 0, monthlyValues: {} };
                        quarterMonths.forEach(m => group.totals[col.id].monthlyValues[m.key] = 0);
                        group.sellers.forEach(seller => {
                            if (seller.data[col.id]) {
                                const s = seller.data[col.id]; const t = group.totals[col.id];
                                t.metaFat += s.metaFat || 0; t.metaVol += s.metaVol || 0; t.metaPos += s.metaPos || 0;
                                t.avgVol += s.avgVol || 0; t.avgMix += s.avgMix || 0; t.metaMix += s.metaMix || 0; t.avgFat += s.avgFat || 0;
                                if (s.monthlyValues) quarterMonths.forEach(m => t.monthlyValues[m.key] += s.monthlyValues[m.key]);
                            }
                        });
                    });

                    // Recalculate Mix Targets for Supervisor using Group Aggregates to match Global Logic
                    // 1. Calculate Group Natural Base (Sum of sellers' natural bases)
                    // Note: 'metaPos' in 'geral' is the Natural PEPSICO Base (unique clients per seller)
                    // Must exclude Americanas (Code 1001) from Base Calculation
                    let groupPepsicoNatural = 0;
                    group.sellers.forEach(seller => {
                        if (seller.code !== '1001') {
                            groupPepsicoNatural += (seller.data['geral'] ? seller.data['geral'].metaPos : 0);
                        }
                    });

                    // 2. Calculate Group Adjustments
                    let groupPepsicoAdj = 0;
                    if (goalsPosAdjustments['PEPSICO_ALL']) {
                        group.sellers.forEach(seller => {
                            groupPepsicoAdj += (goalsPosAdjustments['PEPSICO_ALL'].get(seller.name) || 0);
                        });
                    }

                    const groupPepsicoBase = groupPepsicoNatural + groupPepsicoAdj;

                    // 3. Calculate Mix Targets
                    let groupMixSaltyMeta = Math.round(groupPepsicoBase * 0.50);
                    let groupMixFoodsMeta = Math.round(groupPepsicoBase * 0.30);

                    // 4. Add Mix Adjustments
                    let groupMixSaltyAdj = 0;
                    let groupMixFoodsAdj = 0;
                    if (goalsMixSaltyAdjustments['PEPSICO_ALL']) {
                        group.sellers.forEach(seller => groupMixSaltyAdj += (goalsMixSaltyAdjustments['PEPSICO_ALL'].get(seller.name) || 0));
                    }
                    if (goalsMixFoodsAdjustments['PEPSICO_ALL']) {
                        group.sellers.forEach(seller => groupMixFoodsAdj += (goalsMixFoodsAdjustments['PEPSICO_ALL'].get(seller.name) || 0));
                    }

                    // Override summed totals with recalculated totals
                    if (group.totals['mix_salty']) group.totals['mix_salty'].metaMix = groupMixSaltyMeta + groupMixSaltyAdj;
                    if (group.totals['mix_foods']) group.totals['mix_foods'].metaMix = groupMixFoodsMeta + groupMixFoodsAdj;
                });

                // Recalculate Grand Total (Geral PRIME) using Global Aggregates
                // We can sum the recalculated Group totals which are now consistent, or redo Global.
                // Let's redo Global to be absolutely sure "A = B".
                const grandTotalRow = { totals: {} };
                svColumns.forEach(col => grandTotalRow.totals[col.id] = { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgMix: 0, metaMix: 0, avgFat: 0 });

                // Sum standard metrics from groups
                supervisorGroups.forEach(group => {
                    svColumns.forEach(col => {
                        const s = group.totals[col.id]; const t = grandTotalRow.totals[col.id];
                        t.metaFat += s.metaFat; t.metaVol += s.metaVol; t.metaPos += s.metaPos;
                        t.avgVol += s.avgVol; t.avgMix += s.avgMix; t.avgFat += s.avgFat;
                        // Don't sum metaMix yet
                    });
                });

                // Recalculate Grand Total Mix
                // Calculate Global Natural Base excluding Americanas (using TOTAL_ELMA base as per RESUMO logic)
                let globalElmaNatural = 0;
                sellerMap.forEach(seller => {
                    if (seller.code !== '1001') {
                        globalElmaNatural += (seller.data['total_elma'] ? seller.data['total_elma'].metaPos : 0);
                    }
                });

                let globalElmaAdj = 0;
                let globalMixSaltyAdj = 0;
                let globalMixFoodsAdj = 0;

                // Iterate ALL sellers to get total adjustments
                sellerMap.forEach(seller => {
                    if (seller.code !== '1001') {
                        globalElmaAdj += (goalsPosAdjustments['ELMA_ALL'] ? (goalsPosAdjustments['ELMA_ALL'].get(seller.name) || 0) : 0);
                        globalMixSaltyAdj += (goalsMixSaltyAdjustments['PEPSICO_ALL'] ? (goalsMixSaltyAdjustments['PEPSICO_ALL'].get(seller.name) || 0) : 0);
                        globalMixFoodsAdj += (goalsMixFoodsAdjustments['PEPSICO_ALL'] ? (goalsMixFoodsAdjustments['PEPSICO_ALL'].get(seller.name) || 0) : 0);
                    }
                });

                const globalElmaBase = globalElmaNatural + globalElmaAdj;
                grandTotalRow.totals['mix_salty'].metaMix = Math.round(globalElmaBase * 0.50) + globalMixSaltyAdj;
                grandTotalRow.totals['mix_foods'].metaMix = Math.round(globalElmaBase * 0.30) + globalMixFoodsAdj;

                // We inject this fake Grand Total row logic into the sortedSupervisors array or handle it in rendering?
                // The rendering logic likely expects sortedSupervisors to contain only supervisors.
                // The "Geral PRIME" row is usually rendered separately in the footer.
                // Let's check the rendering loop below.

                const sortedSupervisors = Array.from(supervisorGroups.values()).sort((a, b) => (b.totals['total_elma']?.metaFat || 0) - (a.totals['total_elma']?.metaFat || 0));
                currentGoalsSvData = sortedSupervisors;

                // Render HTML
                if (!mainTable) return;
                const monthsCount = quarterMonths.length;
                let headerHTML = `<thead class="text-[10px] uppercase sticky top-0 z-20 bg-[#0f172a] text-slate-400"><tr><th rowspan="3" class="px-2 py-2 text-center w-16 border-r border-b border-slate-700">CÓD</th><th rowspan="3" class="px-3 py-2 text-left w-48 border-r border-b border-slate-700">VENDEDOR</th>`;
                svColumns.forEach(col => {
                    let colspan = 2;
                    if (col.type === 'standard') colspan = monthsCount + 1 + 4;
                    if (col.type === 'tonnage') colspan = 3; if (col.type === 'mix') colspan = 3; if (col.type === 'geral') colspan = 4;
                    headerHTML += `<th colspan="${colspan}" class="px-2 py-2 text-center font-bold border-r border-b border-slate-700 ${col.colorClass}">${col.label}</th>`;
                });
                headerHTML += `</tr><tr>`;
                svColumns.forEach(col => {
                    if (col.type === 'standard') headerHTML += `<th colspan="${monthsCount + 1}" class="px-1 py-1 text-center border-r border-slate-700/50 bg-slate-800/50">HISTÓRICO FAT.</th><th colspan="2" class="px-1 py-1 text-center border-r border-slate-700/50 bg-slate-800/50">FATURAMENTO</th><th colspan="2" class="px-1 py-1 text-center border-r border-slate-700 bg-slate-800/50">POSITIVAÇÃO</th>`;
                    else if (col.type === 'tonnage') headerHTML += `<th class="px-1 py-1 text-right border-r border-slate-700/50 bg-slate-800/50">MÉDIA TRIM.</th><th colspan="2" class="px-1 py-1 text-center border-r border-slate-700 bg-slate-800/50">META KG</th>`;
                    else if (col.type === 'mix') headerHTML += `<th class="px-1 py-1 text-right border-r border-slate-700/50 bg-slate-800/50">MÉDIA TRIM.</th><th colspan="2" class="px-1 py-1 text-center border-r border-slate-700 bg-slate-800/50">META MIX</th>`;
                    else if (col.type === 'geral') headerHTML += `<th colspan="2" class="px-1 py-1 text-center border-r border-slate-700/50 bg-slate-800/50">FATURAMENTO</th><th class="px-1 py-1 text-center border-r border-slate-700/50 bg-slate-800/50">KG</th><th class="px-1 py-1 text-center border-r border-slate-700 bg-slate-800/50">POSITIVAÇÃO</th>`;
                    else if (col.type === 'pedev') headerHTML += `<th class="px-1 py-1 text-center border-r border-slate-700/50 bg-slate-800/50">META</th>`;
                });
                headerHTML += `</tr><tr>`;
                const gearIcon = `<svg class="w-3 h-3 mx-auto text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>`;
                svColumns.forEach(col => {
                    if (col.type === 'standard') {
                        quarterMonths.forEach(m => headerHTML += `<th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal w-12">${m.label}</th>`);
                        headerHTML += `<th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Média</th><th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Meta</th><th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">${gearIcon}</th><th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">Meta</th><th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">${gearIcon}</th>`;
                    } else if (col.type === 'tonnage') headerHTML += `<th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Volume</th><th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Volume</th><th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">${gearIcon}</th>`;
                    else if (col.type === 'mix') headerHTML += `<th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Qtd</th><th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Meta</th><th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">${gearIcon}</th>`;
                    else if (col.type === 'geral') headerHTML += `<th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Média Trim.</th><th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Meta</th><th class="px-1 py-1 text-right border-r border-b border-slate-700 text-slate-500 font-normal">Meta</th><th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">Meta</th>`;
                    else if (col.type === 'pedev') headerHTML += `<th class="px-1 py-1 text-center border-r border-b border-slate-700 text-slate-500 font-normal">${gearIcon}</th>`;
                });
                headerHTML += `</tr></thead>`;

                let bodyHTML = `<tbody class="divide-y divide-slate-800 bg-[#151c36]">`;
                // Grand Totals calc
                const grandTotals = {}; svColumns.forEach(col => { grandTotals[col.id] = { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgMix: 0, metaMix: 0, avgFat: 0, monthlyValues: {} }; quarterMonths.forEach(m => grandTotals[col.id].monthlyValues[m.key] = 0); });

                sortedSupervisors.forEach((sup, index) => {
                    sup.id = `sup-${index}`;
                    svColumns.forEach(col => {
                        grandTotals[col.id].metaFat += sup.totals[col.id].metaFat; grandTotals[col.id].metaVol += sup.totals[col.id].metaVol; grandTotals[col.id].metaPos += sup.totals[col.id].metaPos;
                        grandTotals[col.id].avgVol += sup.totals[col.id].avgVol; grandTotals[col.id].avgMix += sup.totals[col.id].avgMix; grandTotals[col.id].metaMix += sup.totals[col.id].metaMix;
                        grandTotals[col.id].avgFat += sup.totals[col.id].avgFat;
                        if (sup.totals[col.id].monthlyValues) quarterMonths.forEach(m => grandTotals[col.id].monthlyValues[m.key] += sup.totals[col.id].monthlyValues[m.key]);
                    });

                    sup.sellers.sort((a, b) => (b.data['total_elma']?.metaFat || 0) - (a.data['total_elma']?.metaFat || 0));
                    sup.sellers.forEach(seller => {
                        bodyHTML += `<tr class="hover:bg-slate-800 border-b border-slate-800"><td class="px-2 py-1 text-center text-slate-400 font-mono">${seller.code}</td><td class="px-2 py-1 text-left text-white font-medium truncate max-w-[200px]" title="${seller.name}">${getFirstName(seller.name)}</td>`;
                        svColumns.forEach(col => {
                            const d = seller.data[col.id] || { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgMix: 0, metaMix: 0, avgFat: 0, monthlyValues: {} };
                            if (col.type === 'standard') {
                                const isReadOnly = col.isAgg; const inputClass = isReadOnly ? 'text-slate-400 font-bold opacity-70' : 'text-yellow-300'; const readonlyAttr = isReadOnly ? 'readonly' : ''; const cellBg = isReadOnly ? 'bg-[#151c36]' : 'bg-[#1e293b]';
                                quarterMonths.forEach(m => bodyHTML += `<td class="px-1 py-1 text-right text-slate-400 border-r border-slate-800/50 text-[10px] bg-blue-900/5">${(d.monthlyValues[m.key] || 0).toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`);
                                bodyHTML += `<td class="px-1 py-1 text-right text-slate-300 border-r border-slate-800/50 bg-blue-900/10 font-medium">${d.avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right ${col.colorClass} border-r border-slate-800/50 text-xs font-mono">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 ${cellBg} border-r border-slate-800/50"><input type="text" value="${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}" class="goals-sv-input bg-transparent text-right w-full outline-none ${inputClass} text-xs font-mono" data-sup-id="${sup.id}" data-col-id="${col.id}" data-seller-id="${seller.id || seller.name.replace(/\s+/g,'_')}" data-field="fat" oninput="recalculateGoalsSvTotals(this)" ${readonlyAttr}></td><td class="px-1 py-1 text-center text-slate-300 border-r border-slate-800/50">${d.metaPos}</td><td class="px-1 py-1 ${cellBg} border-r border-slate-800/50"><input type="text" value="${d.metaPos}" class="goals-sv-input bg-transparent text-center w-full outline-none ${inputClass} text-xs font-mono" data-sup-id="${sup.id}" data-col-id="${col.id}" data-seller-id="${seller.id || seller.name.replace(/\s+/g,'_')}" data-field="pos" oninput="recalculateGoalsSvTotals(this)" ${readonlyAttr}></td>`;
                            } else if (col.type === 'tonnage') {
                                bodyHTML += `<td class="px-1 py-1 text-right text-slate-300 border-r border-slate-800/50 font-mono text-xs">${d.avgVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-1 py-1 text-right text-slate-300 border-r border-slate-800/50 font-bold font-mono text-xs">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-1 py-1 bg-[#1e293b] border-r border-slate-800/50"><input type="text" value="${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}" class="goals-sv-input bg-transparent text-right w-full outline-none text-yellow-300 text-xs font-mono" data-sup-id="${sup.id}" data-col-id="${col.id}" data-field="vol" oninput="recalculateGoalsSvTotals(this)"></td>`;
                            } else if (col.type === 'mix') {
                                bodyHTML += `<td class="px-1 py-1 text-right text-slate-300 border-r border-slate-800/50">${d.avgMix.toLocaleString('pt-BR', {minimumFractionDigits: 1, maximumFractionDigits: 1})}</td><td class="px-1 py-1 text-right text-slate-300 border-r border-slate-800/50 font-bold">${d.metaMix}</td><td class="px-1 py-1 bg-[#1e293b] border-r border-slate-800/50"><input type="text" value="${d.metaMix}" class="goals-sv-input bg-transparent text-right w-full outline-none text-yellow-300 text-xs font-mono" data-sup-id="${sup.id}" data-col-id="${col.id}" data-field="mix" oninput="recalculateGoalsSvTotals(this)"></td>`;
                            } else if (col.type === 'geral') {
                                bodyHTML += `<td class="px-1 py-1 text-right text-slate-400 border-r border-slate-800/50 font-mono text-xs">${d.avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right text-white font-bold border-r border-slate-800/50 font-mono text-xs goals-sv-text" data-sup-id="${sup.id}" data-col-id="geral" data-field="fat" id="geral-${seller.id || seller.name.replace(/\s+/g,'_')}-fat">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right text-white font-bold border-r border-slate-800/50 font-mono text-xs goals-sv-text" data-sup-id="${sup.id}" data-col-id="geral" data-field="ton" id="geral-${seller.id || seller.name.replace(/\s+/g,'_')}-ton">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-1 py-1 text-center text-white font-bold border-r border-slate-800/50 font-mono text-xs goals-sv-text" data-sup-id="${sup.id}" data-col-id="geral" data-field="pos" id="geral-${seller.id || seller.name.replace(/\s+/g,'_')}-pos">${d.metaPos}</td>`;
                            } else if (col.type === 'pedev') {
                                bodyHTML += `<td class="px-1 py-1 text-center text-pink-400 font-bold border-r border-slate-800/50 font-mono text-xs goals-sv-text" data-sup-id="${sup.id}" data-col-id="pedev" data-field="pos" id="pedev-${seller.id || seller.name.replace(/\s+/g,'_')}-pos">${d.metaPos}</td>`;
                            }
                        });
                        bodyHTML += `</tr>`;
                    });

                    bodyHTML += `<tr class="bg-slate-800 font-bold border-b border-slate-600"><td class="px-2 py-2 text-center text-slate-400 font-mono">${sup.code}</td><td class="px-2 py-2 text-left text-white uppercase tracking-wider">${sup.name}</td>`;
                    svColumns.forEach(col => {
                        const d = sup.totals[col.id]; const color = col.id.includes('total') || col.type === 'tonnage' || col.type === 'mix' ? 'text-white' : 'text-slate-300';
                        if (col.type === 'standard') {
                            quarterMonths.forEach(m => bodyHTML += `<td class="px-1 py-1 text-right text-slate-400 border-r border-slate-700 text-[10px] bg-blue-900/5">${(d.monthlyValues[m.key] || 0).toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`);
                            bodyHTML += `<td class="px-1 py-1 text-right text-slate-300 border-r border-slate-700 bg-blue-900/10 font-medium">${d.avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right ${color} border-r border-slate-700">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right text-yellow-500/70 border-r border-slate-700" id="total-sup-${sup.id}-${col.id}-fat">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-center ${color} border-r border-slate-700">${d.metaPos}</td><td class="px-1 py-1 text-center text-yellow-500/70 border-r border-slate-700" id="total-sup-${sup.id}-${col.id}-pos">${d.metaPos}</td>`;
                        } else if (col.type === 'tonnage') bodyHTML += `<td class="px-1 py-1 text-right text-slate-300 border-r border-slate-700">${d.avgVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-1 py-1 text-right ${color} border-r border-slate-700">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-1 py-1 text-right text-yellow-500/70 border-r border-slate-700" id="total-sup-${sup.id}-${col.id}-vol">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td>`;
                        else if (col.type === 'mix') bodyHTML += `<td class="px-1 py-1 text-right text-slate-300 border-r border-slate-700">${d.avgMix.toLocaleString('pt-BR', {minimumFractionDigits: 1, maximumFractionDigits: 1})}</td><td class="px-1 py-1 text-right ${color} border-r border-slate-700">${d.metaMix}</td><td class="px-1 py-1 text-right text-yellow-500/70 border-r border-slate-700" id="total-sup-${sup.id}-${col.id}-mix">${d.metaMix}</td>`;
                        else if (col.type === 'geral') bodyHTML += `<td class="px-1 py-1 text-right text-slate-400 border-r border-slate-700">${d.avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right text-white border-r border-slate-700" id="total-sup-${sup.id}-geral-fat">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-1 text-right text-white border-r border-slate-700" id="total-sup-${sup.id}-geral-ton">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} Kg</td><td class="px-1 py-1 text-center text-white border-r border-slate-700" id="total-sup-${sup.id}-geral-pos">${d.metaPos}</td>`;
                        else if (col.type === 'pedev') bodyHTML += `<td class="px-1 py-1 text-center text-pink-400 border-r border-slate-700" id="total-sup-${sup.id}-pedev-pos">${Math.round(sup.totals['total_elma']?.metaPos * 0.9)}</td>`;
                    });
                    bodyHTML += `</tr>`;
                });

                // Grand Total
                bodyHTML += `<tr class="bg-[#0f172a] font-bold text-white border-t-2 border-slate-500 sticky bottom-0 z-20"><td class="px-2 py-3 text-center uppercase tracking-wider">GV</td><td class="px-2 py-3 text-left uppercase tracking-wider">Geral PRIME</td>`;
                svColumns.forEach(col => {
                    // Use recalculated grandTotalRow.totals instead of summed grandTotals
                    const d = grandTotalRow.totals[col.id] || { metaFat: 0, metaVol: 0, metaPos: 0, avgVol: 0, avgMix: 0, metaMix: 0, avgFat: 0 };
                    // Fallback to monthlyValues from original summation if needed (recalculation didn't handle it, but it's not critical for Meta Mix/Pos)
                    // Actually, let's use grandTotals for monthly/avgs and grandTotalRow for Metas if recalculated.
                    const dOrig = grandTotals[col.id];
                    const monthlyVals = dOrig ? dOrig.monthlyValues : {};
                    const avgFat = dOrig ? dOrig.avgFat : 0;
                    const avgVol = dOrig ? dOrig.avgVol : 0;
                    const avgMix = dOrig ? dOrig.avgMix : 0;

                    if (col.type === 'standard') {
                        quarterMonths.forEach(m => bodyHTML += `<td class="px-1 py-2 text-right text-slate-400 border-r border-slate-700 text-[10px] bg-blue-900/5">${(monthlyVals[m.key] || 0).toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`);
                        bodyHTML += `<td class="px-1 py-2 text-right text-teal-400 border-r border-slate-700 bg-blue-900/10">${avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-right text-teal-400 border-r border-slate-700">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-right text-teal-600/70 border-r border-slate-700" id="total-grand-${col.id}-fat">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-center text-purple-400 border-r border-slate-700">${d.metaPos}</td><td class="px-1 py-2 text-center text-purple-600/70 border-r border-slate-700" id="total-grand-${col.id}-pos">${d.metaPos}</td>`;
                    } else if (col.type === 'tonnage') bodyHTML += `<td class="px-1 py-2 text-right text-slate-400 border-r border-slate-700">${avgVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-right text-orange-400 border-r border-slate-700">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-right text-orange-600/70 border-r border-slate-700" id="total-grand-${col.id}-vol">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`;
                    else if (col.type === 'mix') bodyHTML += `<td class="px-1 py-2 text-right text-slate-400 border-r border-slate-700">${avgMix.toLocaleString('pt-BR', {minimumFractionDigits: 1, maximumFractionDigits: 1})}</td><td class="px-1 py-2 text-right text-cyan-400 border-r border-slate-700">${d.metaMix}</td><td class="px-1 py-2 text-right text-cyan-600/70 border-r border-slate-700" id="total-grand-${col.id}-mix">${d.metaMix}</td>`;
                    else if (col.type === 'geral') bodyHTML += `<td class="px-1 py-2 text-right text-slate-500 border-r border-slate-700">${avgFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-right text-white border-r border-slate-700" id="total-grand-geral-fat">${d.metaFat.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-right text-white border-r border-slate-700" id="total-grand-geral-ton">${d.metaVol.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td><td class="px-1 py-2 text-center text-white border-r border-slate-700" id="total-grand-geral-pos">${d.metaPos}</td>`;
                    else if (col.type === 'pedev') bodyHTML += `<td class="px-1 py-2 text-center text-pink-400 border-r border-slate-700" id="total-grand-pedev-pos">${Math.round(grandTotalRow.totals['total_elma']?.metaPos * 0.9)}</td>`;
                });
                bodyHTML += `</tr></tbody>`;
                mainTable.innerHTML = headerHTML + bodyHTML;
            }, () => currentRenderId !== goalsSvRenderId);
        }

        function handleGoalsFilterChange() {
            // Update Dropdown Lists based on available data?
            // Standard pattern: Update filter lists based on selection of others?
            // For now, simpler: Just update the view.
            if (window.goalsUpdateTimeout) clearTimeout(window.goalsUpdateTimeout);
            window.goalsUpdateTimeout = setTimeout(() => {
                // Update Seller Filter options based on Supervisor
                // Get all clients matching supervisor filter, extract sellers.
                // This is slightly different from sales-based filtering.
                // But we can stick to standard updateSellerFilter using 'allSalesData' or 'allClientsData'?
                // updateSellerFilter uses a sales/data array.
                // Let's use allSalesData for consistency with other views to populate seller lists.

                updateGoalsView();
            }, 50);
        }

        function resetGoalsGvFilters() {
            selectedGoalsGvSupervisors = [];
            selectedGoalsGvSellers = [];
            goalsGvCodcliFilter.value = '';

            selectedGoalsGvSupervisors = updateSupervisorFilter(goalsGvSupervisorFilterDropdown, goalsGvSupervisorFilterText, selectedGoalsGvSupervisors, allSalesData);
            selectedGoalsGvSellers = updateSellerFilter(selectedGoalsGvSupervisors, goalsGvSellerFilterDropdown, goalsGvSellerFilterText, selectedGoalsGvSellers, allSalesData);

            updateGoalsView();
        }

        // <!-- INÍCIO DO CÓDIGO RESTAURADO -->

        function getCoverageFilteredData(options = {}) {
            const { excludeFilter = null } = options;
            const isExcluded = (f) => excludeFilter === f || (Array.isArray(excludeFilter) && excludeFilter.includes(f));

            // Define filter sets from UI state
            const sellersNameSet = new Set(selectedCoverageSellers);
            const supervisorsSet = new Set(selectedCoverageSupervisors);
            const city = coverageCityFilter.value.trim().toLowerCase();
            const filial = coverageFilialFilter.value;
            const suppliersSet = new Set(selectedCoverageSuppliers);
            const productsSet = new Set(selectedCoverageProducts);
            const tiposVendaSet = new Set(selectedCoverageTiposVenda);

            // --- Client Filtering (Universe for KPIs) ---
            // This part still filters all clients, but it's necessary for the KPI denominator.
            // The main optimization is ensuring the sales data filtering is fast.
            let clients = allClientsData;
            if (filial !== 'ambas' || supervisorsSet.size > 0 || sellersNameSet.size > 0 || city) {
                const rcasOfSupervisor = new Set();
                if (!isExcluded('supervisor') && supervisorsSet.size > 0) {
                    supervisorsSet.forEach(sup => {
                        (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => rcasOfSupervisor.add(rca));
                    });
                }
                const rcasOfSellers = new Set();
                if (!isExcluded('seller') && sellersNameSet.size > 0) {
                     sellersNameSet.forEach(sellerName => {
                        const rcaCode = optimizedData.rcaCodeByName.get(sellerName);
                        if (rcaCode) rcasOfSellers.add(rcaCode);
                    });
                }
                clients = allClientsData.filter(c => {
                    if (filial !== 'ambas' && clientLastBranch.get(c['Código']) !== filial) return false;
                    const clientRcas = (c.rcas && Array.isArray(c.rcas)) ? c.rcas : [];
                    if (rcasOfSupervisor.size > 0 && !clientRcas.some(rca => rcasOfSupervisor.has(rca))) return false;
                    if (rcasOfSellers.size > 0 && !clientRcas.some(rca => rcasOfSellers.has(rca))) return false;
                    if (!isExcluded('city') && city && (!c.cidade || c.cidade.toLowerCase() !== city)) return false;
                    return true;
                });
            }
            const clientCodes = new Set(clients.map(c => c['Código']));

            // --- Sales Filtering (Optimized via Indices) ---
            const filters = {
                supervisor: supervisorsSet,
                seller: sellersNameSet,
                supplier: suppliersSet,
                product: productsSet,
                tipoVenda: tiposVendaSet,
                city: city,
                filial: filial,
                clientCodes: clientCodes // Pass client universe to correctly scope sales
            };

            let sales = getFilteredDataFromIndices(optimizedData.indices.current, optimizedData.salesById, filters, excludeFilter);
            let history = getFilteredDataFromIndices(optimizedData.indices.history, optimizedData.historyById, filters, excludeFilter);

            // Post-filtering for logic not supported by indices
            const unitPriceInput = document.getElementById('coverage-unit-price-filter');
            const unitPrice = unitPriceInput && unitPriceInput.value ? parseFloat(unitPriceInput.value) : null;
            if (unitPrice !== null) {
                const unitPriceFilter = s => (s.QTVENDA > 0 && Math.abs((s.VLVENDA / s.QTVENDA) - unitPrice) < 0.01);
                sales = sales.filter(unitPriceFilter);
                history = history.filter(unitPriceFilter);
            }

            return { sales, history, clients };
        }

        function updateAllCoverageFilters(options = {}) {
            const { skipFilter = null } = options;

            if (skipFilter !== 'supervisor') {
                const { sales: salesSup, history: historySup } = getCoverageFilteredData({ excludeFilter: 'supervisor' });
                const combinedDataSup = [...salesSup, ...historySup];
                selectedCoverageSupervisors = updateSupervisorFilter(document.getElementById('coverage-supervisor-filter-dropdown'), document.getElementById('coverage-supervisor-filter-text'), selectedCoverageSupervisors, combinedDataSup);
            }

            const { sales: salesSeller, history: historySeller } = getCoverageFilteredData({ excludeFilter: 'seller' });
            selectedCoverageSellers = updateSellerFilter(selectedCoverageSupervisors, coverageVendedorFilterDropdown, coverageVendedorFilterText, selectedCoverageSellers, [...salesSeller, ...historySeller], skipFilter === 'seller');

            const { sales: salesSupplier, history: historySupplier } = getCoverageFilteredData({ excludeFilter: ['supplier', 'product'] });
            selectedCoverageSuppliers = updateSupplierFilter(coverageSupplierFilterDropdown, coverageSupplierFilterText, selectedCoverageSuppliers, [...salesSupplier, ...historySupplier], 'coverage', skipFilter === 'supplier');

            const { sales: salesProd, history: historyProd } = getCoverageFilteredData({ excludeFilter: 'product' });
            selectedCoverageProducts = updateProductFilter(coverageProductFilterDropdown, coverageProductFilterText, selectedCoverageProducts, [...salesProd, ...historyProd], 'coverage', skipFilter === 'product');

            const { sales: salesTV, history: historyTV } = getCoverageFilteredData({ excludeFilter: 'tipoVenda' });
            selectedCoverageTiposVenda = updateTipoVendaFilter(coverageTipoVendaFilterDropdown, coverageTipoVendaFilterText, selectedCoverageTiposVenda, [...salesTV, ...historyTV], skipFilter === 'tipoVenda');
        }

        function handleCoverageFilterChange(options = {}) {
            // Debounce update to prevent UI freezing during rapid selection
            if (window.coverageUpdateTimeout) clearTimeout(window.coverageUpdateTimeout);
            window.coverageUpdateTimeout = setTimeout(() => {
                 updateAllCoverageFilters(options);
                 updateCoverageView();
            }, 10);
        }

        function resetCoverageFilters() {
            selectedCoverageSupervisors = [];
            coverageCityFilter.value = '';
            coverageFilialFilter.value = 'ambas';

            const unitPriceInput = document.getElementById('coverage-unit-price-filter');
            if(unitPriceInput) unitPriceInput.value = '';

            const workingDaysInput = document.getElementById('coverage-working-days-input');
            if(workingDaysInput) workingDaysInput.value = customWorkingDaysCoverage;

            selectedCoverageSellers = [];
            selectedCoverageSuppliers = [];
            selectedCoverageProducts = [];
            selectedCoverageTiposVenda = [];

            updateAllCoverageFilters();
            updateCoverageView();
        }

        function updateCoverageView() {
            coverageRenderId++;
            const currentRenderId = coverageRenderId;

            const { clients, sales, history } = getCoverageFilteredData();
            const productsToAnalyze = [...new Set([...sales.map(s => s.PRODUTO), ...history.map(s => s.PRODUTO)])];

            const sellers = selectedCoverageSellers;
            const sellerRcaCodes = new Set();
            if (sellers.length > 0) {
                sellers.forEach(sellerName => {
                    const rcaCode = optimizedData.rcaCodeByName.get(sellerName);
                    if (rcaCode) sellerRcaCodes.add(rcaCode);
                });
            } else if (selectedCoverageSupervisors.length > 0) {
                selectedCoverageSupervisors.forEach(sup => {
                    (optimizedData.rcasBySupervisor.get(sup) || []).forEach(rca => sellerRcaCodes.add(rca));
                });
            }

            const activeClientsForCoverage = clients.filter(c => {
                const codcli = c['Código'];
                const rca1 = String(c.rca1 || '').trim();

                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');
                return (isAmericanas || rca1 !== '53' || clientsWithSalesThisMonth.has(codcli));
            });
            const activeClientsCount = activeClientsForCoverage.length;
            const activeClientCodes = new Set(activeClientsForCoverage.map(c => c['Código']));

            coverageActiveClientsKpi.textContent = activeClientsCount.toLocaleString('pt-BR');

            // Show Loading State in Table
            coverageTableBody.innerHTML = '<tr><td colspan="8" class="text-center p-8"><div class="flex justify-center items-center"><svg class="animate-spin h-8 w-8 text-teal-500 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="text-slate-400">Calculando cobertura...</span></div></td></tr>';

            if (productsToAnalyze.length === 0) {
                coverageSelectionCoverageValueKpi.textContent = '0%';
                coverageSelectionCoverageCountKpi.textContent = `0 de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;
                coverageSelectionCoverageValueKpiPrevious.textContent = '0%';
                coverageSelectionCoverageCountKpiPrevious.textContent = `0 de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;
                coverageTopCoverageValueKpi.textContent = '0%';
                coverageTopCoverageProductKpi.textContent = '-';
                coverageTableBody.innerHTML = '<tr><td colspan="7" class="text-center p-8 text-slate-500">Nenhum produto selecionado ou encontrado para os filtros.</td></tr>';
                showNoDataMessage('coverageCityChart', 'Sem dados para exibir.');
                return;
            }

            const tableData = [];
            const clientsWhoGotSelectionCurrent = new Set();
            const clientsWhoGotSelectionPrevious = new Set();
            let topCoverageItem = { name: '-', coverage: 0, clients: 0 };
            const activeStockMap = getActiveStockMap(coverageFilialFilter.value);

            const currentMonth = lastSaleDate.getUTCMonth();
            const currentYear = lastSaleDate.getUTCFullYear();
            const prevMonthIdx = (currentMonth === 0) ? 11 : currentMonth - 1;
            const prevMonthYear = (currentMonth === 0) ? currentYear - 1 : currentYear;

            // --- CRITICAL OPTIMIZATION: Pre-aggregate everything ---

            // Maps for Box Quantities: Map<PRODUTO, Number>
            const boxesSoldCurrentMap = new Map();
            const boxesSoldPreviousMap = new Map();

            // Index for Trend Calculation: Map<PRODUTO, Array<Sale>>
            // We group all sales (current + history) by product to calculate trend efficiently
            const trendSalesMap = new Map();

            // Process Current Sales (O(N))
            // --- OTIMIZAÇÃO: Mapa invertido para performance O(1) no cálculo de cobertura ---
            const productClientsCurrent = new Map(); // Map<PRODUTO, Set<CODCLI>>
            const productClientsPrevious = new Map(); // Map<PRODUTO, Set<CODCLI>>

            // Use synchronous loops for initial map building as iterating sales (linear) is generally fast enough
            // (e.g. 50k sales ~ 50ms). Splitting this would require complex state management.
            // The bottleneck is the nested Product * Client check loop later.

            sales.forEach(s => {
                // Coverage Map (Inverted for Performance)
                if (!productClientsCurrent.has(s.PRODUTO)) productClientsCurrent.set(s.PRODUTO, new Set());
                productClientsCurrent.get(s.PRODUTO).add(s.CODCLI);

                // Box Quantity Map
                boxesSoldCurrentMap.set(s.PRODUTO, (boxesSoldCurrentMap.get(s.PRODUTO) || 0) + s.QTVENDA_EMBALAGEM_MASTER);

                // Trend Map
                if (!trendSalesMap.has(s.PRODUTO)) trendSalesMap.set(s.PRODUTO, []);
                trendSalesMap.get(s.PRODUTO).push(s);
            });

            // Process History Sales (O(N))
            history.forEach(s => {
                const d = parseDate(s.DTPED);
                const isPrevMonth = d && d.getUTCMonth() === prevMonthIdx && d.getUTCFullYear() === prevMonthYear;

                // Coverage Map (only if prev month)
                if (isPrevMonth) {
                    // Coverage Map (Inverted for Performance)
                    if (!productClientsPrevious.has(s.PRODUTO)) productClientsPrevious.set(s.PRODUTO, new Set());
                    productClientsPrevious.get(s.PRODUTO).add(s.CODCLI);

                    // Box Quantity Map (only if prev month)
                    boxesSoldPreviousMap.set(s.PRODUTO, (boxesSoldPreviousMap.get(s.PRODUTO) || 0) + s.QTVENDA_EMBALAGEM_MASTER);
                }

                // Trend Map (All history)
                if (!trendSalesMap.has(s.PRODUTO)) trendSalesMap.set(s.PRODUTO, []);
                trendSalesMap.get(s.PRODUTO).push(s);
            });

            // Pre-calculate global dates for Trend
            const endDate = parseDate(sortedWorkingDays[sortedWorkingDays.length - 1]);

            // --- ASYNC CHUNKED PROCESSING ---
            runAsyncChunked(productsToAnalyze, (productCode) => {
                const productInfo = productDetailsMap.get(productCode) || { descricao: `Produto ${productCode}`};

                let clientsWhoGotProductCurrent = 0;
                let clientsWhoGotProductPrevious = 0;

                // --- OTIMIZAÇÃO CRÍTICA: Iterar apenas os compradores do produto em vez de todos os clientes ativos ---

                // Check Current
                const buyersCurrent = productClientsCurrent.get(productCode);
                if (buyersCurrent) {
                    buyersCurrent.forEach(buyer => {
                        if (activeClientCodes.has(buyer)) {
                            clientsWhoGotProductCurrent++;
                            clientsWhoGotSelectionCurrent.add(buyer);
                        }
                    });
                }

                // Check Previous
                const buyersPrevious = productClientsPrevious.get(productCode);
                if (buyersPrevious) {
                    buyersPrevious.forEach(buyer => {
                        if (activeClientCodes.has(buyer)) {
                            clientsWhoGotProductPrevious++;
                            clientsWhoGotSelectionPrevious.add(buyer);
                        }
                    });
                }

                const coverageCurrent = activeClientsCount > 0 ? (clientsWhoGotProductCurrent / activeClientsCount) * 100 : 0;

                if (coverageCurrent > topCoverageItem.coverage) {
                    topCoverageItem = {
                        name: `(${productCode}) ${productInfo.descricao}`,
                        coverage: coverageCurrent,
                        clients: clientsWhoGotProductCurrent
                    };
                }

                const stockQty = activeStockMap.get(productCode) || 0;

                // Trend Calculation
                const productAllSales = trendSalesMap.get(productCode) || [];

                const productCadastroDate = parseDate(productInfo.dtCadastro);
                let productFirstWorkingDayIndex = 0;
                if (productCadastroDate) {
                    const cadastroDateString = productCadastroDate.toISOString().split('T')[0];
                    productFirstWorkingDayIndex = sortedWorkingDays.findIndex(d => d >= cadastroDateString);
                    if (productFirstWorkingDayIndex === -1) productFirstWorkingDayIndex = sortedWorkingDays.length;
                }
                const productMaxLifeInWorkingDays = sortedWorkingDays.length - productFirstWorkingDayIndex;

                const hasHistory = productAllSales.some(s => {
                    const d = parseDate(s.DTPED);
                    return d && (d.getUTCFullYear() < currentYear || (d.getUTCFullYear() === currentYear && d.getUTCMonth() < currentMonth));
                });
                const soldThisMonth = (boxesSoldCurrentMap.get(productCode) || 0) > 0;
                const isFactuallyNewOrReactivated = (!hasHistory && soldThisMonth);

                const daysFromBox = customWorkingDaysCoverage;
                let effectiveDaysToCalculate;

                if (isFactuallyNewOrReactivated) {
                    const daysToConsider = (daysFromBox > 0) ? daysFromBox : passedWorkingDaysCurrentMonth;
                    effectiveDaysToCalculate = Math.min(passedWorkingDaysCurrentMonth, daysToConsider);
                } else {
                    if (daysFromBox > 0) {
                        effectiveDaysToCalculate = Math.min(daysFromBox, productMaxLifeInWorkingDays);
                    } else {
                        effectiveDaysToCalculate = productMaxLifeInWorkingDays;
                    }
                }

                const daysDivisor = effectiveDaysToCalculate > 0 ? effectiveDaysToCalculate : 1;
                const targetIndex = Math.max(0, sortedWorkingDays.length - daysDivisor);
                const startDate = parseDate(sortedWorkingDays[targetIndex]);

                let totalQtySoldInRange = 0;
                // Optimized loop: only iterating relevant sales for this product
                productAllSales.forEach(sale => {
                    const saleDate = parseDate(sale.DTPED);
                    if (saleDate && saleDate >= startDate && saleDate <= endDate) {
                        totalQtySoldInRange += (sale.QTVENDA_EMBALAGEM_MASTER || 0);
                    }
                });

                const dailyAvgSale = totalQtySoldInRange / daysDivisor;
                const trendDays = dailyAvgSale > 0 ? (stockQty / dailyAvgSale) : (stockQty > 0 ? Infinity : 0);

                // Box Quantities (Pre-calculated)
                const boxesSoldCurrentMonth = boxesSoldCurrentMap.get(productCode) || 0;
                const boxesSoldPreviousMonth = boxesSoldPreviousMap.get(productCode) || 0;

                const boxesVariation = boxesSoldPreviousMonth > 0
                    ? ((boxesSoldCurrentMonth - boxesSoldPreviousMonth) / boxesSoldPreviousMonth) * 100
                    : (boxesSoldCurrentMonth > 0 ? Infinity : 0);

                const pdvVariation = clientsWhoGotProductPrevious > 0
                    ? ((clientsWhoGotProductCurrent - clientsWhoGotProductPrevious) / clientsWhoGotProductPrevious) * 100
                    : (clientsWhoGotProductCurrent > 0 ? Infinity : 0);

                tableData.push({
                    descricao: `(${productCode}) ${productInfo.descricao}`,
                    stockQty: stockQty,
                    boxesSoldCurrentMonth: boxesSoldCurrentMonth,
                    boxesSoldPreviousMonth: boxesSoldPreviousMonth,
                    boxesVariation: boxesVariation,
                    pdvVariation: pdvVariation,
                    trendDays: trendDays,
                    clientsPreviousCount: clientsWhoGotProductPrevious,
                    clientsCurrentCount: clientsWhoGotProductCurrent,
                    coverageCurrent: coverageCurrent
                });
            }, () => {
                // --- ON COMPLETE CALLBACK (Render UI) ---
                if (currentRenderId !== coverageRenderId) return;

                coverageTopCoverageValueKpi.textContent = `${topCoverageItem.coverage.toFixed(2)}%`;
                coverageTopCoverageProductKpi.textContent = topCoverageItem.name;
                coverageTopCoverageProductKpi.title = topCoverageItem.name;

                const selectionCoveredCountCurrent = clientsWhoGotSelectionCurrent.size;
                const selectionCoveragePercentCurrent = activeClientsCount > 0 ? (selectionCoveredCountCurrent / activeClientsCount) * 100 : 0;
                coverageSelectionCoverageValueKpi.textContent = `${selectionCoveragePercentCurrent.toFixed(2)}%`;
                coverageSelectionCoverageCountKpi.textContent = `${selectionCoveredCountCurrent.toLocaleString('pt-BR')} de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;

                const selectionCoveredCountPrevious = clientsWhoGotSelectionPrevious.size;
                const selectionCoveragePercentPrevious = activeClientsCount > 0 ? (selectionCoveredCountPrevious / activeClientsCount) * 100 : 0;
                coverageSelectionCoverageValueKpiPrevious.textContent = `${selectionCoveragePercentPrevious.toFixed(2)}%`;
                coverageSelectionCoverageCountKpiPrevious.textContent = `${selectionCoveredCountPrevious.toLocaleString('pt-BR')} de ${activeClientsCount.toLocaleString('pt-BR')} clientes`;

                tableData.sort((a, b) => {
                    return b.stockQty - a.stockQty;
                });

                let filteredTableData = tableData.filter(item => item.boxesSoldCurrentMonth > 0);

                if (coverageTrendFilter !== 'all') {
                    filteredTableData = filteredTableData.filter(item => {
                        const trend = item.trendDays;
                        if (coverageTrendFilter === 'low') return isFinite(trend) && trend < 15;
                        if (coverageTrendFilter === 'medium') return isFinite(trend) && trend >= 15 && trend < 30;
                        if (coverageTrendFilter === 'good') return isFinite(trend) && trend >= 30;
                        return false;
                    });
                }

                const totalBoxesFiltered = filteredTableData.reduce((sum, item) => sum + item.boxesSoldCurrentMonth, 0);
                if (coverageTotalBoxesEl) {
                    coverageTotalBoxesEl.textContent = totalBoxesFiltered.toLocaleString('pt-BR', { maximumFractionDigits: 0 });
                }

                coverageTableDataForExport = filteredTableData;

                coverageTableBody.innerHTML = filteredTableData.slice(0, 500).map(item => {
                    let boxesVariationContent;
                    if (isFinite(item.boxesVariation)) {
                        const colorClass = item.boxesVariation >= 0 ? 'text-green-400' : 'text-red-400';
                        boxesVariationContent = `<span class="${colorClass}">${item.boxesVariation.toFixed(1)}%</span>`;
                    } else if (item.boxesVariation === Infinity) {
                        boxesVariationContent = `<span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-purple-500/30 text-purple-300">Novo</span>`;
                    } else {
                        boxesVariationContent = `<span>-</span>`;
                    }

                    let pdvVariationContent;
                    if (isFinite(item.pdvVariation)) {
                        const colorClass = item.pdvVariation >= 0 ? 'text-green-400' : 'text-red-400';
                        pdvVariationContent = `<span class="${colorClass}">${item.pdvVariation.toFixed(1)}%</span>`;
                    } else if (item.pdvVariation === Infinity) {
                        pdvVariationContent = `<span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-purple-500/30 text-purple-300">Novo</span>`;
                    } else {
                        pdvVariationContent = `<span>-</span>`;
                    }

                    return `
                        <tr class="hover:bg-slate-700/50">
                            <td class="px-2 py-1.5 text-xs">${item.descricao}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${item.stockQty.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${item.boxesSoldPreviousMonth.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${item.boxesSoldCurrentMonth.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${boxesVariationContent}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${item.clientsPreviousCount.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${item.clientsCurrentCount.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-1.5 text-xs text-right">${pdvVariationContent}</td>
                        </tr>
                    `;
                }).join('');

                // Render Top 10 Cities Chart
                const salesByCity = {};
                const salesBySeller = {};

                sales.forEach(s => {
                    const client = clientMapForKPIs.get(String(s.CODCLI));
                    const city = client ? (client.cidade || client['Nome da Cidade'] || 'N/A') : 'N/A';
                    salesByCity[city] = (salesByCity[city] || 0) + s.QTVENDA_EMBALAGEM_MASTER;

                    const seller = s.NOME || 'N/A';
                    salesBySeller[seller] = (salesBySeller[seller] || 0) + s.QTVENDA_EMBALAGEM_MASTER;
                });

                // 1. Chart Data for Cities
                const sortedCities = Object.entries(salesByCity)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10);

                // 2. Chart Data for Sellers
                const sortedSellers = Object.entries(salesBySeller)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10);

                const commonChartOptions = {
                    indexAxis: 'x',
                    plugins: {
                        datalabels: {
                            align: 'end',
                            anchor: 'end',
                            color: '#cbd5e1',
                            font: { weight: 'bold', size: 14 },
                            formatter: (value) => value.toLocaleString('pt-BR', { maximumFractionDigits: 1 })
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toLocaleString('pt-BR', { maximumFractionDigits: 2 }) + ' caixas';
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                };

                if (sortedCities.length > 0) {
                    createChart('coverageCityChart', 'bar', sortedCities.map(([city]) => city), sortedCities.map(([, qty]) => qty), commonChartOptions);
                } else {
                    showNoDataMessage('coverageCityChart', 'Sem dados para exibir.');
                }

                if (sortedSellers.length > 0) {
                    createChart('coverageSellerChart', 'bar', sortedSellers.map(([seller]) => getFirstName(seller)), sortedSellers.map(([, qty]) => qty), commonChartOptions);
                } else {
                    showNoDataMessage('coverageSellerChart', 'Sem dados para exibir.');
                }

                // Visibility Toggle Logic
                const cityContainer = document.getElementById('coverageCityChartContainer');
                const sellerContainer = document.getElementById('coverageSellerChartContainer');
                const toggleBtn = document.getElementById('coverage-chart-toggle-btn');
                const chartTitle = document.getElementById('coverage-chart-title');

                if (currentCoverageChartMode === 'city') {
                    if (cityContainer) cityContainer.classList.remove('hidden');
                    if (sellerContainer) sellerContainer.classList.add('hidden');
                    if (toggleBtn) toggleBtn.textContent = 'Ver Vendedores';
                    if (chartTitle) chartTitle.textContent = 'Top 10 Cidades (Quantidade de Caixas)';
                } else {
                    if (cityContainer) cityContainer.classList.add('hidden');
                    if (sellerContainer) sellerContainer.classList.remove('hidden');
                    if (toggleBtn) toggleBtn.textContent = 'Ver Cidades';
                    if (chartTitle) chartTitle.textContent = 'Top 10 Vendedores (Quantidade de Caixas)';
                }
            }, () => currentRenderId !== coverageRenderId);
        }

        // <!-- FIM DO CÓDIGO RESTAURADO -->

        function getUniqueMonthCount(data) {
            const months = new Set();
            data.forEach(sale => {
                const saleDate = parseDate(sale.DTPED);
                if (saleDate) {
                    const monthKey = `${saleDate.getUTCFullYear()}-${saleDate.getUTCMonth()}`;
                    months.add(monthKey);
                }
            });
            return months.size > 0 ? months.size : 1;
        }

        function calculateSummaryFromData(data, isFiltered, clientBaseForPositivacao) {
            const summary = {
                totalFaturamento: 0, totalPeso: 0, vendasPorVendedor: {}, vendasPorSupervisor: {},
                top10ProdutosFaturamento: [], top10ProdutosPeso: [], faturamentoPorFornecedor: {},
                skuPdv: 0, positivacaoCount: 0, positivacaoPercent: 0
            };
            const salesByProduct = {};
            const faturamentoMap = new Map();

            // --- INÍCIO DA MODIFICAÇÃO: KPIs de Cobertura e SKU ---

            // 1. Lógica de Positivação (Cobertura)
            // Registar clientes que tiveram *qualquer* operação (Venda OU Bonificação)
            const positiveClients = new Set();
            const clientUniqueSkus = new Map(); // Map<CodCli, Set<Produto>>

            data.forEach(sale => {
                // Se o cliente teve Venda (VLVENDA > 0) OU Bonificação (VLBONIFIC > 0), ele é considerado positivado.
                if (sale.CODCLI && (sale.VLVENDA > 0 || sale.VLBONIFIC > 0)) {
                    positiveClients.add(sale.CODCLI);

                    // Rastrear SKUs únicos por cliente para o cálculo correto de SKU/PDV (Mix)
                    if (!clientUniqueSkus.has(sale.CODCLI)) {
                        clientUniqueSkus.set(sale.CODCLI, new Set());
                    }
                    clientUniqueSkus.get(sale.CODCLI).add(sale.PRODUTO);
                }
            });
            summary.positivacaoCount = positiveClients.size;

            let totalSkus = 0;
            // Somar a quantidade de SKUs ÚNICOS por cliente
            clientUniqueSkus.forEach(skus => {
                totalSkus += skus.size;
            });

            data.forEach(item => {
                const vlVenda = Number(item.VLVENDA) || 0;
                const totPesoLiq = Number(item.TOTPESOLIQ) || 0;

                summary.totalFaturamento += vlVenda;
                summary.totalPeso += totPesoLiq;

                const isForbidden = (str) => !str || FORBIDDEN_KEYS.includes(str.trim().toUpperCase());

                const vendedor = item.NOME || 'N/A';
                if (!isForbidden(vendedor)) {
                    summary.vendasPorVendedor[vendedor] = (summary.vendasPorVendedor[vendedor] || 0) + vlVenda;
                }

                const supervisor = item.SUPERV || 'N/A';
                if (!isForbidden(supervisor)) {
                    summary.vendasPorSupervisor[supervisor] = (summary.vendasPorSupervisor[supervisor] || 0) + vlVenda;
                }

                const produto = item.DESCRICAO || 'N/A';
                const codigo = item.PRODUTO || 'N/A';
                if (!salesByProduct[produto]) salesByProduct[produto] = { faturamento: 0, peso: 0, codigo: codigo };
                salesByProduct[produto].faturamento += vlVenda;
                salesByProduct[produto].peso += totPesoLiq;

                let fornecedorLabel;
                if(isFiltered){
                    const fornecedorNome = item.FORNECEDOR || 'N/A';
                    const codFor = item.CODFOR;
                    fornecedorLabel = `${fornecedorNome} - ${codFor}`;
                } else {
                     fornecedorLabel = item.OBSERVACAOFOR || 'N/A';
                }

                if (!isForbidden(fornecedorLabel)) {
                    const currentTotal = faturamentoMap.get(fornecedorLabel) || 0;
                    faturamentoMap.set(fornecedorLabel, currentTotal + vlVenda);
                }
            });

            const totalRelevantClients = clientBaseForPositivacao.length;
            summary.positivacaoPercent = totalRelevantClients > 0 ? (summary.positivacaoCount / totalRelevantClients) * 100 : 0;
            // O cálculo do SKU/PDV agora usa a nova contagem de SKUs e a nova contagem de positivação
            summary.skuPdv = summary.positivacaoCount > 0 ? totalSkus / summary.positivacaoCount : 0;
            // --- FIM DA MODIFICAÇÃO ---

            summary.faturamentoPorFornecedor = Object.fromEntries(faturamentoMap);
            summary.top10ProdutosFaturamento = Object.entries(salesByProduct).sort(([,a],[,b]) => b.faturamento - a.faturamento).slice(0, 10).map(([p, d]) => ({ produto: p, ...d }));
            summary.top10ProdutosPeso = Object.entries(salesByProduct).sort(([,a],[,b]) => b.peso - a.peso).slice(0, 10).map(([p, d]) => ({ produto: p, ...d }));
            return summary;
        }

        const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
        const mergeDeep = (...objects) => {
            return objects.reduce((prev, obj) => {
                Object.keys(obj).forEach(key => {
                    const pVal = prev[key];
                    const oVal = obj[key];
                    if (isObject(pVal) && isObject(oVal)) prev[key] = mergeDeep(pVal, oVal);
                    else prev[key] = oVal;
                });
                return prev;
            }, {});
        };

        function createChart(canvasId, type, labels, chartData, optionsOverrides = {}, pluginsToRegister = []) {
            const container = document.getElementById(canvasId + 'Container');
            if (!container) {
                console.error(`Chart container not found for id: ${canvasId}Container`);
                return;
            }

            if (pluginsToRegister.length > 0) {
                try { Chart.register(...pluginsToRegister); } catch (e) {}
            }

            const professionalPalette = ['#14b8a6', '#6366f1', '#ec4899', '#f97316', '#8b5cf6', '#06b6d4', '#f59e0b', '#ef4444', '#22c55e'];

            let finalDatasets;
            if (Array.isArray(chartData) && chartData.length > 0 && typeof chartData[0] === 'object' && chartData[0].hasOwnProperty('label')) {
                finalDatasets = chartData.map((dataset, index) => ({ ...dataset, backgroundColor: dataset.backgroundColor || professionalPalette[index % professionalPalette.length], borderColor: dataset.borderColor || professionalPalette[index % professionalPalette.length] }));
            } else {
                 finalDatasets = [{ data: chartData || [], backgroundColor: canvasId === 'customerStatusChart' ? ['#2dd4bf', '#f59e0b'] : professionalPalette }];
            }

            let baseOptions = { responsive: true, maintainAspectRatio: false, layout: { padding: { top: 25 } }, plugins: { legend: { display: false, labels: {color: '#cbd5e1'} }, datalabels: { display: false } }, scales: { y: { beginAtZero: true, grace: '5%', ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.05)'} }, x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.05)'} } } };
            let typeDefaults = {};
            if (type === 'bar') typeDefaults = { layout: { padding: { right: 30, top: 30 } }, plugins: { datalabels: { display: true, anchor: 'end', align: 'end', offset: -4, color: '#cbd5e1', font: { size: 10 }, formatter: (v) => (v > 1000 ? (v/1000).toFixed(1) + 'k' : v.toFixed(0)) } } };
            if (type === 'doughnut') typeDefaults = { maintainAspectRatio: true, scales: { y: { display: false }, x: { display: false } }, plugins: { legend: { position: 'top', labels: { color: '#cbd5e1' } }, datalabels: { display: true, color: '#fff', font: { size: 11, weight: 'bold' }, formatter: (v, ctx) => { const total = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0); if(total === 0 || v === 0) return ''; const p = (v / total) * 100; return p > 5 ? p.toFixed(0) + '%' : ''; } } } };

            // 1. Sempre construir um objeto de opções novo e limpo
            const options = mergeDeep({}, baseOptions, typeDefaults, optionsOverrides);

            if (charts[canvasId]) {
                charts[canvasId].data.labels = labels;
                charts[canvasId].data.datasets = finalDatasets;
                // 2. Substituir as opções antigas pelas novas, em vez de tentar um merge
                charts[canvasId].options = options;
                charts[canvasId].update();
                return;
            }

            container.innerHTML = '';
            const newCanvas = document.createElement('canvas');
            newCanvas.id = canvasId;
            container.appendChild(newCanvas);
            container.style.display = ''; container.style.alignItems = ''; container.style.justifyContent = '';
            const ctx = newCanvas.getContext('2d');

            charts[canvasId] = new Chart(ctx, { type, data: { labels, datasets: finalDatasets }, options });
        }

        function showNoDataMessage(canvasId, message) {
            if (charts[canvasId]) {
                charts[canvasId].destroy();
                delete charts[canvasId];
            }
            const container = document.getElementById(canvasId + 'Container');
            if(container) {
                container.style.display = 'flex'; container.style.alignItems = 'center'; container.style.justifyContent = 'center';
                container.innerHTML = `<p class="text-slate-500">${message}</p>`;
            }
        }

        function updateProductBarChart(summary) {
            const metric = currentProductMetric;
            const data = metric === 'faturamento' ? summary.top10ProdutosFaturamento : summary.top10ProdutosPeso;
            const labels = data.map(p => `(${p.codigo}) ${p.produto}`);
            const values = data.map(p => p[metric]);
            createChart('salesByProductBarChart', 'bar', labels, values);
        }

        function renderTable(data) {
            const tableBody = document.getElementById('report-table-body');
            if (!tableBody) return;

            mainTableState.filteredData = data;
            mainTableState.totalPages = Math.ceil(data.length / mainTableState.itemsPerPage);
            if (mainTableState.currentPage > mainTableState.totalPages && mainTableState.totalPages > 0) {
                mainTableState.currentPage = mainTableState.totalPages;
            } else if (mainTableState.totalPages === 0) {
                 mainTableState.currentPage = 1;
            }

            const startIndex = (mainTableState.currentPage - 1) * mainTableState.itemsPerPage;
            const endIndex = startIndex + mainTableState.itemsPerPage;
            const pageData = data.slice(startIndex, endIndex);

            const getPosicaoBadge = (posicao) => {
                if (!posicao) return '<span>-</span>';
                let classes = '';
                switch (posicao) {
                    case 'L': classes = 'bg-green-500/20 text-green-300'; break;
                    case 'M': classes = 'bg-blue-500/20 text-blue-300'; break;
                    case 'F': classes = 'bg-yellow-500/20 text-yellow-300'; break;
                    default: return `<span>${posicao}</span>`;
                }
                return `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${classes}">${posicao}</span>`;
            };

            tableBody.innerHTML = pageData.map(row => `
                <tr class="hover:bg-slate-700">
                    <td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-pedido-id="${row.PEDIDO}">${row.PEDIDO}</a></td>
                    <td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-codcli="${row.CODCLI}">${row.CODCLI}</a></td>
                    <td class="px-4 py-2">${getFirstName(row.NOME)}</td>
                    <td class="px-4 py-2">${row.FORNECEDORES_STR || ''}</td>
                    <td class="px-4 py-2">${formatDate(row.DTPED)}</td>
                    <td class="px-4 py-2">${formatDate(row.DTSAIDA)}</td>
                    <td class="px-4 py-2 text-right">${(Number(row.TOTPESOLIQ) || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })} Kg</td>
                    <td class="px-4 py-2 text-right">${(Number(row.VLVENDA) || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td>
                    <td class="px-4 py-2 text-center">${getPosicaoBadge(row.POSICAO)}</td>
                </tr>
            `).join('');

            if (data.length > 0) {
                pageInfoText.textContent = `Página ${mainTableState.currentPage} de ${mainTableState.totalPages} (Total: ${data.length} pedidos)`;
                prevPageBtn.disabled = mainTableState.currentPage === 1;
                nextPageBtn.disabled = mainTableState.currentPage === mainTableState.totalPages;
                tablePaginationControls.classList.remove('hidden');
            } else {
                pageInfoText.textContent = 'Nenhum pedido encontrado.';
                prevPageBtn.disabled = true;
                nextPageBtn.disabled = true;
                tablePaginationControls.classList.add('hidden');
            }
        }

        function isHoliday(date, holidays) {
            if (!date || !holidays) return false;
            const dateString = date.toISOString().split('T')[0];
            return holidays.includes(dateString);
        }

        function getWorkingDaysInMonth(year, month, holidays) {
            let count = 0;
            const date = new Date(Date.UTC(year, month, 1));
            while (date.getUTCMonth() === month) {
                const dayOfWeek = date.getUTCDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(date, holidays)) {
                    count++;
                }
                date.setUTCDate(date.getUTCDate() + 1);
            }
            return count;
        }

        function getPassedWorkingDaysInMonth(year, month, holidays, today) {
            let count = 0;
            const date = new Date(Date.UTC(year, month, 1));
            // Ensure today is treated as UTC for comparison
            const todayUTC = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));

            while (date <= todayUTC && date.getUTCMonth() === month) {
                const dayOfWeek = date.getUTCDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(date, holidays)) {
                    count++;
                }
                date.setUTCDate(date.getUTCDate() + 1);
            }
            return count > 0 ? count : 1;
        }


        function updateTrendChart(currentSales, historicalSales) {
            const currentYear = lastSaleDate.getUTCFullYear();
            const currentMonth = lastSaleDate.getUTCMonth();
            const totalWorkingDays = getWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays);
            const passedWorkingDays = getPassedWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays, lastSaleDate);

            const monthCount = getUniqueMonthCount(historicalSales);
            const pastQuarterRevenue = historicalSales.reduce((sum, sale) => sum + sale.VLVENDA, 0);
            const averageMonthlyRevenue = pastQuarterRevenue / QUARTERLY_DIVISOR;
            const currentMonthRevenue = currentSales.reduce((sum, sale) => sum + sale.VLVENDA, 0);
            const trend = passedWorkingDays > 0 && totalWorkingDays > 0 ? (currentMonthRevenue / passedWorkingDays) * totalWorkingDays : 0;
            const lineChartDataset = [{ label: 'Valor', data: [averageMonthlyRevenue, trend], fill: true, borderColor: '#14b8a6', backgroundColor: 'rgba(20, 184, 166, 0.1)', tension: 0.2, pointRadius: 6, pointBackgroundColor: '#14b8a6', pointBorderColor: '#FFF', pointBorderWidth: 2, pointHoverRadius: 8 }];

            const formatLabelValue = (v) => {
                if (typeof v !== 'number') return ''; // Proteção contra valores não numéricos
                return (v >= 1000000 ? (v / 1000000).toFixed(2) + ' M' : (v / 1000).toFixed(0) + 'k');
            };

            createChart('trendChart', 'line', ['Média Faturamento Trimestre', 'Tendência Mês Atual'], lineChartDataset, {
                layout: { padding: { top: 30 } },
                plugins: {
                    legend: { display: false },
                    datalabels: { display: true, anchor: 'end', align: 'top', offset: 8, color: '#cbd5e1', font: { size: 12, weight: 'bold' }, formatter: formatLabelValue }
                },
                scales: {
                    y: { ticks: { callback: function(value) { if (value >= 1000000) return 'R$ ' + (value / 1000000).toFixed(1) + 'M'; return 'R$ ' + (value / 1000) + 'k'; } } },
                    x: { grid: { display: false } }
                }
            });
        }

        function updateAllVisuals() {
            const posicao = posicaoFilter.value;
            const codcli = codcliFilter.value.trim();

            let clientBaseForCoverage = allClientsData.filter(c => {
                const rca1 = String(c.rca1 || '').trim();

                const isAmericanas = (c.razaoSocial || '').toUpperCase().includes('AMERICANAS');

                // Regra de inclusão (Americanas ou RCA 1 diferente de 53)
                return (isAmericanas || rca1 !== '53' || clientsWithSalesThisMonth.has(c['Código']));
            });

            if (mainRedeGroupFilter === 'com_rede') {
                clientBaseForCoverage = clientBaseForCoverage.filter(c => c.ramo && c.ramo !== 'N/A');
                if (selectedMainRedes.length > 0) {
                    clientBaseForCoverage = clientBaseForCoverage.filter(c => selectedMainRedes.includes(c.ramo));
                }
            } else if (mainRedeGroupFilter === 'sem_rede') {
                clientBaseForCoverage = clientBaseForCoverage.filter(c => !c.ramo || c.ramo === 'N/A');
            }
            const clientCodesInRede = new Set(clientBaseForCoverage.map(c => c['Código']));

            const intersectSets = (sets) => {
                if (sets.length === 0) return new Set();

                // --- OPTIMIZATION START ---
                // Sort sets by size to intersect the smallest sets first.
                sets.sort((a, b) => a.size - b.size);

                let result = new Set(sets[0]);
                for (let i = 1; i < sets.length; i++) {
                    if (result.size === 0) break; // Stop early if the result is already empty

                    const currentSet = sets[i];
                    for (const id of result) {
                        if (!currentSet.has(id)) {
                            result.delete(id);
                        }
                    }
                }
                // --- OPTIMIZATION END ---
                return result;
            };

            const getFilteredIds = (indices, dataMap) => {
                let setsToIntersect = [];
                let hasFilter = false;

                if (codcli) {
                    hasFilter = true;
                    if (indices.byClient.has(codcli)) {
                        setsToIntersect.push(indices.byClient.get(codcli));
                    } else {
                        return [];
                    }
                }
                    if (selectedMainSupervisors.length > 0) {
                        hasFilter = true;
                        const supIds = new Set();
                        selectedMainSupervisors.forEach(sup => {
                            if (indices.bySupervisor.has(sup)) {
                                (indices.bySupervisor.get(sup) || []).forEach(id => supIds.add(id));
                            }
                        });
                        setsToIntersect.push(supIds);
                    }
                    if (selectedSellers.length > 0) {
                        hasFilter = true;
                        const sellerIds = new Set();
                        selectedSellers.forEach(seller => {
                            (indices.byRca.get(seller) || []).forEach(id => sellerIds.add(id));
                        });
                        setsToIntersect.push(sellerIds);
                    }

                if (selectedTiposVenda.length > 0) {
                    hasFilter = true;
                    const tipoVendaIds = new Set();
                    selectedTiposVenda.forEach(tipo => {
                        (indices.byTipoVenda.get(tipo) || []).forEach(id => tipoVendaIds.add(id));
                    });
                    setsToIntersect.push(tipoVendaIds);
                }

                if (currentFornecedor) {
                    hasFilter = true;
                    if (indices.byPasta.has(currentFornecedor)) {
                        setsToIntersect.push(indices.byPasta.get(currentFornecedor));
                    } else {
                        return [];
                    }
                }
                if (selectedMainSuppliers.length > 0) {
                    hasFilter = true;
                    const supplierIds = new Set();
                    selectedMainSuppliers.forEach(sup => {
                        if (indices.bySupplier.has(sup)) {
                            (indices.bySupplier.get(sup) || []).forEach(id => supplierIds.add(id));
                        }
                    });
                    setsToIntersect.push(supplierIds);
                }

                if (indices.byPosition && posicao) {
                    hasFilter = true;
                    if (indices.byPosition.has(posicao)) {
                        setsToIntersect.push(indices.byPosition.get(posicao));
                    } else {
                        return [];
                    }
                }

                if (mainRedeGroupFilter) {
                    hasFilter = true;
                    const redeIds = new Set();
                    clientCodesInRede.forEach(clientCode => {
                         (indices.byClient.get(clientCode) || []).forEach(id => redeIds.add(id));
                    });
                    setsToIntersect.push(redeIds);
                }

                if (setsToIntersect.length === 0 && hasFilter) {
                    return [];
                }

                if (setsToIntersect.length === 0 && !hasFilter) {
                    return Array.from(dataMap.values());
                }

                const finalIds = intersectSets(setsToIntersect);
                return Array.from(finalIds).map(id => dataMap.get(id));
            };

            const filteredSalesData = getFilteredIds(optimizedData.indices.current, optimizedData.salesById);
            const filteredHistoryData = getFilteredIds(optimizedData.indices.history, optimizedData.historyById);

            const filteredTableData = aggregatedOrders.filter(order => {
                let matches = true;
                if (mainRedeGroupFilter) {
                    matches = matches && clientCodesInRede.has(order.CODCLI);
                }
                if (codcli) matches = matches && order.CODCLI === codcli;
                else {
                    if (selectedMainSupervisors.length > 0) matches = matches && selectedMainSupervisors.includes(order.SUPERV);
                    if (selectedSellers.length > 0) matches = matches && selectedSellers.includes(order.NOME);
                }
                if (selectedTiposVenda.length > 0) matches = matches && selectedTiposVenda.includes(order.TIPOVENDA);
                if (currentFornecedor) matches = matches && order.FORNECEDORES_LIST && order.FORNECEDORES_LIST.includes(currentFornecedor);
                if (selectedMainSuppliers.length > 0) matches = matches && order.CODFORS_LIST && order.CODFORS_LIST.some(c => selectedMainSuppliers.includes(c));
                if (posicao) matches = matches && order.POSICAO === posicao;
                return matches;
            });

            const isFiltered = selectedMainSupervisors.length > 0 || selectedSellers.length > 0 || !!codcli || !!currentFornecedor || !!mainRedeGroupFilter || selectedMainSuppliers.length > 0 || !!posicao || selectedTiposVenda.length > 0;

            const summary = calculateSummaryFromData(filteredSalesData, isFiltered, clientBaseForCoverage);

            totalVendasEl.textContent = summary.totalFaturamento.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            totalPesoEl.textContent = `${(summary.totalPeso / 1000).toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 })}`;
            kpiSkuPdVEl.textContent = summary.skuPdv.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            kpiPositivacaoEl.textContent = `${summary.positivacaoPercent.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%`;
            kpiPositivacaoPercentEl.textContent = `${summary.positivacaoCount.toLocaleString('pt-BR')} PDVs`;


            if (!tableView.classList.contains('hidden')) {
                renderTable(filteredTableData);
            }

            if (!chartView.classList.contains('hidden')) {
                updateTrendChart(filteredSalesData, filteredHistoryData);
                const totalForPercentage = selectedMainSupervisors.length > 0 ? Object.values(summary.vendasPorVendedor).reduce((a, b) => a + b, 0) : Object.values(summary.vendasPorSupervisor).reduce((a, b) => a + b, 0);
                const personChartTooltipOptions = { plugins: { tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) label += ': '; const value = context.parsed.y; if (value !== null) { label += new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value); if (totalForPercentage > 0) { const percentage = ((value / totalForPercentage) * 100).toFixed(2); label += ` (${percentage}%)`; } } return label; } } } } };
                if (selectedMainSupervisors.length > 0) {
                    salesByPersonTitle.textContent = 'Vendas por Vendedor';
                    createChart('salesByPersonChart', 'bar', Object.keys(summary.vendasPorVendedor).map(getFirstName), Object.values(summary.vendasPorVendedor), personChartTooltipOptions);
                } else {
                    salesByPersonTitle.textContent = 'Vendas por Supervisor';
                    createChart('salesByPersonChart', 'bar', Object.keys(summary.vendasPorSupervisor), Object.values(summary.vendasPorSupervisor), personChartTooltipOptions);
                }

                document.getElementById('faturamentoPorFornecedorTitle').textContent = isFiltered ? 'Faturamento por Fornecedor' : 'Faturamento por Categoria';
                const faturamentoPorFornecedorData = summary.faturamentoPorFornecedor;
                const totalFaturamentoFornecedor = Object.values(faturamentoPorFornecedorData).reduce((a, b) => a + b, 0);
                const fornecedorTooltipOptions = { indexAxis: 'y', plugins: { tooltip: { callbacks: { label: function(context) { let label = context.label || ''; if (label) label += ': '; const value = context.parsed.x; if (value !== null) { label += new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value); if (totalFaturamentoFornecedor > 0) { const percentage = ((value / totalFaturamentoFornecedor) * 100).toFixed(2); label += ` (${percentage}%)`; } } return label; } } } } };
                const sortedFornecedores = Object.entries(faturamentoPorFornecedorData).sort(([, a], [, b]) => a - b);
                if (sortedFornecedores.length > 0) createChart('faturamentoPorFornecedorChart', 'bar', sortedFornecedores.map(([name]) => name), sortedFornecedores.map(([, total]) => total), fornecedorTooltipOptions);
                else showNoDataMessage('faturamentoPorFornecedorChart', 'Sem dados de faturamento.');
                updateProductBarChart(summary);
            }
        }

        function updateSupervisorFilter(dropdown, filterText, selectedArray, dataSource, skipRender = false) {
            if (!dropdown || !filterText) return selectedArray;
            const forbidden = ['SUPERV', 'CODUSUR', 'CODSUPERVISOR', 'NOME', 'CODCLI', 'PRODUTO', 'DESCRICAO', 'FORNECEDOR', 'OBSERVACAOFOR', 'CODFOR', 'QTVENDA', 'VLVENDA', 'VLBONIFIC', 'TOTPESOLIQ', 'ESTOQUEUNIT', 'TIPOVENDA', 'FILIAL', 'ESTOQUECX', 'SUPERVISOR'];
            const supervisors = [...new Set(dataSource.map(item => item.SUPERV).filter(s => s && !forbidden.includes(s.toUpperCase())))].sort();

            selectedArray = selectedArray.filter(sup => supervisors.includes(sup));

            if (!skipRender) {
                const htmlParts = [];
                for (let i = 0; i < supervisors.length; i++) {
                    const sup = supervisors[i];
                    const isChecked = selectedArray.includes(sup);
                    htmlParts.push(`<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${sup}" ${isChecked ? 'checked' : ''}><span class="ml-2">${sup}</span></label>`);
                }
                dropdown.innerHTML = htmlParts.join('');
            }

            if (selectedArray.length === 0 || selectedArray.length === supervisors.length) filterText.textContent = 'Todos';
            else if (selectedArray.length === 1) filterText.textContent = selectedArray[0];
            else filterText.textContent = `${selectedArray.length} selecionados`;
            return selectedArray;
        }

        function updateSellerFilter(supervisors, dropdown, filterText, selectedArray, dataSource, skipRender = false) {
            const forbidden = ['NOME', 'VENDEDOR', 'SUPERV', 'CODUSUR', 'CODCLI', 'SUPERVISOR'];
            let sellersToShow;
            if (supervisors && supervisors.length > 0) {
                const supSet = new Set(supervisors);
                sellersToShow = [...new Set(dataSource.filter(s => supSet.has(s.SUPERV)).map(s => s.NOME).filter(n => n && !forbidden.includes(n.toUpperCase())))].sort();
            } else {
                sellersToShow = [...new Set(dataSource.map(item => item.NOME).filter(n => n && !forbidden.includes(n.toUpperCase())))].sort();
            }

            selectedArray = selectedArray.filter(seller => sellersToShow.includes(seller));

            if (!skipRender) {
                const htmlParts = [];
                for (let i = 0; i < sellersToShow.length; i++) {
                    const s = sellersToShow[i];
                    const isChecked = selectedArray.includes(s);
                    htmlParts.push(`<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${s}" ${isChecked ? 'checked' : ''}><span class="ml-2">${s}</span></label>`);
                }
                dropdown.innerHTML = htmlParts.join('');
            }

            if (selectedArray.length === 0 || selectedArray.length === sellersToShow.length) filterText.textContent = 'Todos Vendedores';
            else if (selectedArray.length === 1) filterText.textContent = selectedArray[0];
            else filterText.textContent = `${selectedArray.length} vendedores selecionados`;
            return selectedArray;
        }

        function updateTipoVendaFilter(dropdown, filterText, selectedArray, dataSource, skipRender = false) {
            // Collect unique types from data source
            const forbidden = ['TIPOVENDA', 'TIPO VENDA', 'TIPO', 'CODUSUR', 'CODCLI', 'SUPERV', 'NOME'];
            const uniqueTypes = new Set(dataSource.map(item => item.TIPOVENDA).filter(t => t && !forbidden.includes(t.toUpperCase())));

            // Ensure currently selected items are kept in the list (Safety Net)
            selectedArray.forEach(type => uniqueTypes.add(type));

            const tiposVendaToShow = [...uniqueTypes].sort((a, b) => parseInt(a) - parseInt(b));

            // Re-filter selectedArray ensures we don't have stale data if we wanted strictness,
            // but here we just ensured they are IN the list, so this line effectively does nothing
            // except ordering or removing truly invalid ones if we didn't add them above.
            // Since we added them above, this is redundant but harmless.
            selectedArray = selectedArray.filter(tipo => tiposVendaToShow.includes(tipo));

            if (!skipRender) {
                const htmlParts = [];
                for (let i = 0; i < tiposVendaToShow.length; i++) {
                    const s = tiposVendaToShow[i];
                    const isChecked = selectedArray.includes(s);
                    htmlParts.push(`<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${s}" ${isChecked ? 'checked' : ''}><span class="ml-2">${s}</span></label>`);
                }
                dropdown.innerHTML = htmlParts.join('');
            }

            if (selectedArray.length === 0 || selectedArray.length === tiposVendaToShow.length) filterText.textContent = 'Todos os Tipos';
            else if (selectedArray.length === 1) filterText.textContent = selectedArray[0];
            else filterText.textContent = `${selectedArray.length} tipos selecionados`;
            return selectedArray;
        }

        function updateRedeFilter(dropdown, buttonTextElement, selectedArray, dataSource, baseText = 'Com Rede') {
            const forbidden = ['RAMO', 'RAMO DE ATIVIDADE', 'RAMO_ATIVIDADE', 'DESCRICAO', 'ATIVIDADE'];
            const redesToShow = [...new Set(dataSource.map(item => item.ramo).filter(r => r && r !== 'N/A' && !forbidden.includes(r.toUpperCase())))].sort();
            const validSelected = selectedArray.filter(rede => redesToShow.includes(rede));

            const htmlParts = [];
            for (let i = 0; i < redesToShow.length; i++) {
                const r = redesToShow[i];
                const isChecked = validSelected.includes(r);
                htmlParts.push(`<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${r}" ${isChecked ? 'checked' : ''}><span class="ml-2 text-sm">${r}</span></label>`);
            }
            dropdown.innerHTML = htmlParts.join('');

            if (validSelected.length === 0) {
                buttonTextElement.textContent = baseText;
            } else {
                buttonTextElement.textContent = `${baseText} (${validSelected.length})`;
            }
            return validSelected;
        }

        function resetMainFilters() {
            selectedMainSupervisors = [];
            selectedMainSuppliers = [];
            posicaoFilter.value = '';
            codcliFilter.value = '';
            currentFornecedor = '';
            selectedSellers = [];
            selectedTiposVenda = [];
